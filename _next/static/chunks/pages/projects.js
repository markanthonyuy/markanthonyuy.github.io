_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/projects"],{

/***/ "./components/Container.js":
/*!*********************************!*\
  !*** ./components/Container.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Container; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _container_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./container.module.scss */ \"./components/container.module.scss\");\n/* harmony import */ var _container_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_container_module_scss__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Footer */ \"./components/Footer.js\");\nvar _jsxFileName = \"/home/macmac/Projects/markanthonyuy.github.io/components/Container.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\nfunction Container(_ref) {\n  var children = _ref.children;\n  return __jsx(\"div\", {\n    className: _container_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.outer,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 5\n    }\n  }, __jsx(\"main\", {\n    className: _container_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.container,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 7\n    }\n  }, children), __jsx(_components_Footer__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 7\n    }\n  }));\n}\n_c = Container;\n\nvar _c;\n\n$RefreshReg$(_c, \"Container\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Db250YWluZXIuanM/YWQwZCJdLCJuYW1lcyI6WyJDb250YWluZXIiLCJjaGlsZHJlbiIsInN0eWxlcyIsIm91dGVyIiwiY29udGFpbmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVlLFNBQVNBLFNBQVQsT0FBaUM7QUFBQSxNQUFaQyxRQUFZLFFBQVpBLFFBQVk7QUFDOUMsU0FDRTtBQUFLLGFBQVMsRUFBRUMsNkRBQU0sQ0FBQ0MsS0FBdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQU0sYUFBUyxFQUFFRCw2REFBTSxDQUFDRSxTQUF4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQW9DSCxRQUFwQyxDQURGLEVBRUUsTUFBQywwREFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRkYsQ0FERjtBQU1EO0tBUHVCRCxTIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9Db250YWluZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVzIGZyb20gJy4vY29udGFpbmVyLm1vZHVsZS5zY3NzJ1xuaW1wb3J0IEZvb3RlciBmcm9tICcuLi9jb21wb25lbnRzL0Zvb3RlcidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGFpbmVyKHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMub3V0ZXJ9PlxuICAgICAgPG1haW4gY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT57Y2hpbGRyZW59PC9tYWluPlxuICAgICAgPEZvb3RlciAvPlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Container.js\n");

/***/ }),

/***/ "./components/Footer.js":
/*!******************************!*\
  !*** ./components/Footer.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Footer; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _footer_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./footer.module.scss */ \"./components/footer.module.scss\");\n/* harmony import */ var _footer_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_footer_module_scss__WEBPACK_IMPORTED_MODULE_1__);\nvar _jsxFileName = \"/home/macmac/Projects/markanthonyuy.github.io/components/Footer.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\nvar year = new Date().getFullYear();\nfunction Footer() {\n  return __jsx(\"footer\", {\n    className: _footer_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.footer,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 5\n    }\n  }, __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 7\n    }\n  }, \"Mark Anthony Uy \\xA9 \", year));\n}\n_c = Footer;\n\nvar _c;\n\n$RefreshReg$(_c, \"Footer\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Gb290ZXIuanM/ZjI1NiJdLCJuYW1lcyI6WyJ5ZWFyIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiRm9vdGVyIiwic3R5bGVzIiwiZm9vdGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUVBLElBQU1BLElBQUksR0FBRyxJQUFJQyxJQUFKLEdBQVdDLFdBQVgsRUFBYjtBQUVlLFNBQVNDLE1BQVQsR0FBa0I7QUFDL0IsU0FDRTtBQUFRLGFBQVMsRUFBRUMsMERBQU0sQ0FBQ0MsTUFBMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsOEJBQTJCTCxJQUEzQixDQURGLENBREY7QUFLRDtLQU51QkcsTSIsImZpbGUiOiIuL2NvbXBvbmVudHMvRm9vdGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlcyBmcm9tICcuL2Zvb3Rlci5tb2R1bGUuc2NzcydcblxuY29uc3QgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGb290ZXIoKSB7XG4gIHJldHVybiAoXG4gICAgPGZvb3RlciBjbGFzc05hbWU9e3N0eWxlcy5mb290ZXJ9PlxuICAgICAgPHA+TWFyayBBbnRob255IFV5ICZjb3B5OyB7eWVhcn08L3A+XG4gICAgPC9mb290ZXI+XG4gIClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Footer.js\n");

/***/ }),

/***/ "./components/Nav.js":
/*!***************************!*\
  !*** ./components/Nav.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Nav; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Nav.module.scss */ \"./components/Nav.module.scss\");\n/* harmony import */ var _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Nav_module_scss__WEBPACK_IMPORTED_MODULE_1__);\nvar _jsxFileName = \"/home/macmac/Projects/markanthonyuy.github.io/components/Nav.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\nfunction Nav(_ref) {\n  var active = _ref.active;\n  return __jsx(\"nav\", {\n    className: _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.nav,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 5,\n      columnNumber: 5\n    }\n  }, __jsx(\"a\", {\n    className: active === 'home' ? _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.active : '',\n    href: \"/\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 7\n    }\n  }, \"Home\"), __jsx(\"a\", {\n    className: active === 'about' ? _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.active : '',\n    href: \"/about\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 7\n    }\n  }, \"About\"), __jsx(\"a\", {\n    className: active === 'projects' ? _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.active : '',\n    href: \"/projects\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 7\n    }\n  }, \"Projects\"), __jsx(\"a\", {\n    className: active === 'contact' ? _Nav_module_scss__WEBPACK_IMPORTED_MODULE_1___default.a.active : '',\n    href: \"/contact\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 18,\n      columnNumber: 7\n    }\n  }, \"Contact\"));\n}\n_c = Nav;\n\nvar _c;\n\n$RefreshReg$(_c, \"Nav\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXYuanM/YTEzMyJdLCJuYW1lcyI6WyJOYXYiLCJhY3RpdmUiLCJzdHlsZXMiLCJuYXYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBRWUsU0FBU0EsR0FBVCxPQUF5QjtBQUFBLE1BQVZDLE1BQVUsUUFBVkEsTUFBVTtBQUN0QyxTQUNFO0FBQUssYUFBUyxFQUFFQyx1REFBTSxDQUFDQyxHQUF2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0U7QUFBRyxhQUFTLEVBQUVGLE1BQU0sS0FBSyxNQUFYLEdBQW9CQyx1REFBTSxDQUFDRCxNQUEzQixHQUFvQyxFQUFsRDtBQUFzRCxRQUFJLEVBQUMsR0FBM0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQURGLEVBSUU7QUFBRyxhQUFTLEVBQUVBLE1BQU0sS0FBSyxPQUFYLEdBQXFCQyx1REFBTSxDQUFDRCxNQUE1QixHQUFxQyxFQUFuRDtBQUF1RCxRQUFJLEVBQUMsUUFBNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUpGLEVBT0U7QUFDRSxhQUFTLEVBQUVBLE1BQU0sS0FBSyxVQUFYLEdBQXdCQyx1REFBTSxDQUFDRCxNQUEvQixHQUF3QyxFQURyRDtBQUVFLFFBQUksRUFBQyxXQUZQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBUEYsRUFhRTtBQUFHLGFBQVMsRUFBRUEsTUFBTSxLQUFLLFNBQVgsR0FBdUJDLHVEQUFNLENBQUNELE1BQTlCLEdBQXVDLEVBQXJEO0FBQXlELFFBQUksRUFBQyxVQUE5RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBYkYsQ0FERjtBQW1CRDtLQXBCdUJELEciLCJmaWxlIjoiLi9jb21wb25lbnRzL05hdi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSAnLi9OYXYubW9kdWxlLnNjc3MnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5hdih7IGFjdGl2ZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPG5hdiBjbGFzc05hbWU9e3N0eWxlcy5uYXZ9PlxuICAgICAgPGEgY2xhc3NOYW1lPXthY3RpdmUgPT09ICdob21lJyA/IHN0eWxlcy5hY3RpdmUgOiAnJ30gaHJlZj1cIi9cIj5cbiAgICAgICAgSG9tZVxuICAgICAgPC9hPlxuICAgICAgPGEgY2xhc3NOYW1lPXthY3RpdmUgPT09ICdhYm91dCcgPyBzdHlsZXMuYWN0aXZlIDogJyd9IGhyZWY9XCIvYWJvdXRcIj5cbiAgICAgICAgQWJvdXRcbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGNsYXNzTmFtZT17YWN0aXZlID09PSAncHJvamVjdHMnID8gc3R5bGVzLmFjdGl2ZSA6ICcnfVxuICAgICAgICBocmVmPVwiL3Byb2plY3RzXCJcbiAgICAgID5cbiAgICAgICAgUHJvamVjdHNcbiAgICAgIDwvYT5cbiAgICAgIDxhIGNsYXNzTmFtZT17YWN0aXZlID09PSAnY29udGFjdCcgPyBzdHlsZXMuYWN0aXZlIDogJyd9IGhyZWY9XCIvY29udGFjdFwiPlxuICAgICAgICBDb250YWN0XG4gICAgICA8L2E+XG4gICAgPC9uYXY+XG4gIClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Nav.js\n");

/***/ }),

/***/ "./components/Nav.module.scss":
/*!************************************!*\
  !*** ./components/Nav.module.scss ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Nav.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Nav.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element){// These elements should always exist. If they do not,\n// this code should fail.\nvar anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>\n// Each style tag should be placed right before our\n// anchor. By inserting before and not after, we do not\n// need to track the last inserted element.\nparentNode.insertBefore(element,anchorElement);};\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(!a[p]){return false;}}return true;};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Nav.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Nav.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./Nav.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Nav.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXYubW9kdWxlLnNjc3M/MjdkYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsbU5BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLDZqQkFBZ1U7O0FBRWxXOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVM7QUFDbkM7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0Esc0VBQXNFLHdDQUF3QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZDtBQUNBLGtFQUFrRSxpQkFBaUIsY0FBYyxNQUFNLFlBQVksaUNBQWlDO0FBQ3BKLFVBQVUsZ0JBQWdCLGVBQWUsWUFBWSxpQ0FBaUM7QUFDdEYsVUFBVSxVQUFVLGVBQWU7QUFDbkM7O0FBRUE7QUFDQSxNQUFNLDZqQkFBZ1U7QUFDdFU7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2akJBQWdVOztBQUUxVjs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9OYXYubW9kdWxlLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL05hdi5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vTmF2Lm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vTmF2Lm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Nav.module.scss\n");

/***/ }),

/***/ "./components/container.module.scss":
/*!******************************************!*\
  !*** ./components/container.module.scss ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./container.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/container.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element){// These elements should always exist. If they do not,\n// this code should fail.\nvar anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>\n// Each style tag should be placed right before our\n// anchor. By inserting before and not after, we do not\n// need to track the last inserted element.\nparentNode.insertBefore(element,anchorElement);};\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(!a[p]){return false;}}return true;};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./container.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/container.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./container.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/container.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb250YWluZXIubW9kdWxlLnNjc3M/ZWVlZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsbU5BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLHlrQkFBc1U7O0FBRXhXOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVM7QUFDbkM7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0Esc0VBQXNFLHdDQUF3QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZDtBQUNBLGtFQUFrRSxpQkFBaUIsY0FBYyxNQUFNLFlBQVksaUNBQWlDO0FBQ3BKLFVBQVUsZ0JBQWdCLGVBQWUsWUFBWSxpQ0FBaUM7QUFDdEYsVUFBVSxVQUFVLGVBQWU7QUFDbkM7O0FBRUE7QUFDQSxNQUFNLHlrQkFBc1U7QUFDNVU7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5a0JBQXNVOztBQUVoVzs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9jb250YWluZXIubW9kdWxlLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL2NvbnRhaW5lci5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vY29udGFpbmVyLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vY29udGFpbmVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/container.module.scss\n");

/***/ }),

/***/ "./components/footer.module.scss":
/*!***************************************!*\
  !*** ./components/footer.module.scss ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./footer.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/footer.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element){// These elements should always exist. If they do not,\n// this code should fail.\nvar anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>\n// Each style tag should be placed right before our\n// anchor. By inserting before and not after, we do not\n// need to track the last inserted element.\nparentNode.insertBefore(element,anchorElement);};\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(!a[p]){return false;}}return true;};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./footer.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/footer.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./footer.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/footer.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9mb290ZXIubW9kdWxlLnNjc3M/ZTA5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsbU5BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLG1rQkFBbVU7O0FBRXJXOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVM7QUFDbkM7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0Esc0VBQXNFLHdDQUF3QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZDtBQUNBLGtFQUFrRSxpQkFBaUIsY0FBYyxNQUFNLFlBQVksaUNBQWlDO0FBQ3BKLFVBQVUsZ0JBQWdCLGVBQWUsWUFBWSxpQ0FBaUM7QUFDdEYsVUFBVSxVQUFVLGVBQWU7QUFDbkM7O0FBRUE7QUFDQSxNQUFNLG1rQkFBbVU7QUFDelU7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxta0JBQW1VOztBQUU3Vjs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9mb290ZXIubW9kdWxlLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL2Zvb3Rlci5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vZm9vdGVyLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0xIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy0yIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtb25lT2YtMy0zIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMy00IS4vZm9vdGVyLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/footer.module.scss\n");

/***/ }),

/***/ "./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ \"./node_modules/@emotion/memoize/dist/memoize.browser.esm.js\");\n\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar index = Object(_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmJyb3dzZXIuZXNtLmpzP2Y2ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUF1Qzs7QUFFdkMsazdIQUFrN0g7O0FBRWw3SCxZQUFZLGdFQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsb0VBQUssRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9pcy1wcm9wLXZhbGlkL2Rpc3QvaXMtcHJvcC12YWxpZC5icm93c2VyLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtZW1vaXplIGZyb20gJ0BlbW90aW9uL21lbW9pemUnO1xuXG52YXIgcmVhY3RQcm9wc1JlZ2V4ID0gL14oKGNoaWxkcmVufGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfGtleXxyZWZ8YXV0b0ZvY3VzfGRlZmF1bHRWYWx1ZXxkZWZhdWx0Q2hlY2tlZHxpbm5lckhUTUx8c3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nfHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ3x2YWx1ZUxpbmt8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8Zm9ybXxmb3JtQWN0aW9ufGZvcm1FbmNUeXBlfGZvcm1NZXRob2R8Zm9ybU5vVmFsaWRhdGV8Zm9ybVRhcmdldHxmcmFtZUJvcmRlcnxoZWFkZXJzfGhlaWdodHxoaWRkZW58aGlnaHxocmVmfGhyZWZMYW5nfGh0bWxGb3J8aHR0cEVxdWl2fGlkfGlucHV0TW9kZXxpbnRlZ3JpdHl8aXN8a2V5UGFyYW1zfGtleVR5cGV8a2luZHxsYWJlbHxsYW5nfGxpc3R8bG9hZGluZ3xsb29wfGxvd3xtYXJnaW5IZWlnaHR8bWFyZ2luV2lkdGh8bWF4fG1heExlbmd0aHxtZWRpYXxtZWRpYUdyb3VwfG1ldGhvZHxtaW58bWluTGVuZ3RofG11bHRpcGxlfG11dGVkfG5hbWV8bm9uY2V8bm9WYWxpZGF0ZXxvcGVufG9wdGltdW18cGF0dGVybnxwbGFjZWhvbGRlcnxwbGF5c0lubGluZXxwb3N0ZXJ8cHJlbG9hZHxwcm9maWxlfHJhZGlvR3JvdXB8cmVhZE9ubHl8cmVmZXJyZXJQb2xpY3l8cmVsfHJlcXVpcmVkfHJldmVyc2VkfHJvbGV8cm93c3xyb3dTcGFufHNhbmRib3h8c2NvcGV8c2NvcGVkfHNjcm9sbGluZ3xzZWFtbGVzc3xzZWxlY3RlZHxzaGFwZXxzaXplfHNpemVzfHNsb3R8c3BhbnxzcGVsbENoZWNrfHNyY3xzcmNEb2N8c3JjTGFuZ3xzcmNTZXR8c3RhcnR8c3RlcHxzdHlsZXxzdW1tYXJ5fHRhYkluZGV4fHRhcmdldHx0aXRsZXx0eXBlfHVzZU1hcHx2YWx1ZXx3aWR0aHx3bW9kZXx3cmFwfGFib3V0fGRhdGF0eXBlfGlubGlzdHxwcmVmaXh8cHJvcGVydHl8cmVzb3VyY2V8dHlwZW9mfHZvY2FifGF1dG9DYXBpdGFsaXplfGF1dG9Db3JyZWN0fGF1dG9TYXZlfGNvbG9yfGluZXJ0fGl0ZW1Qcm9wfGl0ZW1TY29wZXxpdGVtVHlwZXxpdGVtSUR8aXRlbVJlZnxvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpbmRleCA9IG1lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js\n");

/***/ }),

/***/ "./node_modules/@emotion/memoize/dist/memoize.browser.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/memoize.browser.esm.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (memoize);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzP2UyYTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxzRUFBTyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@emotion/memoize/dist/memoize.browser.esm.js\n");

/***/ }),

/***/ "./node_modules/@popmotion/easing/dist/easing.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@popmotion/easing/dist/easing.es.js ***!
  \**********************************************************/
/*! exports provided: reversed, mirrored, createReversedEasing, createMirroredEasing, createExpoIn, createBackIn, createAnticipateEasing, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, bounceOut, bounceIn, bounceInOut, cubicBezier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reversed\", function() { return reversed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mirrored\", function() { return mirrored; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createReversedEasing\", function() { return createReversedEasing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createMirroredEasing\", function() { return createMirroredEasing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createExpoIn\", function() { return createExpoIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBackIn\", function() { return createBackIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAnticipateEasing\", function() { return createAnticipateEasing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linear\", function() { return linear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"easeIn\", function() { return easeIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"easeOut\", function() { return easeOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"easeInOut\", function() { return easeInOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circIn\", function() { return circIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circOut\", function() { return circOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circInOut\", function() { return circInOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backIn\", function() { return backIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backOut\", function() { return backOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backInOut\", function() { return backInOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anticipate\", function() { return anticipate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bounceOut\", function() { return bounceOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bounceIn\", function() { return bounceIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bounceInOut\", function() { return bounceInOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cubicBezier\", function() { return cubicBezier; });\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar reversed = function (easing) {\n    return function (p) {\n        return 1 - easing(1 - p);\n    };\n};\nvar mirrored = function (easing) {\n    return function (p) {\n        return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n    };\n};\nvar createReversedEasing = reversed;\nvar createMirroredEasing = mirrored;\nvar createExpoIn = function (power) {\n    return function (p) {\n        return Math.pow(p, power);\n    };\n};\nvar createBackIn = function (power) {\n    return function (p) {\n        return p * p * ((power + 1) * p - power);\n    };\n};\nvar createAnticipateEasing = function (power) {\n    var backEasing = createBackIn(power);\n    return function (p) {\n        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n    };\n};\nvar linear = function (p) {\n    return p;\n};\nvar easeIn = /*#__PURE__*/createExpoIn(2);\nvar easeOut = /*#__PURE__*/reversed(easeIn);\nvar easeInOut = /*#__PURE__*/mirrored(easeIn);\nvar circIn = function (p) {\n    return 1 - Math.sin(Math.acos(p));\n};\nvar circOut = /*#__PURE__*/reversed(circIn);\nvar circInOut = /*#__PURE__*/mirrored(circOut);\nvar backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = /*#__PURE__*/reversed(backIn);\nvar backInOut = /*#__PURE__*/mirrored(backIn);\nvar anticipate = /*#__PURE__*/createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);\nvar BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nvar BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nvar BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nvar ca = 4356.0 / 361.0;\nvar cb = 35442.0 / 1805.0;\nvar cc = 16061.0 / 1805.0;\nvar bounceOut = function (p) {\n    var p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = function (p) {\n    return 1.0 - bounceOut(1.0 - p);\n};\nvar bounceInOut = function (p) {\n    return p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n};\nvar NEWTON_ITERATIONS = 8;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar K_SPLINE_TABLE_SIZE = 11;\nvar K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);\nvar FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';\nvar a = function (a1, a2) {\n    return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\nvar b = function (a1, a2) {\n    return 3.0 * a2 - 6.0 * a1;\n};\nvar c = function (a1) {\n    return 3.0 * a1;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);\n    var binarySubdivide = function (aX, aA, aB) {\n        var i = 0;\n        var currentX;\n        var currentT;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    };\n    var newtonRaphsonIterate = function (aX, aGuessT) {\n        var i = 0;\n        var currentSlope = 0;\n        var currentX;\n        for (; i < NEWTON_ITERATIONS; ++i) {\n            currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    };\n    var calcSampleValues = function () {\n        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {\n            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);\n        }\n    };\n    var getTForX = function (aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = K_SPLINE_TABLE_SIZE - 1;\n        var dist = 0.0;\n        var guessForT = 0.0;\n        var initialSlope = 0.0;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += K_SAMPLE_STEP_SIZE;\n        }\n        --currentSample;\n        dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;\n        initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);\n        }\n    };\n    calcSampleValues();\n    var resolver = function (aX) {\n        var returnValue;\n        if (mX1 === mY1 && mX2 === mY2) {\n            returnValue = aX;\n        } else if (aX === 0) {\n            returnValue = 0;\n        } else if (aX === 1) {\n            returnValue = 1;\n        } else {\n            returnValue = calcBezier(getTForX(aX), mY1, mY2);\n        }\n        return returnValue;\n    };\n    return resolver;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3Btb3Rpb24vZWFzaW5nL2Rpc3QvZWFzaW5nLmVzLmpzPzk3MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQW1FO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFSIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bwb3Btb3Rpb24vZWFzaW5nL2Rpc3QvZWFzaW5nLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG52YXIgcmV2ZXJzZWQgPSBmdW5jdGlvbiAoZWFzaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAxIC0gZWFzaW5nKDEgLSBwKTtcbiAgICB9O1xufTtcbnZhciBtaXJyb3JlZCA9IGZ1bmN0aW9uIChlYXNpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAgPD0gMC41ID8gZWFzaW5nKDIgKiBwKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwKSkpIC8gMjtcbiAgICB9O1xufTtcbnZhciBjcmVhdGVSZXZlcnNlZEVhc2luZyA9IHJldmVyc2VkO1xudmFyIGNyZWF0ZU1pcnJvcmVkRWFzaW5nID0gbWlycm9yZWQ7XG52YXIgY3JlYXRlRXhwb0luID0gZnVuY3Rpb24gKHBvd2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gICAgfTtcbn07XG52YXIgY3JlYXRlQmFja0luID0gZnVuY3Rpb24gKHBvd2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwICogcCAqICgocG93ZXIgKyAxKSAqIHAgLSBwb3dlcik7XG4gICAgfTtcbn07XG52YXIgY3JlYXRlQW50aWNpcGF0ZUVhc2luZyA9IGZ1bmN0aW9uIChwb3dlcikge1xuICAgIHZhciBiYWNrRWFzaW5nID0gY3JlYXRlQmFja0luKHBvd2VyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIChwICo9IDIpIDwgMSA/IDAuNSAqIGJhY2tFYXNpbmcocCkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcbiAgICB9O1xufTtcbnZhciBsaW5lYXIgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwO1xufTtcbnZhciBlYXNlSW4gPSAvKiNfX1BVUkVfXyovY3JlYXRlRXhwb0luKDIpO1xudmFyIGVhc2VPdXQgPSAvKiNfX1BVUkVfXyovcmV2ZXJzZWQoZWFzZUluKTtcbnZhciBlYXNlSW5PdXQgPSAvKiNfX1BVUkVfXyovbWlycm9yZWQoZWFzZUluKTtcbnZhciBjaXJjSW4gPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHApKTtcbn07XG52YXIgY2lyY091dCA9IC8qI19fUFVSRV9fKi9yZXZlcnNlZChjaXJjSW4pO1xudmFyIGNpcmNJbk91dCA9IC8qI19fUFVSRV9fKi9taXJyb3JlZChjaXJjT3V0KTtcbnZhciBiYWNrSW4gPSAvKiNfX1BVUkVfXyovY3JlYXRlQmFja0luKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBiYWNrT3V0ID0gLyojX19QVVJFX18qL3JldmVyc2VkKGJhY2tJbik7XG52YXIgYmFja0luT3V0ID0gLyojX19QVVJFX18qL21pcnJvcmVkKGJhY2tJbik7XG52YXIgYW50aWNpcGF0ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVBbnRpY2lwYXRlRWFzaW5nKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID0gNC4wIC8gMTEuMDtcbnZhciBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRCA9IDguMCAvIDExLjA7XG52YXIgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA9IDkuMCAvIDEwLjA7XG52YXIgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbnZhciBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG52YXIgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xudmFyIGJvdW5jZU91dCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHAyID0gcCAqIHA7XG4gICAgcmV0dXJuIHAgPCBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID8gNy41NjI1ICogcDIgOiBwIDwgQk9VTkNFX1NFQ09ORF9USFJFU0hPTEQgPyA5LjA3NSAqIHAyIC0gOS45ICogcCArIDMuNCA6IHAgPCBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEID8gY2EgKiBwMiAtIGNiICogcCArIGNjIDogMTAuOCAqIHAgKiBwIC0gMjAuNTIgKiBwICsgMTAuNzI7XG59O1xudmFyIGJvdW5jZUluID0gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMS4wIC0gYm91bmNlT3V0KDEuMCAtIHApO1xufTtcbnZhciBib3VuY2VJbk91dCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHAgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dChwICogMi4wIC0gMS4wKSArIDAuNTtcbn07XG52YXIgTkVXVE9OX0lURVJBVElPTlMgPSA4O1xudmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG52YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcbnZhciBLX1NQTElORV9UQUJMRV9TSVpFID0gMTE7XG52YXIgS19TQU1QTEVfU1RFUF9TSVpFID0gMS4wIC8gKEtfU1BMSU5FX1RBQkxFX1NJWkUgLSAxLjApO1xudmFyIEZMT0FUXzMyX1NVUFBPUlRFRCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xudmFyIGEgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gICAgcmV0dXJuIDEuMCAtIDMuMCAqIGEyICsgMy4wICogYTE7XG59O1xudmFyIGIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIGEyIC0gNi4wICogYTE7XG59O1xudmFyIGMgPSBmdW5jdGlvbiAoYTEpIHtcbiAgICByZXR1cm4gMy4wICogYTE7XG59O1xudmFyIGdldFNsb3BlID0gZnVuY3Rpb24gKHQsIGExLCBhMikge1xuICAgIHJldHVybiAzLjAgKiBhKGExLCBhMikgKiB0ICogdCArIDIuMCAqIGIoYTEsIGEyKSAqIHQgKyBjKGExKTtcbn07XG52YXIgY2FsY0JlemllciA9IGZ1bmN0aW9uICh0LCBhMSwgYTIpIHtcbiAgICByZXR1cm4gKChhKGExLCBhMikgKiB0ICsgYihhMSwgYTIpKSAqIHQgKyBjKGExKSkgKiB0O1xufTtcbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBGTE9BVF8zMl9TVVBQT1JURUQgPyBuZXcgRmxvYXQzMkFycmF5KEtfU1BMSU5FX1RBQkxFX1NJWkUpIDogbmV3IEFycmF5KEtfU1BMSU5FX1RBQkxFX1NJWkUpO1xuICAgIHZhciBiaW5hcnlTdWJkaXZpZGUgPSBmdW5jdGlvbiAoYVgsIGFBLCBhQikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgICAgdmFyIGN1cnJlbnRUO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VDtcbiAgICB9O1xuICAgIHZhciBuZXd0b25SYXBoc29uSXRlcmF0ZSA9IGZ1bmN0aW9uIChhWCwgYUd1ZXNzVCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSAwO1xuICAgICAgICB2YXIgY3VycmVudFg7XG4gICAgICAgIGZvciAoOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICAgICAgICAgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH07XG4gICAgdmFyIGNhbGNTYW1wbGVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgS19TUExJTkVfVEFCTEVfU0laRTsgKytpKSB7XG4gICAgICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBLX1NBTVBMRV9TVEVQX1NJWkUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldFRGb3JYID0gZnVuY3Rpb24gKGFYKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xuICAgICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICAgIHZhciBsYXN0U2FtcGxlID0gS19TUExJTkVfVEFCTEVfU0laRSAtIDE7XG4gICAgICAgIHZhciBkaXN0ID0gMC4wO1xuICAgICAgICB2YXIgZ3Vlc3NGb3JUID0gMC4wO1xuICAgICAgICB2YXIgaW5pdGlhbFNsb3BlID0gMC4wO1xuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBLX1NBTVBMRV9TVEVQX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xuICAgICAgICBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBLX1NBTVBMRV9TVEVQX1NJWkU7XG4gICAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBLX1NBTVBMRV9TVEVQX1NJWkUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgdmFyIHJlc29sdmVyID0gZnVuY3Rpb24gKGFYKSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGFYO1xuICAgICAgICB9IGVsc2UgaWYgKGFYID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYVggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzb2x2ZXI7XG59XG5cbmV4cG9ydCB7IHJldmVyc2VkLCBtaXJyb3JlZCwgY3JlYXRlUmV2ZXJzZWRFYXNpbmcsIGNyZWF0ZU1pcnJvcmVkRWFzaW5nLCBjcmVhdGVFeHBvSW4sIGNyZWF0ZUJhY2tJbiwgY3JlYXRlQW50aWNpcGF0ZUVhc2luZywgbGluZWFyLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCwgY2lyY0luLCBjaXJjT3V0LCBjaXJjSW5PdXQsIGJhY2tJbiwgYmFja091dCwgYmFja0luT3V0LCBhbnRpY2lwYXRlLCBib3VuY2VPdXQsIGJvdW5jZUluLCBib3VuY2VJbk91dCwgY3ViaWNCZXppZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popmotion/easing/dist/easing.es.js\n");

/***/ }),

/***/ "./node_modules/@popmotion/popcorn/dist/popcorn.es.js":
/*!************************************************************!*\
  !*** ./node_modules/@popmotion/popcorn/dist/popcorn.es.js ***!
  \************************************************************/
/*! exports provided: createAnticipateEasing, createBackIn, createExpoIn, cubicBezier, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, reversed, mirrored, angle, applyOffset, clamp, conditional, degreesToRadians, distance, interpolate, isPoint, isPoint3D, mix, mixArray, mixColor, mixComplex, mixObject, pipe, pointFromVector, progress, radiansToDegrees, smooth, smoothFrame, snap, springForce, springForceExpo, springForceLinear, steps, toDecimal, velocityPerFrame, velocityPerSecond, wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyOffset\", function() { return applyOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conditional\", function() { return conditional; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degreesToRadians\", function() { return degreesToRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolate\", function() { return interpolate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPoint\", function() { return isPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPoint3D\", function() { return isPoint3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mix\", function() { return mix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mixArray\", function() { return mixArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mixColor\", function() { return mixColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mixComplex\", function() { return mixComplex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mixObject\", function() { return mixObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pipe\", function() { return pipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointFromVector\", function() { return pointFromVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"progress\", function() { return progress; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radiansToDegrees\", function() { return radiansToDegrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"smooth\", function() { return smooth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"smoothFrame\", function() { return smoothFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"snap\", function() { return snap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"springForce\", function() { return springForce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"springForceExpo\", function() { return springForceExpo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"springForceLinear\", function() { return springForceLinear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"steps\", function() { return steps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toDecimal\", function() { return toDecimal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"velocityPerFrame\", function() { return velocityPerFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"velocityPerSecond\", function() { return velocityPerSecond; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return wrap$1; });\n/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-value-types */ \"./node_modules/style-value-types/dist/style-value-types.es.js\");\n/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hey-listen */ \"./node_modules/hey-listen/dist/hey-listen.es.js\");\n/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framesync */ \"./node_modules/framesync/dist/framesync.es.js\");\n/* harmony import */ var _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @popmotion/easing */ \"./node_modules/@popmotion/easing/dist/easing.es.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createAnticipateEasing\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"createAnticipateEasing\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createBackIn\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"createBackIn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createExpoIn\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"createExpoIn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"cubicBezier\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"cubicBezier\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linear\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"linear\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"easeIn\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"easeIn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"easeOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"easeOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"easeInOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"easeInOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"circIn\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"circIn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"circOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"circOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"circInOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"circInOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"backIn\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"backIn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"backOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"backOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"backInOut\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"backInOut\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"anticipate\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"anticipate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reversed\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"reversed\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mirrored\", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_3__[\"mirrored\"]; });\n\n\n\n\n\n\n\nvar zeroPoint = {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0\r\n};\r\nvar isNum = function (v) { return typeof v === 'number'; };\n\nvar radiansToDegrees = (function (radians) { return (radians * 180) / Math.PI; });\n\nvar angle = (function (a, b) {\r\n    if (b === void 0) { b = zeroPoint; }\r\n    return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\r\n});\n\nvar applyOffset = (function (from, to) {\r\n    var hasReceivedFrom = true;\r\n    if (to === undefined) {\r\n        to = from;\r\n        hasReceivedFrom = false;\r\n    }\r\n    return function (v) {\r\n        if (hasReceivedFrom) {\r\n            return v - from + to;\r\n        }\r\n        else {\r\n            from = v;\r\n            hasReceivedFrom = true;\r\n            return to;\r\n        }\r\n    };\r\n});\n\nvar curryRange = (function (func) { return function (min, max, v) { return (v !== undefined ? func(min, max, v) : function (cv) { return func(min, max, cv); }); }; });\n\nvar clamp = function (min, max, v) {\r\n    return Math.min(Math.max(v, min), max);\r\n};\r\nvar clamp$1 = curryRange(clamp);\n\nvar conditional = (function (check, apply) { return function (v) {\r\n    return check(v) ? apply(v) : v;\r\n}; });\n\nvar degreesToRadians = (function (degrees) { return (degrees * Math.PI) / 180; });\n\nvar isPoint = (function (point) {\r\n    return point.hasOwnProperty('x') && point.hasOwnProperty('y');\r\n});\n\nvar isPoint3D = (function (point) {\r\n    return isPoint(point) && point.hasOwnProperty('z');\r\n});\n\nvar distance1D = function (a, b) { return Math.abs(a - b); };\r\nvar distance = (function (a, b) {\r\n    if (b === void 0) { b = zeroPoint; }\r\n    if (isNum(a) && isNum(b)) {\r\n        return distance1D(a, b);\r\n    }\r\n    else if (isPoint(a) && isPoint(b)) {\r\n        var xDelta = distance1D(a.x, b.x);\r\n        var yDelta = distance1D(a.y, b.y);\r\n        var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\r\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\r\n    }\r\n    return 0;\r\n});\n\nvar progress = (function (from, to, value) {\r\n    var toFromDifference = to - from;\r\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\r\n});\n\nvar mix = (function (from, to, progress) {\r\n    return -progress * from + progress * to + from;\r\n});\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar mixLinearColor = function (from, to, v) {\r\n    var fromExpo = from * from;\r\n    var toExpo = to * to;\r\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\r\n};\r\nvar colorTypes = [style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"hex\"], style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"rgba\"], style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"hsla\"]];\r\nvar getColorType = function (v) {\r\n    return colorTypes.find(function (type) { return type.test(v); });\r\n};\r\nvar notAnimatable = function (color$$1) {\r\n    return \"'\" + color$$1 + \"' is not an animatable color. Use the equivalent color code instead.\";\r\n};\r\nvar mixColor = (function (from, to) {\r\n    var fromColorType = getColorType(from);\r\n    var toColorType = getColorType(to);\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(!!fromColorType, notAnimatable(from));\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(!!toColorType, notAnimatable(to));\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(fromColorType.transform === toColorType.transform, 'Both colors must be hex/RGBA, OR both must be HSLA.');\r\n    var fromColor = fromColorType.parse(from);\r\n    var toColor = toColorType.parse(to);\r\n    var blended = __assign({}, fromColor);\r\n    var mixFunc = fromColorType === style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"hsla\"] ? mix : mixLinearColor;\r\n    return function (v) {\r\n        for (var key in blended) {\r\n            if (key !== 'alpha') {\r\n                blended[key] = mixFunc(fromColor[key], toColor[key], v);\r\n            }\r\n        }\r\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\r\n        return fromColorType.transform(blended);\r\n    };\r\n});\n\nvar combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };\r\nvar pipe = (function () {\r\n    var transformers = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        transformers[_i] = arguments[_i];\r\n    }\r\n    return transformers.reduce(combineFunctions);\r\n});\n\nfunction getMixer(origin, target) {\r\n    if (isNum(origin)) {\r\n        return function (v) { return mix(origin, target, v); };\r\n    }\r\n    else if (style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"color\"].test(origin)) {\r\n        return mixColor(origin, target);\r\n    }\r\n    else {\r\n        return mixComplex(origin, target);\r\n    }\r\n}\r\nvar mixArray = function (from, to) {\r\n    var output = from.slice();\r\n    var numValues = output.length;\r\n    var blendValue = from.map(function (fromThis, i) { return getMixer(fromThis, to[i]); });\r\n    return function (v) {\r\n        for (var i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nvar mixObject = function (origin, target) {\r\n    var output = __assign({}, origin, target);\r\n    var blendValue = {};\r\n    for (var key in output) {\r\n        if (origin[key] !== undefined && target[key] !== undefined) {\r\n            blendValue[key] = getMixer(origin[key], target[key]);\r\n        }\r\n    }\r\n    return function (v) {\r\n        for (var key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nfunction analyse(value) {\r\n    var parsed = style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"complex\"].parse(value);\r\n    var numValues = parsed.length;\r\n    var numNumbers = 0;\r\n    var numRGB = 0;\r\n    var numHSL = 0;\r\n    for (var i = 0; i < numValues; i++) {\r\n        if (numNumbers || typeof parsed[i] === 'number') {\r\n            numNumbers++;\r\n        }\r\n        else {\r\n            if (parsed[i].hue !== undefined) {\r\n                numHSL++;\r\n            }\r\n            else {\r\n                numRGB++;\r\n            }\r\n        }\r\n    }\r\n    return { parsed: parsed, numNumbers: numNumbers, numRGB: numRGB, numHSL: numHSL };\r\n}\r\nvar mixComplex = function (origin, target) {\r\n    var template = style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"complex\"].createTransformer(target);\r\n    var originStats = analyse(origin);\r\n    var targetStats = analyse(target);\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(originStats.numHSL === targetStats.numHSL &&\r\n        originStats.numRGB === targetStats.numRGB &&\r\n        originStats.numNumbers >= targetStats.numNumbers, \"Complex values '\" + origin + \"' and '\" + target + \"' too different to mix. Ensure all colors are of the same type.\");\r\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\r\n};\n\nvar mixNumber = function (from, to) { return function (p) { return mix(from, to, p); }; };\r\nfunction detectMixerFactory(v) {\r\n    if (typeof v === 'number') {\r\n        return mixNumber;\r\n    }\r\n    else if (typeof v === 'string') {\r\n        if (style_value_types__WEBPACK_IMPORTED_MODULE_0__[\"color\"].test(v)) {\r\n            return mixColor;\r\n        }\r\n        else {\r\n            return mixComplex;\r\n        }\r\n    }\r\n    else if (Array.isArray(v)) {\r\n        return mixArray;\r\n    }\r\n    else if (typeof v === 'object') {\r\n        return mixObject;\r\n    }\r\n}\r\nfunction createMixers(output, ease, customMixer) {\r\n    var mixers = [];\r\n    var mixerFactory = customMixer || detectMixerFactory(output[0]);\r\n    var numMixers = output.length - 1;\r\n    for (var i = 0; i < numMixers; i++) {\r\n        var mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            var easingFunction = Array.isArray(ease) ? ease[i] : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\nfunction fastInterpolate(_a, _b) {\r\n    var from = _a[0], to = _a[1];\r\n    var mixer = _b[0];\r\n    return function (v) { return mixer(progress(from, to, v)); };\r\n}\r\nfunction slowInterpolate(input, mixers) {\r\n    var inputLength = input.length;\r\n    var lastInputIndex = inputLength - 1;\r\n    return function (v) {\r\n        var mixerIndex = 0;\r\n        var foundMixerIndex = false;\r\n        if (v <= input[0]) {\r\n            foundMixerIndex = true;\r\n        }\r\n        else if (v >= input[lastInputIndex]) {\r\n            mixerIndex = lastInputIndex - 1;\r\n            foundMixerIndex = true;\r\n        }\r\n        if (!foundMixerIndex) {\r\n            var i = 1;\r\n            for (; i < inputLength; i++) {\r\n                if (input[i] > v || i === lastInputIndex) {\r\n                    break;\r\n                }\r\n            }\r\n            mixerIndex = i - 1;\r\n        }\r\n        var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\r\n        return mixers[mixerIndex](progressInRange);\r\n    };\r\n}\r\nfunction interpolate(input, output, _a) {\r\n    var _b = _a === void 0 ? {} : _a, _c = _b.clamp, clamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;\r\n    var inputLength = input.length;\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(inputLength === output.length, 'Both input and output ranges must be the same length');\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__[\"invariant\"])(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [].concat(input);\r\n        output = [].concat(output);\r\n        input.reverse();\r\n        output.reverse();\r\n    }\r\n    var mixers = createMixers(output, ease, mixer);\r\n    var interpolator = inputLength === 2\r\n        ? fastInterpolate(input, mixers)\r\n        : slowInterpolate(input, mixers);\r\n    return clamp\r\n        ? pipe(clamp$1(input[0], input[inputLength - 1]), interpolator)\r\n        : interpolator;\r\n}\n\nvar pointFromVector = (function (origin, angle, distance) {\r\n    angle = degreesToRadians(angle);\r\n    return {\r\n        x: distance * Math.cos(angle) + origin.x,\r\n        y: distance * Math.sin(angle) + origin.y\r\n    };\r\n});\n\nvar toDecimal = (function (num, precision) {\r\n    if (precision === void 0) { precision = 2; }\r\n    precision = Math.pow(10, precision);\r\n    return Math.round(num * precision) / precision;\r\n});\n\nvar smoothFrame = (function (prevValue, nextValue, duration, smoothing) {\r\n    if (smoothing === void 0) { smoothing = 0; }\r\n    return toDecimal(prevValue +\r\n        (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));\r\n});\n\nvar smooth = (function (strength) {\r\n    if (strength === void 0) { strength = 50; }\r\n    var previousValue = 0;\r\n    var lastUpdated = 0;\r\n    return function (v) {\r\n        var currentFramestamp = Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])().timestamp;\r\n        var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\r\n        var newValue = timeDelta\r\n            ? smoothFrame(previousValue, v, timeDelta, strength)\r\n            : previousValue;\r\n        lastUpdated = currentFramestamp;\r\n        previousValue = newValue;\r\n        return newValue;\r\n    };\r\n});\n\nvar snap = (function (points) {\r\n    if (typeof points === 'number') {\r\n        return function (v) { return Math.round(v / points) * points; };\r\n    }\r\n    else {\r\n        var i_1 = 0;\r\n        var numPoints_1 = points.length;\r\n        return function (v) {\r\n            var lastDistance = Math.abs(points[0] - v);\r\n            for (i_1 = 1; i_1 < numPoints_1; i_1++) {\r\n                var point = points[i_1];\r\n                var distance = Math.abs(point - v);\r\n                if (distance === 0)\r\n                    return point;\r\n                if (distance > lastDistance)\r\n                    return points[i_1 - 1];\r\n                if (i_1 === numPoints_1 - 1)\r\n                    return point;\r\n                lastDistance = distance;\r\n            }\r\n        };\r\n    }\r\n});\n\nvar identity = function (v) { return v; };\r\nvar springForce = function (alterDisplacement) {\r\n    if (alterDisplacement === void 0) { alterDisplacement = identity; }\r\n    return curryRange(function (constant, origin, v) {\r\n        var displacement = origin - v;\r\n        var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\r\n        return displacement <= 0\r\n            ? origin + springModifiedDisplacement\r\n            : origin - springModifiedDisplacement;\r\n    });\r\n};\r\nvar springForceLinear = springForce();\r\nvar springForceExpo = springForce(Math.sqrt);\n\nvar velocityPerFrame = (function (xps, frameDuration) {\r\n    return isNum(xps) ? xps / (1000 / frameDuration) : 0;\r\n});\n\nvar velocityPerSecond = (function (velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n});\n\nvar wrap = function (min, max, v) {\r\n    var rangeSize = max - min;\r\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\r\n};\r\nvar wrap$1 = curryRange(wrap);\n\nvar clampProgress = clamp$1(0, 1);\r\nvar steps = (function (steps, direction) {\r\n    if (direction === void 0) { direction = 'end'; }\r\n    return function (progress) {\r\n        progress =\r\n            direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\r\n        var expanded = progress * steps;\r\n        var rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\r\n        return clampProgress(rounded / steps);\r\n    };\r\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3Btb3Rpb24vcG9wY29ybi9kaXN0L3BvcGNvcm4uZXMuanM/YjRhNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9FO0FBQzdCO0FBQ0U7QUFDdUw7QUFDQTs7QUFFaE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7O0FBRXhELDRDQUE0QyxrQ0FBa0MsRUFBRTs7QUFFaEY7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1DQUFtQyxnQ0FBZ0MsOERBQThELDJCQUEyQixFQUFFLEVBQUUsR0FBRyxFQUFFOztBQUVySztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxFQUFFLEVBQUU7O0FBRUosNENBQTRDLGtDQUFrQyxFQUFFOztBQUVoRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FB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QVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUrVyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AcG9wbW90aW9uL3BvcGNvcm4vZGlzdC9wb3Bjb3JuLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaHNsYSwgcmdiYSwgaGV4LCBjb2xvciwgY29tcGxleCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgZ2V0RnJhbWVEYXRhIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IGNyZWF0ZUFudGljaXBhdGVFYXNpbmcsIGNyZWF0ZUJhY2tJbiwgY3JlYXRlRXhwb0luLCBjdWJpY0JlemllciwgbGluZWFyLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCwgY2lyY0luLCBjaXJjT3V0LCBjaXJjSW5PdXQsIGJhY2tJbiwgYmFja091dCwgYmFja0luT3V0LCBhbnRpY2lwYXRlLCByZXZlcnNlZCwgbWlycm9yZWQgfSBmcm9tICdAcG9wbW90aW9uL2Vhc2luZyc7XG5leHBvcnQgeyBjcmVhdGVBbnRpY2lwYXRlRWFzaW5nLCBjcmVhdGVCYWNrSW4sIGNyZWF0ZUV4cG9JbiwgY3ViaWNCZXppZXIsIGxpbmVhciwgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQsIGNpcmNJbiwgY2lyY091dCwgY2lyY0luT3V0LCBiYWNrSW4sIGJhY2tPdXQsIGJhY2tJbk91dCwgYW50aWNpcGF0ZSwgcmV2ZXJzZWQsIG1pcnJvcmVkIH0gZnJvbSAnQHBvcG1vdGlvbi9lYXNpbmcnO1xuXG52YXIgemVyb1BvaW50ID0ge1xyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICB6OiAwXHJcbn07XHJcbnZhciBpc051bSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcic7IH07XG5cbnZhciByYWRpYW5zVG9EZWdyZWVzID0gKGZ1bmN0aW9uIChyYWRpYW5zKSB7IHJldHVybiAocmFkaWFucyAqIDE4MCkgLyBNYXRoLlBJOyB9KTtcblxudmFyIGFuZ2xlID0gKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSB6ZXJvUG9pbnQ7IH1cclxuICAgIHJldHVybiByYWRpYW5zVG9EZWdyZWVzKE1hdGguYXRhbjIoYi55IC0gYS55LCBiLnggLSBhLngpKTtcclxufSk7XG5cbnZhciBhcHBseU9mZnNldCA9IChmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgIHZhciBoYXNSZWNlaXZlZEZyb20gPSB0cnVlO1xyXG4gICAgaWYgKHRvID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0byA9IGZyb207XHJcbiAgICAgICAgaGFzUmVjZWl2ZWRGcm9tID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoaGFzUmVjZWl2ZWRGcm9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2IC0gZnJvbSArIHRvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZnJvbSA9IHY7XHJcbiAgICAgICAgICAgIGhhc1JlY2VpdmVkRnJvbSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0bztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGN1cnJ5UmFuZ2UgPSAoZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChtaW4sIG1heCwgdikgeyByZXR1cm4gKHYgIT09IHVuZGVmaW5lZCA/IGZ1bmMobWluLCBtYXgsIHYpIDogZnVuY3Rpb24gKGN2KSB7IHJldHVybiBmdW5jKG1pbiwgbWF4LCBjdik7IH0pOyB9OyB9KTtcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcclxufTtcclxudmFyIGNsYW1wJDEgPSBjdXJyeVJhbmdlKGNsYW1wKTtcblxudmFyIGNvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChjaGVjaywgYXBwbHkpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gY2hlY2sodikgPyBhcHBseSh2KSA6IHY7XHJcbn07IH0pO1xuXG52YXIgZGVncmVlc1RvUmFkaWFucyA9IChmdW5jdGlvbiAoZGVncmVlcykgeyByZXR1cm4gKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDsgfSk7XG5cbnZhciBpc1BvaW50ID0gKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgcmV0dXJuIHBvaW50Lmhhc093blByb3BlcnR5KCd4JykgJiYgcG9pbnQuaGFzT3duUHJvcGVydHkoJ3knKTtcclxufSk7XG5cbnZhciBpc1BvaW50M0QgPSAoZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICByZXR1cm4gaXNQb2ludChwb2ludCkgJiYgcG9pbnQuaGFzT3duUHJvcGVydHkoJ3onKTtcclxufSk7XG5cbnZhciBkaXN0YW5jZTFEID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTsgfTtcclxudmFyIGRpc3RhbmNlID0gKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSB6ZXJvUG9pbnQ7IH1cclxuICAgIGlmIChpc051bShhKSAmJiBpc051bShiKSkge1xyXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTFEKGEsIGIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQb2ludChhKSAmJiBpc1BvaW50KGIpKSB7XHJcbiAgICAgICAgdmFyIHhEZWx0YSA9IGRpc3RhbmNlMUQoYS54LCBiLngpO1xyXG4gICAgICAgIHZhciB5RGVsdGEgPSBkaXN0YW5jZTFEKGEueSwgYi55KTtcclxuICAgICAgICB2YXIgekRlbHRhID0gaXNQb2ludDNEKGEpICYmIGlzUG9pbnQzRChiKSA/IGRpc3RhbmNlMUQoYS56LCBiLnopIDogMDtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHhEZWx0YSwgMikgKyBNYXRoLnBvdyh5RGVsdGEsIDIpICsgTWF0aC5wb3coekRlbHRhLCAyKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufSk7XG5cbnZhciBwcm9ncmVzcyA9IChmdW5jdGlvbiAoZnJvbSwgdG8sIHZhbHVlKSB7XHJcbiAgICB2YXIgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcclxuICAgIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcclxufSk7XG5cbnZhciBtaXggPSAoZnVuY3Rpb24gKGZyb20sIHRvLCBwcm9ncmVzcykge1xyXG4gICAgcmV0dXJuIC1wcm9ncmVzcyAqIGZyb20gKyBwcm9ncmVzcyAqIHRvICsgZnJvbTtcclxufSk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgbWl4TGluZWFyQ29sb3IgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHYpIHtcclxuICAgIHZhciBmcm9tRXhwbyA9IGZyb20gKiBmcm9tO1xyXG4gICAgdmFyIHRvRXhwbyA9IHRvICogdG87XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYgKiAodG9FeHBvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG8pKTtcclxufTtcclxudmFyIGNvbG9yVHlwZXMgPSBbaGV4LCByZ2JhLCBoc2xhXTtcclxudmFyIGdldENvbG9yVHlwZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gY29sb3JUeXBlcy5maW5kKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnRlc3Qodik7IH0pO1xyXG59O1xyXG52YXIgbm90QW5pbWF0YWJsZSA9IGZ1bmN0aW9uIChjb2xvciQkMSkge1xyXG4gICAgcmV0dXJuIFwiJ1wiICsgY29sb3IkJDEgKyBcIicgaXMgbm90IGFuIGFuaW1hdGFibGUgY29sb3IuIFVzZSB0aGUgZXF1aXZhbGVudCBjb2xvciBjb2RlIGluc3RlYWQuXCI7XHJcbn07XHJcbnZhciBtaXhDb2xvciA9IChmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgIHZhciBmcm9tQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKGZyb20pO1xyXG4gICAgdmFyIHRvQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKHRvKTtcclxuICAgIGludmFyaWFudCghIWZyb21Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUoZnJvbSkpO1xyXG4gICAgaW52YXJpYW50KCEhdG9Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUodG8pKTtcclxuICAgIGludmFyaWFudChmcm9tQ29sb3JUeXBlLnRyYW5zZm9ybSA9PT0gdG9Db2xvclR5cGUudHJhbnNmb3JtLCAnQm90aCBjb2xvcnMgbXVzdCBiZSBoZXgvUkdCQSwgT1IgYm90aCBtdXN0IGJlIEhTTEEuJyk7XHJcbiAgICB2YXIgZnJvbUNvbG9yID0gZnJvbUNvbG9yVHlwZS5wYXJzZShmcm9tKTtcclxuICAgIHZhciB0b0NvbG9yID0gdG9Db2xvclR5cGUucGFyc2UodG8pO1xyXG4gICAgdmFyIGJsZW5kZWQgPSBfX2Fzc2lnbih7fSwgZnJvbUNvbG9yKTtcclxuICAgIHZhciBtaXhGdW5jID0gZnJvbUNvbG9yVHlwZSA9PT0gaHNsYSA/IG1peCA6IG1peExpbmVhckNvbG9yO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJsZW5kZWQpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2FscGhhJykge1xyXG4gICAgICAgICAgICAgICAgYmxlbmRlZFtrZXldID0gbWl4RnVuYyhmcm9tQ29sb3Jba2V5XSwgdG9Db2xvcltrZXldLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBibGVuZGVkLmFscGhhID0gbWl4KGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21Db2xvclR5cGUudHJhbnNmb3JtKGJsZW5kZWQpO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBjb21iaW5lRnVuY3Rpb25zID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBiKGEodikpOyB9OyB9O1xyXG52YXIgcGlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHJhbnNmb3JtZXJzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHRyYW5zZm9ybWVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVycy5yZWR1Y2UoY29tYmluZUZ1bmN0aW9ucyk7XHJcbn0pO1xuXG5mdW5jdGlvbiBnZXRNaXhlcihvcmlnaW4sIHRhcmdldCkge1xyXG4gICAgaWYgKGlzTnVtKG9yaWdpbikpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG1peChvcmlnaW4sIHRhcmdldCwgdik7IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2xvci50ZXN0KG9yaWdpbikpIHtcclxuICAgICAgICByZXR1cm4gbWl4Q29sb3Iob3JpZ2luLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1peENvbXBsZXgob3JpZ2luLCB0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbnZhciBtaXhBcnJheSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xyXG4gICAgdmFyIG91dHB1dCA9IGZyb20uc2xpY2UoKTtcclxuICAgIHZhciBudW1WYWx1ZXMgPSBvdXRwdXQubGVuZ3RoO1xyXG4gICAgdmFyIGJsZW5kVmFsdWUgPSBmcm9tLm1hcChmdW5jdGlvbiAoZnJvbVRoaXMsIGkpIHsgcmV0dXJuIGdldE1peGVyKGZyb21UaGlzLCB0b1tpXSk7IH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xyXG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBibGVuZFZhbHVlW2ldKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfTtcclxufTtcclxudmFyIG1peE9iamVjdCA9IGZ1bmN0aW9uIChvcmlnaW4sIHRhcmdldCkge1xyXG4gICAgdmFyIG91dHB1dCA9IF9fYXNzaWduKHt9LCBvcmlnaW4sIHRhcmdldCk7XHJcbiAgICB2YXIgYmxlbmRWYWx1ZSA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIG91dHB1dCkge1xyXG4gICAgICAgIGlmIChvcmlnaW5ba2V5XSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmxlbmRWYWx1ZVtrZXldID0gZ2V0TWl4ZXIob3JpZ2luW2tleV0sIHRhcmdldFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmxlbmRWYWx1ZSkge1xyXG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcbn07XHJcbmZ1bmN0aW9uIGFuYWx5c2UodmFsdWUpIHtcclxuICAgIHZhciBwYXJzZWQgPSBjb21wbGV4LnBhcnNlKHZhbHVlKTtcclxuICAgIHZhciBudW1WYWx1ZXMgPSBwYXJzZWQubGVuZ3RoO1xyXG4gICAgdmFyIG51bU51bWJlcnMgPSAwO1xyXG4gICAgdmFyIG51bVJHQiA9IDA7XHJcbiAgICB2YXIgbnVtSFNMID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcclxuICAgICAgICBpZiAobnVtTnVtYmVycyB8fCB0eXBlb2YgcGFyc2VkW2ldID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBudW1OdW1iZXJzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkW2ldLmh1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBudW1IU0wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG51bVJHQisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWQsIG51bU51bWJlcnM6IG51bU51bWJlcnMsIG51bVJHQjogbnVtUkdCLCBudW1IU0w6IG51bUhTTCB9O1xyXG59XHJcbnZhciBtaXhDb21wbGV4ID0gZnVuY3Rpb24gKG9yaWdpbiwgdGFyZ2V0KSB7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKHRhcmdldCk7XHJcbiAgICB2YXIgb3JpZ2luU3RhdHMgPSBhbmFseXNlKG9yaWdpbik7XHJcbiAgICB2YXIgdGFyZ2V0U3RhdHMgPSBhbmFseXNlKHRhcmdldCk7XHJcbiAgICBpbnZhcmlhbnQob3JpZ2luU3RhdHMubnVtSFNMID09PSB0YXJnZXRTdGF0cy5udW1IU0wgJiZcclxuICAgICAgICBvcmlnaW5TdGF0cy5udW1SR0IgPT09IHRhcmdldFN0YXRzLm51bVJHQiAmJlxyXG4gICAgICAgIG9yaWdpblN0YXRzLm51bU51bWJlcnMgPj0gdGFyZ2V0U3RhdHMubnVtTnVtYmVycywgXCJDb21wbGV4IHZhbHVlcyAnXCIgKyBvcmlnaW4gKyBcIicgYW5kICdcIiArIHRhcmdldCArIFwiJyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUuXCIpO1xyXG4gICAgcmV0dXJuIHBpcGUobWl4QXJyYXkob3JpZ2luU3RhdHMucGFyc2VkLCB0YXJnZXRTdGF0cy5wYXJzZWQpLCB0ZW1wbGF0ZSk7XHJcbn07XG5cbnZhciBtaXhOdW1iZXIgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHsgcmV0dXJuIGZ1bmN0aW9uIChwKSB7IHJldHVybiBtaXgoZnJvbSwgdG8sIHApOyB9OyB9O1xyXG5mdW5jdGlvbiBkZXRlY3RNaXhlckZhY3Rvcnkodikge1xyXG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBtaXhOdW1iZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoY29sb3IudGVzdCh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWl4Q29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbWl4Q29tcGxleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1peEFycmF5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIG1peE9iamVjdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBjdXN0b21NaXhlcikge1xyXG4gICAgdmFyIG1peGVycyA9IFtdO1xyXG4gICAgdmFyIG1peGVyRmFjdG9yeSA9IGN1c3RvbU1peGVyIHx8IGRldGVjdE1peGVyRmFjdG9yeShvdXRwdXRbMF0pO1xyXG4gICAgdmFyIG51bU1peGVycyA9IG91dHB1dC5sZW5ndGggLSAxO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1NaXhlcnM7IGkrKykge1xyXG4gICAgICAgIHZhciBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xyXG4gICAgICAgIGlmIChlYXNlKSB7XHJcbiAgICAgICAgICAgIHZhciBlYXNpbmdGdW5jdGlvbiA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlW2ldIDogZWFzZTtcclxuICAgICAgICAgICAgbWl4ZXIgPSBwaXBlKGVhc2luZ0Z1bmN0aW9uLCBtaXhlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1peGVycy5wdXNoKG1peGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtaXhlcnM7XHJcbn1cclxuZnVuY3Rpb24gZmFzdEludGVycG9sYXRlKF9hLCBfYikge1xyXG4gICAgdmFyIGZyb20gPSBfYVswXSwgdG8gPSBfYVsxXTtcclxuICAgIHZhciBtaXhlciA9IF9iWzBdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBtaXhlcihwcm9ncmVzcyhmcm9tLCB0bywgdikpOyB9O1xyXG59XHJcbmZ1bmN0aW9uIHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSB7XHJcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICB2YXIgbGFzdElucHV0SW5kZXggPSBpbnB1dExlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbWl4ZXJJbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIGZvdW5kTWl4ZXJJbmRleCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHYgPj0gaW5wdXRbbGFzdElucHV0SW5kZXhdKSB7XHJcbiAgICAgICAgICAgIG1peGVySW5kZXggPSBsYXN0SW5wdXRJbmRleCAtIDE7XHJcbiAgICAgICAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZm91bmRNaXhlckluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCBpbnB1dExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRbaV0gPiB2IHx8IGkgPT09IGxhc3RJbnB1dEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWl4ZXJJbmRleCA9IGkgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbbWl4ZXJJbmRleF0sIGlucHV0W21peGVySW5kZXggKyAxXSwgdik7XHJcbiAgICAgICAgcmV0dXJuIG1peGVyc1ttaXhlckluZGV4XShwcm9ncmVzc0luUmFuZ2UpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgb3V0cHV0LCBfYSkge1xyXG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuY2xhbXAsIGNsYW1wID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgZWFzZSA9IF9iLmVhc2UsIG1peGVyID0gX2IubWl4ZXI7XHJcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICBpbnZhcmlhbnQoaW5wdXRMZW5ndGggPT09IG91dHB1dC5sZW5ndGgsICdCb3RoIGlucHV0IGFuZCBvdXRwdXQgcmFuZ2VzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoJyk7XHJcbiAgICBpbnZhcmlhbnQoIWVhc2UgfHwgIUFycmF5LmlzQXJyYXkoZWFzZSkgfHwgZWFzZS5sZW5ndGggPT09IGlucHV0TGVuZ3RoIC0gMSwgJ0FycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuJyk7XHJcbiAgICBpZiAoaW5wdXRbMF0gPiBpbnB1dFtpbnB1dExlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xyXG4gICAgICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xyXG4gICAgICAgIGlucHV0LnJldmVyc2UoKTtcclxuICAgICAgICBvdXRwdXQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcclxuICAgIHZhciBpbnRlcnBvbGF0b3IgPSBpbnB1dExlbmd0aCA9PT0gMlxyXG4gICAgICAgID8gZmFzdEludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpXHJcbiAgICAgICAgOiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycyk7XHJcbiAgICByZXR1cm4gY2xhbXBcclxuICAgICAgICA/IHBpcGUoY2xhbXAkMShpbnB1dFswXSwgaW5wdXRbaW5wdXRMZW5ndGggLSAxXSksIGludGVycG9sYXRvcilcclxuICAgICAgICA6IGludGVycG9sYXRvcjtcclxufVxuXG52YXIgcG9pbnRGcm9tVmVjdG9yID0gKGZ1bmN0aW9uIChvcmlnaW4sIGFuZ2xlLCBkaXN0YW5jZSkge1xyXG4gICAgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKGFuZ2xlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSkgKyBvcmlnaW4ueCxcclxuICAgICAgICB5OiBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKSArIG9yaWdpbi55XHJcbiAgICB9O1xyXG59KTtcblxudmFyIHRvRGVjaW1hbCA9IChmdW5jdGlvbiAobnVtLCBwcmVjaXNpb24pIHtcclxuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAyOyB9XHJcbiAgICBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XHJcbn0pO1xuXG52YXIgc21vb3RoRnJhbWUgPSAoZnVuY3Rpb24gKHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBkdXJhdGlvbiwgc21vb3RoaW5nKSB7XHJcbiAgICBpZiAoc21vb3RoaW5nID09PSB2b2lkIDApIHsgc21vb3RoaW5nID0gMDsgfVxyXG4gICAgcmV0dXJuIHRvRGVjaW1hbChwcmV2VmFsdWUgK1xyXG4gICAgICAgIChkdXJhdGlvbiAqIChuZXh0VmFsdWUgLSBwcmV2VmFsdWUpKSAvIE1hdGgubWF4KHNtb290aGluZywgZHVyYXRpb24pKTtcclxufSk7XG5cbnZhciBzbW9vdGggPSAoZnVuY3Rpb24gKHN0cmVuZ3RoKSB7XHJcbiAgICBpZiAoc3RyZW5ndGggPT09IHZvaWQgMCkgeyBzdHJlbmd0aCA9IDUwOyB9XHJcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IDA7XHJcbiAgICB2YXIgbGFzdFVwZGF0ZWQgPSAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZXN0YW1wID0gZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xyXG4gICAgICAgIHZhciB0aW1lRGVsdGEgPSBjdXJyZW50RnJhbWVzdGFtcCAhPT0gbGFzdFVwZGF0ZWQgPyBjdXJyZW50RnJhbWVzdGFtcCAtIGxhc3RVcGRhdGVkIDogMDtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aW1lRGVsdGFcclxuICAgICAgICAgICAgPyBzbW9vdGhGcmFtZShwcmV2aW91c1ZhbHVlLCB2LCB0aW1lRGVsdGEsIHN0cmVuZ3RoKVxyXG4gICAgICAgICAgICA6IHByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgbGFzdFVwZGF0ZWQgPSBjdXJyZW50RnJhbWVzdGFtcDtcclxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBzbmFwID0gKGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgIGlmICh0eXBlb2YgcG9pbnRzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gTWF0aC5yb3VuZCh2IC8gcG9pbnRzKSAqIHBvaW50czsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBpXzEgPSAwO1xyXG4gICAgICAgIHZhciBudW1Qb2ludHNfMSA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0RGlzdGFuY2UgPSBNYXRoLmFicyhwb2ludHNbMF0gLSB2KTtcclxuICAgICAgICAgICAgZm9yIChpXzEgPSAxOyBpXzEgPCBudW1Qb2ludHNfMTsgaV8xKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMocG9pbnQgLSB2KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBsYXN0RGlzdGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50c1tpXzEgLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChpXzEgPT09IG51bVBvaW50c18xIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBsYXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn0pO1xuXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfTtcclxudmFyIHNwcmluZ0ZvcmNlID0gZnVuY3Rpb24gKGFsdGVyRGlzcGxhY2VtZW50KSB7XHJcbiAgICBpZiAoYWx0ZXJEaXNwbGFjZW1lbnQgPT09IHZvaWQgMCkgeyBhbHRlckRpc3BsYWNlbWVudCA9IGlkZW50aXR5OyB9XHJcbiAgICByZXR1cm4gY3VycnlSYW5nZShmdW5jdGlvbiAoY29uc3RhbnQsIG9yaWdpbiwgdikge1xyXG4gICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSBvcmlnaW4gLSB2O1xyXG4gICAgICAgIHZhciBzcHJpbmdNb2RpZmllZERpc3BsYWNlbWVudCA9IC0oMCAtIGNvbnN0YW50ICsgMSkgKiAoMCAtIGFsdGVyRGlzcGxhY2VtZW50KE1hdGguYWJzKGRpc3BsYWNlbWVudCkpKTtcclxuICAgICAgICByZXR1cm4gZGlzcGxhY2VtZW50IDw9IDBcclxuICAgICAgICAgICAgPyBvcmlnaW4gKyBzcHJpbmdNb2RpZmllZERpc3BsYWNlbWVudFxyXG4gICAgICAgICAgICA6IG9yaWdpbiAtIHNwcmluZ01vZGlmaWVkRGlzcGxhY2VtZW50O1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBzcHJpbmdGb3JjZUxpbmVhciA9IHNwcmluZ0ZvcmNlKCk7XHJcbnZhciBzcHJpbmdGb3JjZUV4cG8gPSBzcHJpbmdGb3JjZShNYXRoLnNxcnQpO1xuXG52YXIgdmVsb2NpdHlQZXJGcmFtZSA9IChmdW5jdGlvbiAoeHBzLCBmcmFtZUR1cmF0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNOdW0oeHBzKSA/IHhwcyAvICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xyXG59KTtcblxudmFyIHZlbG9jaXR5UGVyU2Vjb25kID0gKGZ1bmN0aW9uICh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xyXG59KTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAobWluLCBtYXgsIHYpIHtcclxuICAgIHZhciByYW5nZVNpemUgPSBtYXggLSBtaW47XHJcbiAgICByZXR1cm4gKCgoKHYgLSBtaW4pICUgcmFuZ2VTaXplKSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUpICsgbWluO1xyXG59O1xyXG52YXIgd3JhcCQxID0gY3VycnlSYW5nZSh3cmFwKTtcblxudmFyIGNsYW1wUHJvZ3Jlc3MgPSBjbGFtcCQxKDAsIDEpO1xyXG52YXIgc3RlcHMgPSAoZnVuY3Rpb24gKHN0ZXBzLCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBkaXJlY3Rpb24gPSAnZW5kJzsgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9ncmVzcykge1xyXG4gICAgICAgIHByb2dyZXNzID1cclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnZW5kJyA/IE1hdGgubWluKHByb2dyZXNzLCAwLjk5OSkgOiBNYXRoLm1heChwcm9ncmVzcywgMC4wMDEpO1xyXG4gICAgICAgIHZhciBleHBhbmRlZCA9IHByb2dyZXNzICogc3RlcHM7XHJcbiAgICAgICAgdmFyIHJvdW5kZWQgPSBkaXJlY3Rpb24gPT09ICdlbmQnID8gTWF0aC5mbG9vcihleHBhbmRlZCkgOiBNYXRoLmNlaWwoZXhwYW5kZWQpO1xyXG4gICAgICAgIHJldHVybiBjbGFtcFByb2dyZXNzKHJvdW5kZWQgLyBzdGVwcyk7XHJcbiAgICB9O1xyXG59KTtcblxuZXhwb3J0IHsgYW5nbGUsIGFwcGx5T2Zmc2V0LCBjbGFtcCQxIGFzIGNsYW1wLCBjb25kaXRpb25hbCwgZGVncmVlc1RvUmFkaWFucywgZGlzdGFuY2UsIGludGVycG9sYXRlLCBpc1BvaW50LCBpc1BvaW50M0QsIG1peCwgbWl4QXJyYXksIG1peENvbG9yLCBtaXhDb21wbGV4LCBtaXhPYmplY3QsIHBpcGUsIHBvaW50RnJvbVZlY3RvciwgcHJvZ3Jlc3MsIHJhZGlhbnNUb0RlZ3JlZXMsIHNtb290aCwgc21vb3RoRnJhbWUsIHNuYXAsIHNwcmluZ0ZvcmNlLCBzcHJpbmdGb3JjZUV4cG8sIHNwcmluZ0ZvcmNlTGluZWFyLCBzdGVwcywgdG9EZWNpbWFsLCB2ZWxvY2l0eVBlckZyYW1lLCB2ZWxvY2l0eVBlclNlY29uZCwgd3JhcCQxIGFzIHdyYXAgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popmotion/popcorn/dist/popcorn.es.js\n");

/***/ }),

/***/ "./node_modules/framer-motion/dist/framer-motion.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/framer-motion/dist/framer-motion.es.js ***!
  \*************************************************************/
/*! exports provided: AnimatePresence, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, Point, ReducedMotion, UnstableSyncLayout, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, transform, unwrapMotionValue, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimatePresence\", function() { return AnimatePresence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationControls\", function() { return AnimationControls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragControls\", function() { return DragControls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MotionContext\", function() { return MotionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MotionPluginContext\", function() { return MotionPluginContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MotionPlugins\", function() { return MotionPlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MotionValue\", function() { return MotionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReducedMotion\", function() { return ReducedMotion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnstableSyncLayout\", function() { return UnstableSyncLayout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animationControls\", function() { return animationControls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createMotionComponent\", function() { return createMotionComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidMotionProp\", function() { return isValidMotionProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"motion\", function() { return motion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"motionValue\", function() { return motionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrapMotionValue\", function() { return unwrapMotionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useAnimatedState\", function() { return useAnimatedState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useAnimation\", function() { return useAnimation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCycle\", function() { return useCycle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDomEvent\", function() { return useDomEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDragControls\", function() { return useDragControls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useElementScroll\", function() { return useElementScroll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useExternalRef\", function() { return useExternalRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useGestures\", function() { return useGestures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useInvertedScale\", function() { return useInvertedScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useMotionValue\", function() { return useMotionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usePanGesture\", function() { return usePanGesture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usePresence\", function() { return usePresence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useReducedMotion\", function() { return useReducedMotion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useSpring\", function() { return useSpring; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useTapGesture\", function() { return useTapGesture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useTransform\", function() { return useTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useViewportScroll\", function() { return useViewportScroll; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framesync */ \"./node_modules/framesync/dist/framesync.es.js\");\n/* harmony import */ var _popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @popmotion/popcorn */ \"./node_modules/@popmotion/popcorn/dist/popcorn.es.js\");\n/* harmony import */ var stylefire__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! stylefire */ \"./node_modules/stylefire/dist/stylefire.es.js\");\n/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hey-listen */ \"./node_modules/hey-listen/dist/hey-listen.es.js\");\n/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! style-value-types */ \"./node_modules/style-value-types/dist/style-value-types.es.js\");\n/* harmony import */ var popmotion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! popmotion */ \"./node_modules/popmotion/dist/popmotion.es.js\");\n/* harmony import */ var _popmotion_easing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @popmotion/easing */ \"./node_modules/@popmotion/easing/dist/easing.es.js\");\n\n\n\n\n\n\n\n\n\n\n\nvar isFloat = function (value) {\r\n    return !isNaN(parseFloat(value));\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nvar MotionValue = /** @class */ (function () {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    function MotionValue(init, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, transformer = _b.transformer, parent = _b.parent;\r\n        /**\r\n         * Duration, in milliseconds, since last updating frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.timeDelta = 0;\r\n        /**\r\n         * Timestamp of the last time this `MotionValue` was updated.\r\n         *\r\n         * @internal\r\n         */\r\n        this.lastUpdated = 0;\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = false;\r\n        this.updateAndNotify = function (v, render) {\r\n            if (render === void 0) { render = true; }\r\n            _this.prev = _this.current;\r\n            _this.current = _this.transformer ? _this.transformer(v) : v;\r\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\r\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            if (_this.children) {\r\n                _this.children.forEach(_this.setChild);\r\n            }\r\n            if (render && _this.renderSubscribers) {\r\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            // Update timestamp\r\n            var _a = Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])(), delta = _a.delta, timestamp = _a.timestamp;\r\n            if (_this.lastUpdated !== timestamp) {\r\n                _this.timeDelta = delta;\r\n                _this.lastUpdated = timestamp;\r\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].postRender(_this.scheduleVelocityCheck);\r\n            }\r\n        };\r\n        /**\r\n         * Notify a subscriber with the latest value.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @param subscriber - The subscriber to notify.\r\n         *\r\n         * @internal\r\n         */\r\n        this.notifySubscriber = function (subscriber) {\r\n            subscriber(_this.current);\r\n        };\r\n        /**\r\n         * Schedule a velocity check for the next frame.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.scheduleVelocityCheck = function () { return framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].postRender(_this.velocityCheck); };\r\n        /**\r\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\r\n         * This ensures velocity calculations return `0`.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.velocityCheck = function (_a) {\r\n            var timestamp = _a.timestamp;\r\n            if (timestamp !== _this.lastUpdated) {\r\n                _this.prev = _this.current;\r\n            }\r\n        };\r\n        /**\r\n         * Updates child `MotionValue`.\r\n         *\r\n         * @param child - Child `MotionValue`.\r\n         *\r\n         * @internal\r\n         */\r\n        this.setChild = function (child) { return child.set(_this.current); };\r\n        this.parent = parent;\r\n        this.transformer = transformer;\r\n        this.set(init, false);\r\n        this.canTrackVelocity = isFloat(this.current);\r\n    }\r\n    /**\r\n     * Creates a new `MotionValue` that's subscribed to the output of this one.\r\n     *\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.addChild = function (config) {\r\n        if (config === void 0) { config = {}; }\r\n        var child = new MotionValue(this.current, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ parent: this }, config));\r\n        if (!this.children)\r\n            this.children = new Set();\r\n        this.children.add(child);\r\n        return child;\r\n    };\r\n    /**\r\n     * Stops a `MotionValue` from being subscribed to this one.\r\n     *\r\n     * @param child - The subscribed `MotionValue`\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.removeChild = function (child) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(child);\r\n    };\r\n    /**\r\n     * Subscribes a subscriber function to a subscription list.\r\n     *\r\n     * @param subscriptions - A `Set` of subscribers.\r\n     * @param subscription - A subscriber function.\r\n     */\r\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\r\n        var _this = this;\r\n        var updateSubscriber = function () { return subscription(_this.current); };\r\n        subscriptions.add(updateSubscriber);\r\n        return function () { return subscriptions.delete(updateSubscriber); };\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * @library\r\n     *\r\n     * ```jsx\r\n     * function MyComponent() {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <Frame x={x} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @motion\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     *\r\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\r\n     *\r\n     * ```jsx\r\n     * useOnChange(x, () => {})\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.onChange = function (subscription) {\r\n        if (!this.updateSubscribers)\r\n            this.updateSubscribers = new Set();\r\n        return this.subscribeTo(this.updateSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` requests a render.\r\n     *\r\n     * @param subscriber - A function that's provided the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.onRenderRequest = function (subscription) {\r\n        if (!this.renderSubscribers)\r\n            this.renderSubscribers = new Set();\r\n        // Render immediately\r\n        this.notifySubscriber(subscription);\r\n        return this.subscribeTo(this.renderSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.attach = function (passiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n    };\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.set = function (v, render) {\r\n        if (render === void 0) { render = true; }\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.get = function () {\r\n        return this.current;\r\n    };\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.getVelocity = function () {\r\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\r\n        return this.canTrackVelocity\r\n            ? // These casts could be avoided if parseFloat would be typed better\r\n                Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__[\"velocityPerSecond\"])(parseFloat(this.current) -\r\n                    parseFloat(this.prev), this.timeDelta)\r\n            : 0;\r\n    };\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.start = function (animation) {\r\n        var _this = this;\r\n        this.stop();\r\n        return new Promise(function (resolve) {\r\n            _this.stopAnimation = animation(resolve);\r\n        }).then(function () { return _this.clearAnimation(); });\r\n    };\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.stop = function () {\r\n        if (this.stopAnimation)\r\n            this.stopAnimation();\r\n        this.clearAnimation();\r\n    };\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.isAnimating = function () {\r\n        return !!this.stopAnimation;\r\n    };\r\n    MotionValue.prototype.clearAnimation = function () {\r\n        this.stopAnimation = null;\r\n    };\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.destroy = function () {\r\n        this.updateSubscribers && this.updateSubscribers.clear();\r\n        this.renderSubscribers && this.renderSubscribers.clear();\r\n        this.parent && this.parent.removeChild(this);\r\n        this.stop();\r\n    };\r\n    return MotionValue;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nfunction motionValue(init, opts) {\r\n    return new MotionValue(init, opts);\r\n}\n\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    var ref = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\n\nvar isMotionValue = function (value) {\r\n    return value instanceof MotionValue;\r\n};\n\n// Creating a styler factory for the `onUpdate` prop allows all values\r\n// to fire and the `onUpdate` prop will only fire once per frame\r\nvar updateStyler = Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"createStylerFactory\"])({\r\n    onRead: function () { return null; },\r\n    onRender: function (state, _a) {\r\n        var onUpdate = _a.onUpdate;\r\n        return onUpdate(state);\r\n    },\r\n});\r\nvar MotionValuesMap = /** @class */ (function () {\r\n    function MotionValuesMap() {\r\n        this.hasMounted = false;\r\n        this.values = new Map();\r\n        this.unsubscribers = new Map();\r\n    }\r\n    MotionValuesMap.prototype.has = function (key) {\r\n        return this.values.has(key);\r\n    };\r\n    MotionValuesMap.prototype.set = function (key, value) {\r\n        this.values.set(key, value);\r\n        if (this.hasMounted) {\r\n            this.bindValueToOutput(key, value);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.get = function (key, defaultValue) {\r\n        var value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = new MotionValue(defaultValue);\r\n            this.set(key, value);\r\n        }\r\n        return value;\r\n    };\r\n    MotionValuesMap.prototype.forEach = function (callback) {\r\n        return this.values.forEach(callback);\r\n    };\r\n    MotionValuesMap.prototype.bindValueToOutput = function (key, value) {\r\n        var _this = this;\r\n        var onRender = function (v) { return _this.output && _this.output(key, v); };\r\n        var unsubscribeOnRender = value.onRenderRequest(onRender);\r\n        var onChange = function (v) {\r\n            _this.onUpdate && _this.onUpdate.set(key, v);\r\n        };\r\n        var unsubscribeOnChange = value.onChange(onChange);\r\n        if (this.unsubscribers.has(key)) {\r\n            this.unsubscribers.get(key)();\r\n        }\r\n        this.unsubscribers.set(key, function () {\r\n            unsubscribeOnRender();\r\n            unsubscribeOnChange();\r\n        });\r\n    };\r\n    MotionValuesMap.prototype.setOnUpdate = function (onUpdate) {\r\n        this.onUpdate = undefined;\r\n        if (onUpdate) {\r\n            this.onUpdate = updateStyler({ onUpdate: onUpdate });\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.setTransformTemplate = function (transformTemplate) {\r\n        if (this.transformTemplate !== transformTemplate) {\r\n            this.transformTemplate = transformTemplate;\r\n            this.updateTransformTemplate();\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.getTransformTemplate = function () {\r\n        return this.transformTemplate;\r\n    };\r\n    MotionValuesMap.prototype.updateTransformTemplate = function () {\r\n        if (this.output) {\r\n            this.output(\"transform\", this.transformTemplate);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.mount = function (output) {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        if (output)\r\n            this.output = output;\r\n        this.values.forEach(function (value, key) { return _this.bindValueToOutput(key, value); });\r\n        this.updateTransformTemplate();\r\n    };\r\n    MotionValuesMap.prototype.unmount = function () {\r\n        var _this = this;\r\n        this.values.forEach(function (_value, key) {\r\n            var unsubscribe = _this.unsubscribers.get(key);\r\n            unsubscribe && unsubscribe();\r\n        });\r\n    };\r\n    return MotionValuesMap;\r\n}());\r\nvar specialMotionValueProps = new Set([\"dragOriginX\", \"dragOriginY\"]);\r\nvar useMotionValues = function (props) {\r\n    var motionValues = useConstant(function () {\r\n        var map = new MotionValuesMap();\r\n        /**\r\n         * Loop through every prop and add any detected `MotionValue`s. This is SVG-specific\r\n         * code that should be extracted, perhaps considered hollistically with `useMotionStyles`.\r\n         *\r\n         * <motion.circle cx={motionValue(0)} />\r\n         */\r\n        for (var key in props) {\r\n            if (isMotionValue(props[key]) &&\r\n                !specialMotionValueProps.has(key)) {\r\n                map.set(key, props[key]);\r\n            }\r\n        }\r\n        return map;\r\n    });\r\n    motionValues.setOnUpdate(props.onUpdate);\r\n    motionValues.setTransformTemplate(props.transformTemplate);\r\n    return motionValues;\r\n};\n\nvar session = null;\r\nvar syncRenderSession = {\r\n    isOpen: function () { return session !== null; },\r\n    open: function () {\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(!session, \"Sync render session already open\");\r\n        session = [];\r\n    },\r\n    flush: function () {\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(session !== null, \"No sync render session found\");\r\n        session && session.forEach(function (styler) { return styler.render(); });\r\n        session = null;\r\n    },\r\n    push: function (styler) {\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(session !== null, \"No sync render session found\");\r\n        session && session.push(styler);\r\n    },\r\n};\n\n/**\r\n * `useEffect` gets resolved bottom-up. We defer some optional functionality to child\r\n * components, so to ensure everything runs correctly we export the ref-binding logic\r\n * to a new component rather than in `useMotionValues`.\r\n */\r\nvar MountComponent = function (_a) {\r\n    var ref = _a.innerRef, values = _a.values, isStatic = _a.isStatic;\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(ref.current instanceof Element, \"No `ref` found. Ensure components created with `motion.custom` forward refs using `React.forwardRef`\");\r\n        var domStyler = Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ref.current, {\r\n            preparseOutput: false,\r\n            enableHardwareAcceleration: !isStatic,\r\n        });\r\n        values.mount(function (key, value) {\r\n            domStyler.set(key, value);\r\n            if (syncRenderSession.isOpen()) {\r\n                syncRenderSession.push(domStyler);\r\n            }\r\n        });\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return null;\r\n};\r\nvar Mount = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"memo\"])(MountComponent);\n\nvar createValueResolver = function (resolver) { return function (values) {\r\n    var resolvedValues = {};\r\n    values.forEach(function (value, key) { return (resolvedValues[key] = resolver(value)); });\r\n    return resolvedValues;\r\n}; };\r\nvar resolveCurrent = createValueResolver(function (value) { return value.get(); });\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\r\nvar isTransformOriginProp = function (key) { return transformOriginProps.has(key); };\r\nvar buildStyleAttr = function (values, styleProp, isStatic) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var transformTemplate = values.getTransformTemplate();\r\n    if (transformTemplate) {\r\n        // If `transform` has been manually set as a string, pass that through the template\r\n        // otherwise pass it forward to Stylefire's style property builder\r\n        motionValueStyles.transform = styleProp.transform\r\n            ? transformTemplate({}, styleProp.transform)\r\n            : transformTemplate;\r\n    }\r\n    return Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"buildStyleProperty\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, styleProp), motionValueStyles), !isStatic);\r\n};\r\nvar useMotionStyles = function (values, styleProp, isStatic, transformValues) {\r\n    if (styleProp === void 0) { styleProp = {}; }\r\n    var style = {};\r\n    var prevMotionStyles = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])({}).current;\r\n    for (var key in styleProp) {\r\n        var thisStyle = styleProp[key];\r\n        if (isMotionValue(thisStyle)) {\r\n            // If this is a motion value, add it to our MotionValuesMap\r\n            values.set(key, thisStyle);\r\n        }\r\n        else if (!isStatic &&\r\n            (Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"isTransformProp\"])(key) || isTransformOriginProp(key))) {\r\n            // Or if it's a transform prop, create a motion value (or update an existing one)\r\n            // to ensure Stylefire can reconcile all the transform values together.\r\n            // A further iteration on this would be to create a single styler per component that gets\r\n            // used in the DOM renderer's buildStyleAttr *and* animations, then we would only\r\n            // have to convert animating values to `MotionValues` (we could probably remove this entire function).\r\n            // The only architectural consideration is to allow Stylefire to have elements mounted after\r\n            // a styler is created.\r\n            if (!values.has(key)) {\r\n                // If it doesn't exist as a motion value, create it\r\n                values.set(key, motionValue(thisStyle));\r\n            }\r\n            else {\r\n                // Otherwise only update it if it's changed from a previous render\r\n                if (thisStyle !== prevMotionStyles[key]) {\r\n                    var value = values.get(key);\r\n                    value.set(thisStyle);\r\n                }\r\n            }\r\n            prevMotionStyles[key] = thisStyle;\r\n        }\r\n        else {\r\n            style[key] = thisStyle;\r\n        }\r\n    }\r\n    return transformValues ? transformValues(style) : style;\r\n};\n\nvar isKeyframesTarget = function (v) {\r\n    return Array.isArray(v);\r\n};\n\nvar isCustomValue = function (v) {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nvar resolveFinalValueInKeyframes = function (v) {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\n\nvar auto = {\r\n    test: function (v) { return v === \"auto\"; },\r\n    parse: function (v) { return v; },\r\n};\r\nvar dimensionTypes = [style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"number\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"px\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"percent\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"degrees\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"vw\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"vh\"], auto];\r\nvar valueTypes = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(dimensionTypes, [style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"color\"], style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"complex\"]]);\r\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\r\nvar getDimensionValueType = function (v) {\r\n    return dimensionTypes.find(testValueType(v));\r\n};\r\nvar getValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\nvar underDampedSpring = function () { return ({\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restDelta: 0.5,\r\n    restSpeed: 10,\r\n}); };\r\nvar overDampedSpring = function (to) { return ({\r\n    type: \"spring\",\r\n    stiffness: 700,\r\n    damping: to === 0 ? 100 : 35,\r\n}); };\r\nvar linearTween = function () { return ({\r\n    ease: \"linear\",\r\n    duration: 0.3,\r\n}); };\r\nvar keyframes = function (values) { return ({\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n    values: values,\r\n}); };\r\nvar defaultTransitions = {\r\n    x: underDampedSpring,\r\n    y: underDampedSpring,\r\n    z: underDampedSpring,\r\n    rotate: underDampedSpring,\r\n    rotateX: underDampedSpring,\r\n    rotateY: underDampedSpring,\r\n    rotateZ: underDampedSpring,\r\n    scaleX: overDampedSpring,\r\n    scaleY: overDampedSpring,\r\n    scale: overDampedSpring,\r\n    opacity: linearTween,\r\n    backgroundColor: linearTween,\r\n    color: linearTween,\r\n    default: overDampedSpring,\r\n};\r\nvar getDefaultTransition = function (valueKey, to) {\r\n    var transitionFactory;\r\n    if (isKeyframesTarget(to)) {\r\n        transitionFactory = keyframes;\r\n    }\r\n    else {\r\n        transitionFactory =\r\n            defaultTransitions[valueKey] || defaultTransitions.default;\r\n    }\r\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ to: to }, transitionFactory(to));\r\n};\n\n/**\r\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\r\n * updates with `to` and then completes. By using this we can compose instant transitions\r\n * in with the same logic that applies `delay` or returns a `Promise` etc.\r\n *\r\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\r\n * the animation until after the duration finishes. This is for situations when you're **only**\r\n * animating non-animatable values and then setting something on `transitionEnd`. Really\r\n * you want this to fire after the \"animation\" finishes, rather than instantly.\r\n *\r\n * ```\r\n * animate={{\r\n *   display: 'block',\r\n *   transitionEnd: { display: 'none' }\r\n * }}\r\n * ```\r\n */\r\nvar just = function (_a) {\r\n    var to = _a.to, duration = _a.duration;\r\n    return Object(popmotion__WEBPACK_IMPORTED_MODULE_7__[\"action\"])(function (_a) {\r\n        var update = _a.update, complete = _a.complete;\r\n        update(to);\r\n        duration ? Object(popmotion__WEBPACK_IMPORTED_MODULE_7__[\"delay\"])(duration).start({ complete: complete }) : complete();\r\n    });\r\n};\n\nvar easingDefinitionToFunction = function (definition) {\r\n    if (Array.isArray(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\r\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\r\n        return Object(_popmotion_easing__WEBPACK_IMPORTED_MODULE_8__[\"cubicBezier\"])(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(_popmotion_easing__WEBPACK_IMPORTED_MODULE_8__[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\r\n        return _popmotion_easing__WEBPACK_IMPORTED_MODULE_8__[definition];\r\n    }\r\n    return definition;\r\n};\r\nvar isEasingArray = function (ease) {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\n\nvar isDurationAnimation = function (v) {\r\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\r\n};\n\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nvar isAnimatable = function (key, value) {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (key === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"complex\"].test(value) && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\n\n/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar transitions = { tween: popmotion__WEBPACK_IMPORTED_MODULE_7__[\"tween\"], spring: popmotion__WEBPACK_IMPORTED_MODULE_7__[\"spring\"], keyframes: popmotion__WEBPACK_IMPORTED_MODULE_7__[\"keyframes\"], inertia: popmotion__WEBPACK_IMPORTED_MODULE_7__[\"inertia\"], just: just };\r\nvar transitionOptionParser = {\r\n    tween: function (opts) {\r\n        if (opts.ease) {\r\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\r\n            opts.ease = easingDefinitionToFunction(ease);\r\n        }\r\n        return opts;\r\n    },\r\n    keyframes: function (_a) {\r\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"from\", \"to\", \"velocity\"]);\r\n        if (opts.values && opts.values[0] === null) {\r\n            var values = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(opts.values);\r\n            values[0] = from;\r\n            opts.values = values;\r\n        }\r\n        if (opts.ease) {\r\n            opts.easings = isEasingArray(opts.ease)\r\n                ? opts.ease.map(easingDefinitionToFunction)\r\n                : easingDefinitionToFunction(opts.ease);\r\n        }\r\n        opts.ease = _popmotion_easing__WEBPACK_IMPORTED_MODULE_8__[\"linear\"];\r\n        return opts;\r\n    },\r\n};\r\nvar isTransitionDefined = function (_a) {\r\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\r\n    return Object.keys(transition).length;\r\n};\r\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\r\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\r\n    // If no object, return default transition\r\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\r\n    // and see if there's any props remaining\r\n    if (transitionDefinition === undefined ||\r\n        !isTransitionDefined(transitionDefinition)) {\r\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ delay: delay }, getDefaultTransition(key, to));\r\n    }\r\n    var valueTransitionDefinition = transitionDefinition[key] ||\r\n        transitionDefinition.default ||\r\n        transitionDefinition;\r\n    if (valueTransitionDefinition.type === false) {\r\n        return {\r\n            delay: valueTransitionDefinition.hasOwnProperty(\"delay\")\r\n                ? valueTransitionDefinition.delay\r\n                : delay,\r\n            to: isKeyframesTarget(to)\r\n                ? to[to.length - 1]\r\n                : to,\r\n            type: \"just\",\r\n        };\r\n    }\r\n    else if (isKeyframesTarget(to)) {\r\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition), { \r\n            // This animation must be keyframes if we're animating through an array\r\n            type: \"keyframes\" });\r\n    }\r\n    else {\r\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ type: \"tween\", to: to,\r\n            delay: delay }, valueTransitionDefinition);\r\n    }\r\n};\r\nvar preprocessOptions = function (type, opts) {\r\n    return transitionOptionParser[type]\r\n        ? transitionOptionParser[type](opts)\r\n        : opts;\r\n};\r\nvar getAnimation = function (key, value, target, transition) {\r\n    var origin = value.get();\r\n    var isOriginAnimatable = isAnimatable(key, origin);\r\n    var isTargetAnimatable = isAnimatable(key, target);\r\n    // TODO we could probably improve this check to ensure both values are of the same type -\r\n    // for instance 100 to #fff. This might live better in Popmotion.\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"warning\"])(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \" + target + \". \\\"\" + origin + \"\\\" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\r\n    // Parse the `transition` prop and return options for the Popmotion animation\r\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"type\"]);\r\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\r\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\r\n        ? transitions[type]\r\n        : just;\r\n    var opts = preprocessOptions(type, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\r\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\r\n    if (isDurationAnimation(opts)) {\r\n        if (opts.duration) {\r\n            opts.duration = secondsToMilliseconds(opts.duration);\r\n        }\r\n        if (opts.repeatDelay) {\r\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\r\n        }\r\n    }\r\n    return [actionFactory, opts];\r\n};\r\n/**\r\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\r\n *\r\n * @internal\r\n */\r\nfunction startAnimation(key, value, target, _a) {\r\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"delay\"]);\r\n    return value.start(function (complete) {\r\n        var activeAnimation;\r\n        var _a = getAnimation(key, value, target, transition), animationFactory = _a[0], _b = _a[1], valueDelay = _b.delay, options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_b, [\"delay\"]);\r\n        if (valueDelay !== undefined) {\r\n            delay$1 = valueDelay;\r\n        }\r\n        var animate = function () {\r\n            var animation = animationFactory(options);\r\n            // Bind animation opts to animation\r\n            activeAnimation = animation.start({\r\n                update: function (v) { return value.set(v); },\r\n                complete: complete,\r\n            });\r\n        };\r\n        // If we're delaying this animation, only resolve it **after** the delay to\r\n        // ensure the value's resolve velocity is up-to-date.\r\n        if (delay$1) {\r\n            activeAnimation = Object(popmotion__WEBPACK_IMPORTED_MODULE_7__[\"delay\"])(secondsToMilliseconds(delay$1)).start({\r\n                complete: animate,\r\n            });\r\n        }\r\n        else {\r\n            animate();\r\n        }\r\n        return function () {\r\n            if (activeAnimation)\r\n                activeAnimation.stop();\r\n        };\r\n    });\r\n}\n\n/**\r\n * Get the current value of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getCurrent = function (values) {\r\n    var current = {};\r\n    values.forEach(function (value, key) { return (current[key] = value.get()); });\r\n    return current;\r\n};\r\n/**\r\n * Get the current velocity of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getVelocity = function (values) {\r\n    var velocity = {};\r\n    values.forEach(function (value, key) { return (velocity[key] = value.getVelocity()); });\r\n    return velocity;\r\n};\r\n/**\r\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\r\n * check, just helps with typing.\r\n * @param p -\r\n */\r\nvar isTargetResolver = function (p) {\r\n    return typeof p === \"function\";\r\n};\r\n/**\r\n * Check if value is a list of variant labels\r\n * @param v -\r\n */\r\nvar isVariantLabels = function (v) { return Array.isArray(v); };\r\n/**\r\n * Check if value is a numerical string, ie \"100\" or \"100px\"\r\n */\r\nvar isNumericalString = function (v) { return /^\\d*\\.?\\d+$/.test(v); };\r\n/**\r\n * Control animations for a single component\r\n *\r\n * @internal\r\n */\r\nvar ValueAnimationControls = /** @class */ (function () {\r\n    function ValueAnimationControls(_a) {\r\n        var _this = this;\r\n        var values = _a.values, readValueFromSource = _a.readValueFromSource, makeTargetAnimatable = _a.makeTargetAnimatable;\r\n        /**\r\n         * A reference to the component's latest props. We could probably ditch this in\r\n         * favour to a reference to the `custom` prop now we don't send all props through\r\n         * to target resolvers.\r\n         */\r\n        this.props = {};\r\n        /**\r\n         * The component's variants, as provided by `variants`\r\n         */\r\n        this.variants = {};\r\n        /**\r\n         * A set of values that we animate back to when a value is cleared of all overrides.\r\n         */\r\n        this.baseTarget = {};\r\n        /**\r\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\r\n         */\r\n        this.overrides = [];\r\n        /**\r\n         * A series of target overrides as they were originally resolved.\r\n         */\r\n        this.resolvedOverrides = [];\r\n        /**\r\n         * A Set of currently active override indexes\r\n         */\r\n        this.activeOverrides = new Set();\r\n        /**\r\n         * A Set of value keys that are currently animating.\r\n         */\r\n        this.isAnimating = new Set();\r\n        /**\r\n         * Check if the associated `MotionValueMap` has a key with the provided string.\r\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\r\n         */\r\n        this.hasValue = function (key) { return !_this.values.has(key); };\r\n        this.values = values;\r\n        this.readValueFromSource = readValueFromSource;\r\n        this.makeTargetAnimatable = makeTargetAnimatable;\r\n        this.values.forEach(function (value, key) { return (_this.baseTarget[key] = value.get()); });\r\n    }\r\n    /**\r\n     * Set the reference to the component's props.\r\n     * @param props -\r\n     */\r\n    ValueAnimationControls.prototype.setProps = function (props) {\r\n        this.props = props;\r\n    };\r\n    /**\r\n     * Set the reference to the component's variants\r\n     * @param variants -\r\n     */\r\n    ValueAnimationControls.prototype.setVariants = function (variants) {\r\n        if (variants)\r\n            this.variants = variants;\r\n    };\r\n    /**\r\n     * Set the component's default transition\r\n     * @param transition -\r\n     */\r\n    ValueAnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        if (transition)\r\n            this.defaultTransition = transition;\r\n    };\r\n    /**\r\n     * Set motion values without animation.\r\n     *\r\n     * @param definition -\r\n     * @param isActive -\r\n     */\r\n    ValueAnimationControls.prototype.setValues = function (definition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.isActive, isActive = _c === void 0 ? new Set() : _c, priority = _b.priority;\r\n        var _d = this.resolveVariant(definition), target = _d.target, transitionEnd = _d.transitionEnd;\r\n        target = this.transformValues(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, target), transitionEnd));\r\n        return Object.keys(target).forEach(function (key) {\r\n            if (isActive.has(key))\r\n                return;\r\n            isActive.add(key);\r\n            if (target) {\r\n                var targetValue = resolveFinalValueInKeyframes(target[key]);\r\n                if (_this.values.has(key)) {\r\n                    var value = _this.values.get(key);\r\n                    value && value.set(targetValue);\r\n                }\r\n                else {\r\n                    _this.values.set(key, motionValue(targetValue));\r\n                }\r\n                if (!priority)\r\n                    _this.baseTarget[key] = targetValue;\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Allows `transformValues` to be set by a component that allows us to\r\n     * transform the values in a given `Target`. This allows Framer Library\r\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\r\n     * to manually support these extended types here in Framer Motion.\r\n     *\r\n     * @param values -\r\n     */\r\n    ValueAnimationControls.prototype.transformValues = function (values) {\r\n        var transformValues = this.props.transformValues;\r\n        return transformValues ? transformValues(values) : values;\r\n    };\r\n    /**\r\n     * Check a `Target` for new values we haven't animated yet, and add them\r\n     * to the `MotionValueMap`.\r\n     *\r\n     * Currently there's functionality here that is DOM-specific, we should allow\r\n     * this functionality to be injected by the factory that creates DOM-specific\r\n     * components.\r\n     *\r\n     * @param target -\r\n     */\r\n    ValueAnimationControls.prototype.checkForNewValues = function (target) {\r\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\r\n        var numNewValues = newValueKeys.length;\r\n        if (!numNewValues)\r\n            return;\r\n        for (var i = 0; i < numNewValues; i++) {\r\n            var key = newValueKeys[i];\r\n            var targetValue = target[key];\r\n            var value = null;\r\n            // If this is a keyframes value, we can attempt to use the first value in the\r\n            // array as that's going to be the first value of the animation anyway\r\n            if (Array.isArray(targetValue)) {\r\n                value = targetValue[0];\r\n            }\r\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\r\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\r\n            // or props.style (for HTML) if the value exists there before attempting to read.\r\n            if (value === null) {\r\n                value = this.readValueFromSource(key);\r\n                Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\r\n            }\r\n            if (typeof value === \"string\" && isNumericalString(value)) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!getValueType(value) && style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"complex\"].test(targetValue)) {\r\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n                value = style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"complex\"].getAnimatableNone(targetValue);\r\n            }\r\n            this.values.set(key, motionValue(value));\r\n            this.baseTarget[key] = value;\r\n        }\r\n    };\r\n    /**\r\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\r\n     * @param variant -\r\n     */\r\n    ValueAnimationControls.prototype.resolveVariant = function (variant) {\r\n        if (!variant) {\r\n            return {\r\n                target: undefined,\r\n                transition: undefined,\r\n                transitionEnd: undefined,\r\n            };\r\n        }\r\n        if (isTargetResolver(variant)) {\r\n            // resolve current and velocity\r\n            variant = variant(this.props.custom, getCurrent(this.values), getVelocity(this.values));\r\n        }\r\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(variant, [\"transition\", \"transitionEnd\"]);\r\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\r\n    };\r\n    /**\r\n     * Get the highest active override priority index\r\n     */\r\n    ValueAnimationControls.prototype.getHighestPriority = function () {\r\n        if (!this.activeOverrides.size)\r\n            return 0;\r\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\r\n    };\r\n    /**\r\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\r\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\r\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\r\n     * than the one that was resolved when the hover gesture animation started.\r\n     *\r\n     * @param definition -\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\r\n        this.overrides[overrideIndex] = definition;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) {\r\n                return child.setOverride(definition, overrideIndex);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Start an override animation.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.startOverride = function (overrideIndex) {\r\n        var override = this.overrides[overrideIndex];\r\n        if (override) {\r\n            return this.start(override, { priority: overrideIndex });\r\n        }\r\n    };\r\n    /**\r\n     * Clear an override. We check every value we animated to in this override to see if\r\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.clearOverride = function (overrideIndex) {\r\n        var _this = this;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\r\n        }\r\n        var override = this.overrides[overrideIndex];\r\n        if (!override)\r\n            return;\r\n        this.activeOverrides.delete(overrideIndex);\r\n        var highest = this.getHighestPriority();\r\n        this.resetIsAnimating();\r\n        if (highest) {\r\n            var highestOverride = this.overrides[highest];\r\n            highestOverride && this.startOverride(highest);\r\n        }\r\n        // Figure out which remaining values were affected by the override and animate those\r\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\r\n        if (!overrideTarget)\r\n            return;\r\n        var remainingValues = {};\r\n        for (var key in this.baseTarget) {\r\n            if (overrideTarget[key] !== undefined) {\r\n                remainingValues[key] = this.baseTarget[key];\r\n            }\r\n        }\r\n        this.onStart();\r\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\r\n    };\r\n    /**\r\n     * Apply a target/variant without any animation\r\n     */\r\n    ValueAnimationControls.prototype.apply = function (definition) {\r\n        if (Array.isArray(definition)) {\r\n            return this.applyVariantLabels(definition);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            return this.applyVariantLabels([definition]);\r\n        }\r\n        else {\r\n            this.setValues(definition);\r\n        }\r\n    };\r\n    /**\r\n     * Apply variant labels without animation\r\n     */\r\n    ValueAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\r\n        var _this = this;\r\n        var isActive = new Set();\r\n        var reversedList = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(variantLabelList).reverse();\r\n        reversedList.forEach(function (key) {\r\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\r\n            if (transitionEnd) {\r\n                _this.setValues(transitionEnd, { isActive: isActive });\r\n            }\r\n            if (target) {\r\n                _this.setValues(target, { isActive: isActive });\r\n            }\r\n            if (_this.children && _this.children.size) {\r\n                _this.children.forEach(function (child) {\r\n                    return child.applyVariantLabels(variantLabelList);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.start = function (definition, opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        if (opts.priority) {\r\n            this.activeOverrides.add(opts.priority);\r\n        }\r\n        this.resetIsAnimating(opts.priority);\r\n        var animation;\r\n        if (isVariantLabels(definition)) {\r\n            animation = this.animateVariantLabels(definition, opts);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            animation = this.animateVariant(definition, opts);\r\n        }\r\n        else {\r\n            animation = this.animate(definition, opts);\r\n        }\r\n        this.onStart();\r\n        return animation.then(function () { return _this.onComplete(); });\r\n    };\r\n    ValueAnimationControls.prototype.animate = function (animationDefinition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\r\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\r\n        if (transitionOverride) {\r\n            transition = transitionOverride;\r\n        }\r\n        if (!target)\r\n            return Promise.resolve();\r\n        target = this.transformValues(target);\r\n        if (transitionEnd) {\r\n            transitionEnd = this.transformValues(transitionEnd);\r\n        }\r\n        this.checkForNewValues(target);\r\n        if (this.makeTargetAnimatable) {\r\n            var animatable = this.makeTargetAnimatable(target, transitionEnd);\r\n            target = animatable.target;\r\n            transitionEnd = animatable.transitionEnd;\r\n        }\r\n        if (priority) {\r\n            this.resolvedOverrides[priority] = target;\r\n        }\r\n        this.checkForNewValues(target);\r\n        var animations = [];\r\n        for (var key in target) {\r\n            var value = this.values.get(key);\r\n            if (!value || !target || target[key] === undefined)\r\n                continue;\r\n            var valueTarget = target[key];\r\n            if (!priority) {\r\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\r\n            }\r\n            if (this.isAnimating.has(key))\r\n                continue;\r\n            this.isAnimating.add(key);\r\n            animations.push(startAnimation(key, value, valueTarget, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ delay: delay }, transition)));\r\n        }\r\n        var allAnimations = Promise.all(animations);\r\n        return transitionEnd\r\n            ? allAnimations.then(function () {\r\n                _this.setValues(transitionEnd, { priority: priority });\r\n            })\r\n            : allAnimations;\r\n    };\r\n    ValueAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\r\n        var _this = this;\r\n        var animations = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(variantLabels).reverse()\r\n            .map(function (label) { return _this.animateVariant(label, opts); });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\r\n        var _this = this;\r\n        var when = false;\r\n        var delayChildren = 0;\r\n        var staggerChildren = 0;\r\n        var staggerDirection = 1;\r\n        var priority = (opts && opts.priority) || 0;\r\n        var variant = this.variants[variantLabel];\r\n        var getAnimations = variant\r\n            ? function () { return _this.animate(variant, opts); }\r\n            : function () { return Promise.resolve(); };\r\n        var getChildrenAnimations = this.children\r\n            ? function () {\r\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\r\n            }\r\n            : function () { return Promise.resolve(); };\r\n        if (variant && this.children) {\r\n            var transition = this.resolveVariant(variant).transition;\r\n            if (transition) {\r\n                when = transition.when || when;\r\n                delayChildren = transition.delayChildren || delayChildren;\r\n                staggerChildren = transition.staggerChildren || staggerChildren;\r\n                staggerDirection =\r\n                    transition.staggerDirection || staggerDirection;\r\n            }\r\n        }\r\n        if (when) {\r\n            var _a = when === \"beforeChildren\"\r\n                ? [getAnimations, getChildrenAnimations]\r\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\r\n            return first().then(last);\r\n        }\r\n        else {\r\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\r\n        if (delayChildren === void 0) { delayChildren = 0; }\r\n        if (staggerChildren === void 0) { staggerChildren = 0; }\r\n        if (staggerDirection === void 0) { staggerDirection = 1; }\r\n        if (priority === void 0) { priority = 0; }\r\n        if (!this.children) {\r\n            return Promise.resolve();\r\n        }\r\n        var animations = [];\r\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\r\n        var generateStaggerDuration = staggerDirection === 1\r\n            ? function (i) { return i * staggerChildren; }\r\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\r\n        Array.from(this.children).forEach(function (childControls, i) {\r\n            var animation = childControls.animateVariant(variantLabel, {\r\n                priority: priority,\r\n                delay: delayChildren + generateStaggerDuration(i),\r\n            });\r\n            animations.push(animation);\r\n        });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.onStart = function () {\r\n        var onAnimationStart = this.props.onAnimationStart;\r\n        onAnimationStart && onAnimationStart();\r\n    };\r\n    ValueAnimationControls.prototype.onComplete = function () {\r\n        var onAnimationComplete = this.props.onAnimationComplete;\r\n        onAnimationComplete && onAnimationComplete();\r\n    };\r\n    ValueAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\r\n        var numOverrides = this.overrides.length;\r\n        for (var i = priority + 1; i < numOverrides; i++) {\r\n            var resolvedOverride = this.resolvedOverrides[i];\r\n            if (resolvedOverride) {\r\n                for (var key in resolvedOverride) {\r\n                    this.isAnimating.add(key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.resetIsAnimating = function (priority) {\r\n        if (priority === void 0) { priority = 0; }\r\n        this.isAnimating.clear();\r\n        // If this isn't the highest priority gesture, block the animation\r\n        // of anything that's currently being animated\r\n        if (priority < this.getHighestPriority()) {\r\n            this.checkOverrideIsAnimating(priority);\r\n        }\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.stop = function () {\r\n        this.values.forEach(function (value) { return value.stop(); });\r\n    };\r\n    /**\r\n     * Add the controls of a child component.\r\n     * @param controls -\r\n     */\r\n    ValueAnimationControls.prototype.addChild = function (controls) {\r\n        if (!this.children) {\r\n            this.children = new Set();\r\n        }\r\n        this.children.add(controls);\r\n        // We set child overrides when `setOverride` is called, but also have to do it here\r\n        // as the first time `setOverride` is called all the children might not have been added yet.\r\n        this.overrides.forEach(function (override, i) {\r\n            override && controls.setOverride(override, i);\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.removeChild = function (controls) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(controls);\r\n    };\r\n    ValueAnimationControls.prototype.resetChildren = function () {\r\n        if (this.children)\r\n            this.children.clear();\r\n    };\r\n    return ValueAnimationControls;\r\n}());\n\n/**\r\n * Use callback either only on the initial render or on all renders. In concurrent mode\r\n * the \"initial\" render might run multiple times\r\n *\r\n * @param callback - Callback to run\r\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\r\n *\r\n * @public\r\n */\r\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\r\n    if (isInitialOnly === void 0) { isInitialOnly = false; }\r\n    var isInitialRender = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(true);\r\n    if (!isInitialOnly || (isInitialOnly && isInitialRender.current)) {\r\n        callback();\r\n    }\r\n    isInitialRender.current = false;\r\n}\n\n/**\r\n * Control animations on one or more components.\r\n *\r\n * @public\r\n */\r\nvar AnimationControls = /** @class */ (function () {\r\n    function AnimationControls() {\r\n        /**\r\n         * Track whether the host component has mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.hasMounted = false;\r\n        /**\r\n         * Pending animations that are started before a component is mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.pendingAnimations = [];\r\n        /**\r\n         * A collection of linked component animation controls.\r\n         *\r\n         * @internal\r\n         */\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Set variants on this and all child components.\r\n     *\r\n     * @param variants - The variants to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setVariants = function (variants) {\r\n        this.variants = variants;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setVariants(variants);\r\n        });\r\n    };\r\n    /**\r\n     * Set a default transition on this and all child components\r\n     *\r\n     * @param transition - The default transition to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        this.defaultTransition = transition;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setDefaultTransition(transition);\r\n        });\r\n    };\r\n    /**\r\n     * Subscribes a component's animation controls to this.\r\n     *\r\n     * @param controls - The controls to subscribe\r\n     * @returns An unsubscribe function.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        if (this.variants)\r\n            controls.setVariants(this.variants);\r\n        if (this.defaultTransition)\r\n            controls.setDefaultTransition(this.defaultTransition);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Starts an animation on all linked components.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * controls.start(\"variantLabel\")\r\n     * controls.start({\r\n     *   x: 0,\r\n     *   transition: { duration: 1 }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param definition - Properties or variant label to animate to\r\n     * @param transition - Optional `transtion` to apply to a variant\r\n     * @returns - A `Promise` that resolves when all animations have completed.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\r\n        var _this = this;\r\n        if (this.hasMounted) {\r\n            var animations_1 = [];\r\n            this.componentControls.forEach(function (controls) {\r\n                var animation = controls.start(definition, {\r\n                    transitionOverride: transitionOverride,\r\n                });\r\n                animations_1.push(animation);\r\n            });\r\n            return Promise.all(animations_1);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve) {\r\n                _this.pendingAnimations.push({\r\n                    animation: [definition, transitionOverride],\r\n                    resolve: resolve,\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Instantly set to a set of properties or a variant.\r\n     *\r\n     * ```jsx\r\n     * // With properties\r\n     * controls.set({ opacity: 0 })\r\n     *\r\n     * // With variants\r\n     * controls.set(\"hidden\")\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     * We could perform a similar trick to `.start` where this can be called before mount\r\n     * and we maintain a list of of pending actions that get applied on mount. But the\r\n     * expectation of `set` is that it happens synchronously and this would be difficult\r\n     * to do before any children have even attached themselves. It's also poor practise\r\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.set = function (definition) {\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n        return this.componentControls.forEach(function (controls) {\r\n            return controls.apply(definition);\r\n        });\r\n    };\r\n    /**\r\n     * Stops animations on all linked components.\r\n     *\r\n     * ```jsx\r\n     * controls.stop()\r\n     * ```\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.stop = function () {\r\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\r\n    };\r\n    /**\r\n     * Initialises the animation controls.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.mount = function () {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        this.pendingAnimations.forEach(function (_a) {\r\n            var animation = _a.animation, resolve = _a.resolve;\r\n            return _this.start.apply(_this, animation).then(resolve);\r\n        });\r\n    };\r\n    /**\r\n     * Stops all child animations when the host component unmounts.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.unmount = function () {\r\n        this.hasMounted = false;\r\n        this.stop();\r\n    };\r\n    return AnimationControls;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nvar animationControls = function () { return new AnimationControls(); };\n\nvar PresenceContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"])(null);\n\n/**\r\n * @internal\r\n */\r\nvar MotionContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"])({\r\n    static: false,\r\n});\r\nvar isVariantLabel = function (v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n};\r\nvar isAnimationControls = function (v) {\r\n    return v instanceof AnimationControls;\r\n};\r\n/**\r\n * Set up the context for children motion components.\r\n *\r\n * We also use this opportunity to apply `initial` values\r\n */\r\nvar useMotionContext = function (parentContext, controls, values, isStatic, _a) {\r\n    if (isStatic === void 0) { isStatic = false; }\r\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover;\r\n    var _b;\r\n    var presenceContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(PresenceContext);\r\n    // Override initial with that from a parent context, if defined\r\n    if (((_b = presenceContext) === null || _b === void 0 ? void 0 : _b.initial) !== undefined) {\r\n        initial = presenceContext.initial;\r\n    }\r\n    var initialState;\r\n    if (initial === false && !isAnimationControls(animate)) {\r\n        initialState = animate;\r\n    }\r\n    else if (typeof initial !== \"boolean\") {\r\n        initialState = initial;\r\n    }\r\n    // Track mounted status so children can detect whether they were present during their\r\n    // parent's first render\r\n    var hasMounted = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(false);\r\n    // We propagate this component's ValueAnimationControls *if* we're being provided variants,\r\n    // if we're being used to control variants, or if we're being passed animation controls.\r\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\r\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\r\n    // that this restriction is removed.\r\n    var shouldPropagateControls = variants ||\r\n        isVariantLabel(animate) ||\r\n        isVariantLabel(whileTap) ||\r\n        isVariantLabel(whileHover) ||\r\n        isAnimationControls(animate);\r\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\r\n    var targetInitial = isVariantLabel(initialState)\r\n        ? initialState\r\n        : parentContext.initial;\r\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\r\n    // the tree initially animates.\r\n    var targetAnimate = isVariantLabel(animate)\r\n        ? animate\r\n        : parentContext.animate;\r\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\r\n    // or in another non-animation/interaction environment.\r\n    var initialDependency = isStatic ? targetInitial : null;\r\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\r\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\r\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\r\n    // the new order of any child components for the `staggerChildren` functionality.\r\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\r\n        ? targetAnimate\r\n        : null;\r\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\r\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\r\n    // So all child motion components will re-render as a result.\r\n    var context = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () { return ({\r\n        controls: shouldPropagateControls\r\n            ? controls\r\n            : parentContext.controls,\r\n        initial: targetInitial,\r\n        animate: targetAnimate,\r\n        values: values,\r\n        hasMounted: hasMounted,\r\n        isReducedMotion: parentContext.isReducedMotion,\r\n    }); }, [initialDependency, animateDependency, parentContext.isReducedMotion]);\r\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\r\n    context.static = isStatic;\r\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\r\n    // in `initial`.\r\n    useInitialOrEveryRender(function () {\r\n        var initialToApply = initialState || parentContext.initial;\r\n        initialToApply && controls.apply(initialToApply);\r\n    }, !isStatic);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        hasMounted.current = true;\r\n    }, []);\r\n    return context;\r\n};\n\n/**\r\n * Creates an imperative set of controls to trigger animations.\r\n *\r\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\r\n *\r\n * @param values\r\n * @param props\r\n * @param ref\r\n * @param subscribeToParentControls\r\n *\r\n * @internal\r\n */\r\nfunction useValueAnimationControls(config, props, subscribeToParentControls) {\r\n    var variants = props.variants, transition = props.transition;\r\n    var parentControls = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext).controls;\r\n    var presenceContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(PresenceContext);\r\n    var controls = useConstant(function () { return new ValueAnimationControls(config); });\r\n    // Reset and resubscribe children every render to ensure stagger order is correct\r\n    if (!presenceContext || presenceContext.isPresent) {\r\n        controls.resetChildren();\r\n        controls.setProps(props);\r\n        controls.setVariants(variants);\r\n        controls.setDefaultTransition(transition);\r\n    }\r\n    // We have to subscribe to the parent controls within a useEffect rather than during render,\r\n    // as\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        if (subscribeToParentControls && parentControls) {\r\n            parentControls.addChild(controls);\r\n        }\r\n    });\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        return function () {\r\n            // Remove reference to onAnimationComplete from controls. All the MotionValues\r\n            // are unsubscribed from this component separately. We let animations run out\r\n            // as they might be animating other components.\r\n            var onAnimationComplete = props.onAnimationComplete, unmountProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(props, [\"onAnimationComplete\"]);\r\n            controls.setProps(unmountProps);\r\n            parentControls && parentControls.removeChild(controls);\r\n        };\r\n    }, []);\r\n    return controls;\r\n}\n\nvar checkShouldInheritVariant = function (_a) {\r\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\r\n    return (inherit &&\r\n        !!variants &&\r\n        (!animate || animate instanceof AnimationControls));\r\n};\n\n/**\r\n * Uses the ref that is passed in, or creates a new one\r\n * @param external - External ref\r\n * @internal\r\n */\r\nfunction useExternalRef(externalRef) {\r\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\r\n    // shouldn't be called conditionally. However, Framer Motion will break if this\r\n    // condition changes anyway. It might be possible to use an invariant here to\r\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\r\n    var ref = !externalRef || typeof externalRef === \"function\"\r\n        ? Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null)\r\n        : externalRef;\r\n    // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\r\n    // but `ref` types changing between renders would break Motion anyway. If we receive\r\n    // bug reports about this, we should track the provided ref and throw an invariant\r\n    // rather than move the conditional to inside the useEffect as this will be fired\r\n    // for every Frame component within Framer.\r\n    if (externalRef && typeof externalRef === \"function\") {\r\n        Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n            externalRef(ref.current);\r\n            return function () { return externalRef(null); };\r\n        }, []);\r\n    }\r\n    return ref;\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar createMotionComponent = function (_a) {\r\n    var getValueControlsConfig = _a.getValueControlsConfig, loadFunctionalityComponents = _a.loadFunctionalityComponents, renderComponent = _a.renderComponent;\r\n    function MotionComponent(props, externalRef) {\r\n        var ref = useExternalRef(externalRef);\r\n        var parentContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext);\r\n        var isStatic = parentContext.static || props.static || false;\r\n        var values = useMotionValues(props);\r\n        var style = useMotionStyles(values, props.style, isStatic, props.transformValues);\r\n        var shouldInheritVariant = checkShouldInheritVariant(props);\r\n        var controlsConfig = useConstant(function () {\r\n            return getValueControlsConfig(ref, values);\r\n        });\r\n        var controls = useValueAnimationControls(controlsConfig, props, shouldInheritVariant);\r\n        var context = useMotionContext(parentContext, controls, values, isStatic, props);\r\n        var functionality = isStatic\r\n            ? null\r\n            : loadFunctionalityComponents(ref, values, props, parentContext, controls, shouldInheritVariant);\r\n        var renderedComponent = renderComponent(ref, style, values, props, isStatic);\r\n        return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null,\r\n            Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(MotionContext.Provider, { value: context }, renderedComponent),\r\n            Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null,\r\n                Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Mount, { innerRef: ref, values: values, isStatic: isStatic }),\r\n                functionality)));\r\n    }\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"forwardRef\"])(MotionComponent);\r\n};\n\n/**\r\n * @internal\r\n */\r\nvar htmlElements = [\r\n    \"a\",\r\n    \"abbr\",\r\n    \"address\",\r\n    \"area\",\r\n    \"article\",\r\n    \"aside\",\r\n    \"audio\",\r\n    \"b\",\r\n    \"base\",\r\n    \"bdi\",\r\n    \"bdo\",\r\n    \"big\",\r\n    \"blockquote\",\r\n    \"body\",\r\n    \"br\",\r\n    \"button\",\r\n    \"canvas\",\r\n    \"caption\",\r\n    \"cite\",\r\n    \"code\",\r\n    \"col\",\r\n    \"colgroup\",\r\n    \"data\",\r\n    \"datalist\",\r\n    \"dd\",\r\n    \"del\",\r\n    \"details\",\r\n    \"dfn\",\r\n    \"dialog\",\r\n    \"div\",\r\n    \"dl\",\r\n    \"dt\",\r\n    \"em\",\r\n    \"embed\",\r\n    \"fieldset\",\r\n    \"figcaption\",\r\n    \"figure\",\r\n    \"footer\",\r\n    \"form\",\r\n    \"h1\",\r\n    \"h2\",\r\n    \"h3\",\r\n    \"h4\",\r\n    \"h5\",\r\n    \"h6\",\r\n    \"head\",\r\n    \"header\",\r\n    \"hgroup\",\r\n    \"hr\",\r\n    \"html\",\r\n    \"i\",\r\n    \"iframe\",\r\n    \"img\",\r\n    \"input\",\r\n    \"ins\",\r\n    \"kbd\",\r\n    \"keygen\",\r\n    \"label\",\r\n    \"legend\",\r\n    \"li\",\r\n    \"link\",\r\n    \"main\",\r\n    \"map\",\r\n    \"mark\",\r\n    \"menu\",\r\n    \"menuitem\",\r\n    \"meta\",\r\n    \"meter\",\r\n    \"nav\",\r\n    \"noscript\",\r\n    \"object\",\r\n    \"ol\",\r\n    \"optgroup\",\r\n    \"option\",\r\n    \"output\",\r\n    \"p\",\r\n    \"param\",\r\n    \"picture\",\r\n    \"pre\",\r\n    \"progress\",\r\n    \"q\",\r\n    \"rp\",\r\n    \"rt\",\r\n    \"ruby\",\r\n    \"s\",\r\n    \"samp\",\r\n    \"script\",\r\n    \"section\",\r\n    \"select\",\r\n    \"small\",\r\n    \"source\",\r\n    \"span\",\r\n    \"strong\",\r\n    \"style\",\r\n    \"sub\",\r\n    \"summary\",\r\n    \"sup\",\r\n    \"table\",\r\n    \"tbody\",\r\n    \"td\",\r\n    \"textarea\",\r\n    \"tfoot\",\r\n    \"th\",\r\n    \"thead\",\r\n    \"time\",\r\n    \"title\",\r\n    \"tr\",\r\n    \"track\",\r\n    \"u\",\r\n    \"ul\",\r\n    \"var\",\r\n    \"video\",\r\n    \"wbr\",\r\n    \"webview\",\r\n];\r\n/**\r\n * @internal\r\n */\r\nvar svgElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"svg\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\n\n/**\r\n * @internal\r\n */\r\nvar MotionPluginContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"])({\r\n    transformPagePoint: function (p) { return p; },\r\n});\r\n/**\r\n * @remarks For now I think this should remain a private API for our own use\r\n * until we can figure out a nicer way of allowing people to add these\r\n *\r\n * @internal\r\n */\r\nfunction MotionPlugins(_a) {\r\n    var children = _a.children, props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"children\"]);\r\n    var pluginContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionPluginContext);\r\n    var value = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, pluginContext)).current;\r\n    // Mutative to prevent triggering rerenders in all listening\r\n    // components every time this component renders\r\n    for (var key in props) {\r\n        value[key] = props[key];\r\n    }\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(MotionPluginContext.Provider, { value: value }, children));\r\n}\n\nfunction useUnmountEffect(callback) {\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () { return function () { return callback(); }; }, []);\r\n}\n\nfunction addDomEvent(target, eventName, handler, options) {\r\n    if (!handler)\r\n        return;\r\n    target.addEventListener(eventName, handler, options);\r\n    return function () { return target.removeEventListener(eventName, handler, options); };\r\n}\r\n/**\r\n * Attaches an event listener directly to the provided DOM element.\r\n *\r\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\r\n * event handlers.\r\n *\r\n * ```jsx\r\n * const ref = useRef(null)\r\n *\r\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\r\n *\r\n * return <div ref={ref} />\r\n * ```\r\n *\r\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\r\n * @param eventName - Name of the event you want listen for.\r\n * @param handler - Function to fire when receiving the event.\r\n * @param options - Options to pass to `Event.addEventListener`.\r\n *\r\n * @public\r\n */\r\nfunction useDomEvent(ref, eventName, handler, options) {\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        var element = ref.current;\r\n        if (handler && element) {\r\n            return addDomEvent(element, eventName, handler, options);\r\n        }\r\n    }, [ref, eventName, handler, options]);\r\n}\n\nfunction isMouseEvent(event) {\r\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\r\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\r\n        return !!(event.pointerType === \"mouse\");\r\n    }\r\n    return event instanceof MouseEvent;\r\n}\r\nfunction isTouchEvent(event) {\r\n    var hasTouches = !!event.touches;\r\n    return hasTouches;\r\n}\n\n/**\r\n * Filters out events not attached to the primary pointer (currently left mouse button)\r\n * @param eventHandler\r\n */\r\nfunction filterPrimaryPointer(eventHandler) {\r\n    if (!eventHandler)\r\n        return undefined;\r\n    return function (event) {\r\n        var isMouseEvent = event instanceof MouseEvent;\r\n        var isPrimaryPointer = !isMouseEvent ||\r\n            (isMouseEvent && event.button === 0);\r\n        if (isPrimaryPointer) {\r\n            eventHandler(event);\r\n        }\r\n    };\r\n}\r\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\r\nfunction pointFromTouch(e) {\r\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\r\n    var _a = primaryTouch || defaultPagePoint, pageX = _a.pageX, pageY = _a.pageY;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction pointFromMouse(_a) {\r\n    var _b = _a.pageX, pageX = _b === void 0 ? 0 : _b, _c = _a.pageY, pageY = _c === void 0 ? 0 : _c;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction extractEventInfo(event) {\r\n    return {\r\n        point: isTouchEvent(event)\r\n            ? pointFromTouch(event)\r\n            : pointFromMouse(event),\r\n    };\r\n}\r\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\r\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\r\n    if (!handler)\r\n        return;\r\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\r\n    return shouldFilterPrimaryPointer\r\n        ? filterPrimaryPointer(listener)\r\n        : listener;\r\n};\n\nvar isBrowser = typeof window !== \"undefined\";\r\n// We check for event support via functions in case they've been mocked by a testing suite.\r\nvar supportsPointerEvents = function () {\r\n    return isBrowser && window.onpointerdown === null;\r\n};\r\nvar supportsTouchEvents = function () {\r\n    return isBrowser && window.ontouchstart === null;\r\n};\r\nvar supportsMouseEvents = function () {\r\n    return isBrowser && window.onmousedown === null;\r\n};\n\nvar mouseEventNames = {\r\n    pointerdown: \"mousedown\",\r\n    pointermove: \"mousemove\",\r\n    pointerup: \"mouseup\",\r\n    pointercancel: \"mousecancel\",\r\n    pointerover: \"mouseover\",\r\n    pointerout: \"mouseout\",\r\n    pointerenter: \"mouseenter\",\r\n    pointerleave: \"mouseleave\",\r\n};\r\nvar touchEventNames = {\r\n    pointerdown: \"touchstart\",\r\n    pointermove: \"touchmove\",\r\n    pointerup: \"touchend\",\r\n    pointercancel: \"touchcancel\",\r\n};\r\nfunction getPointerEventName(name) {\r\n    if (supportsPointerEvents()) {\r\n        return name;\r\n    }\r\n    else if (supportsTouchEvents()) {\r\n        return touchEventNames[name];\r\n    }\r\n    else if (supportsMouseEvents()) {\r\n        return mouseEventNames[name];\r\n    }\r\n    return name;\r\n}\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\r\nfunction usePointerEvent(ref, eventName, handler, options) {\r\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\n\n/** @public */\r\nvar Point;\r\n(function (Point) {\r\n    /** @beta */\r\n    Point.subtract = function (a, b) {\r\n        return { x: a.x - b.x, y: a.y - b.y };\r\n    };\r\n    /** @beta */\r\n    Point.relativeTo = function (idOrElem) {\r\n        var elem;\r\n        var getElem = function () {\r\n            // Caching element here could be leaky because of React lifecycle\r\n            if (elem !== undefined)\r\n                return elem;\r\n            if (typeof idOrElem === \"string\") {\r\n                elem = document.getElementById(idOrElem);\r\n            }\r\n            else {\r\n                elem = idOrElem;\r\n            }\r\n            return elem;\r\n        };\r\n        return function (_a) {\r\n            var x = _a.x, y = _a.y;\r\n            var localElem = getElem();\r\n            if (!localElem)\r\n                return undefined;\r\n            var rect = localElem.getBoundingClientRect();\r\n            return {\r\n                x: x - rect.left - window.scrollX,\r\n                y: y - rect.top - window.scrollY,\r\n            };\r\n        };\r\n    };\r\n})(Point || (Point = {}));\n\nvar isViewportScrollBlocked = false;\r\nvar isBrowser$1 = typeof window !== \"undefined\";\r\nif (isBrowser$1) {\r\n    document.addEventListener(\"touchmove\", function (event) {\r\n        if (isViewportScrollBlocked) {\r\n            event.preventDefault();\r\n        }\r\n    }, { passive: false });\r\n}\r\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\r\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\n\n/**\r\n * @internal\r\n */\r\nvar PanSession = /** @class */ (function () {\r\n    function PanSession(event, handlers, _a) {\r\n        var _this = this;\r\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.startEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEventInfo = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.handlers = {};\r\n        this.updatePoint = function () {\r\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\r\n                return;\r\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\r\n            var isPanStarted = _this.startEvent !== null;\r\n            // Only start panning if the offset is larger than 3 pixels. If we make it\r\n            // any larger than this we'll want to reset the pointer history\r\n            // on the first update to avoid visual snapping to the cursoe.\r\n            var isDistancePastThreshold = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__[\"distance\"])(info.offset, { x: 0, y: 0 }) >= 3;\r\n            if (!isPanStarted && !isDistancePastThreshold)\r\n                return;\r\n            var point = info.point;\r\n            var timestamp = Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])().timestamp;\r\n            _this.history.push(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, point), { timestamp: timestamp }));\r\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\r\n            if (!isPanStarted) {\r\n                onStart && onStart(_this.lastMoveEvent, info);\r\n                _this.startEvent = _this.lastMoveEvent;\r\n            }\r\n            onMove && onMove(_this.lastMoveEvent, info);\r\n        };\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (isTouchEvent(event) && event.touches.length > 1)\r\n            return;\r\n        this.handlers = handlers;\r\n        this.transformPagePoint = transformPagePoint;\r\n        var info = extractEventInfo(event);\r\n        var initialInfo = transformPoint(info, this.transformPagePoint);\r\n        var point = initialInfo.point;\r\n        var timestamp = Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])().timestamp;\r\n        this.history = [Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, point), { timestamp: timestamp })];\r\n        var onSessionStart = handlers.onSessionStart;\r\n        onSessionStart &&\r\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\r\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) { return _this.handlePointerMove(event, info); });\r\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) { return _this.handlePointerUp(event, info); });\r\n        this.removeListeners = function () {\r\n            removeOnPointerMove && removeOnPointerMove();\r\n            removeOnPointerUp && removeOnPointerUp();\r\n        };\r\n    }\r\n    PanSession.prototype.handlePointerMove = function (event, info) {\r\n        this.lastMoveEvent = event;\r\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\r\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\r\n        if (isMouseEvent(event) && event.buttons === 0) {\r\n            this.handlePointerUp(event, info);\r\n            return;\r\n        }\r\n        // Throttle mouse move event to once per frame\r\n        framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(this.updatePoint, true);\r\n    };\r\n    PanSession.prototype.handlePointerUp = function (event, info) {\r\n        this.end();\r\n        var onEnd = this.handlers.onEnd;\r\n        if (!onEnd)\r\n            return;\r\n        var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\r\n        onEnd && onEnd(event, panInfo);\r\n    };\r\n    PanSession.prototype.updateHandlers = function (handlers) {\r\n        this.handlers = handlers;\r\n    };\r\n    PanSession.prototype.end = function () {\r\n        this.removeListeners && this.removeListeners();\r\n        framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(this.updatePoint);\r\n        unblockViewportScroll();\r\n    };\r\n    return PanSession;\r\n}());\r\nfunction transformPoint(info, transformPagePoint) {\r\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\r\n}\r\nfunction getPanInfo(_a, history) {\r\n    var point = _a.point;\r\n    return {\r\n        point: point,\r\n        delta: Point.subtract(point, lastDevicePoint(history)),\r\n        offset: Point.subtract(point, startDevicePoint(history)),\r\n        velocity: getVelocity$1(history, 0.1),\r\n    };\r\n}\r\nfunction startDevicePoint(history) {\r\n    return history[0];\r\n}\r\nfunction lastDevicePoint(history) {\r\n    return history[history.length - 1];\r\n}\r\nfunction getVelocity$1(history, timeDelta) {\r\n    if (history.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var i = history.length - 1;\r\n    var timestampedPoint = null;\r\n    var lastPoint = lastDevicePoint(history);\r\n    while (i >= 0) {\r\n        timestampedPoint = history[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\n\n/**\r\n *\r\n * @param handlers -\r\n * @param ref -\r\n *\r\n * @internalremarks\r\n * Currently this sets new pan gesture functions every render. The memo route has been explored\r\n * in the past but ultimately we're still creating new functions every render. An optimisation\r\n * to explore is creating the pan gestures and loading them into a `ref`.\r\n *\r\n * @internal\r\n */\r\nfunction usePanGesture(_a, ref) {\r\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\r\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\r\n    var panSession = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    var transformPagePoint = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionPluginContext).transformPagePoint;\r\n    var handlers = {\r\n        onSessionStart: onPanSessionStart,\r\n        onStart: onPanStart,\r\n        onMove: onPan,\r\n        onEnd: function (event, info) {\r\n            panSession.current = null;\r\n            onPanEnd && onPanEnd(event, info);\r\n        },\r\n    };\r\n    if (panSession.current !== null) {\r\n        panSession.current.updateHandlers(handlers);\r\n    }\r\n    function onPointerDown(event) {\r\n        panSession.current = new PanSession(event, handlers, {\r\n            transformPagePoint: transformPagePoint,\r\n        });\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\r\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\r\n}\n\n/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nvar isNodeOrChild = function (parent, child) {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\n\nvar order = [\"whileHover\", \"whileTap\", \"whileDrag\"];\r\nvar getGesturePriority = function (gesture) {\r\n    return order.indexOf(gesture) + 1;\r\n};\n\nfunction createLock(name) {\r\n    var lock = null;\r\n    return function () {\r\n        var openLock = function () {\r\n            lock = null;\r\n        };\r\n        if (lock === null) {\r\n            lock = name;\r\n            return openLock;\r\n        }\r\n        return false;\r\n    };\r\n}\r\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\r\nvar globalVerticalLock = createLock(\"dragVertical\");\r\nfunction getGlobalLock(drag) {\r\n    var lock = false;\r\n    if (drag === \"y\") {\r\n        lock = globalVerticalLock();\r\n    }\r\n    else if (drag === \"x\") {\r\n        lock = globalHorizontalLock();\r\n    }\r\n    else {\r\n        var openHorizontal_1 = globalHorizontalLock();\r\n        var openVertical_1 = globalVerticalLock();\r\n        if (openHorizontal_1 && openVertical_1) {\r\n            lock = function () {\r\n                openHorizontal_1();\r\n                openVertical_1();\r\n            };\r\n        }\r\n        else {\r\n            // Release the locks because we don't use them\r\n            if (openHorizontal_1)\r\n                openHorizontal_1();\r\n            if (openVertical_1)\r\n                openVertical_1();\r\n        }\r\n    }\r\n    return lock;\r\n}\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\r\n/**\r\n * @param handlers -\r\n * @internal\r\n */\r\nfunction useTapGesture(_a, ref) {\r\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\r\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\r\n    var isTapping = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(false);\r\n    var cancelPointerEventListener = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    function removePointerUp() {\r\n        cancelPointerEventListener.current &&\r\n            cancelPointerEventListener.current();\r\n        cancelPointerEventListener.current = null;\r\n    }\r\n    if (whileTap && controls) {\r\n        controls.setOverride(whileTap, tapGesturePriority);\r\n    }\r\n    // We load this event handler into a ref so we can later refer to\r\n    // onPointerUp.current which will always have reference to the latest props\r\n    var onPointerUp = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    onPointerUp.current = function (event, info) {\r\n        var element = ref.current;\r\n        removePointerUp();\r\n        if (!isTapping.current || !element)\r\n            return;\r\n        isTapping.current = false;\r\n        if (controls && whileTap) {\r\n            controls.clearOverride(tapGesturePriority);\r\n        }\r\n        // Check the gesture lock - if we get it, it means no drag gesture is active\r\n        // and we can safely fire the tap gesture.\r\n        var openGestureLock = getGlobalLock(true);\r\n        if (!openGestureLock)\r\n            return;\r\n        openGestureLock();\r\n        if (!isNodeOrChild(element, event.target)) {\r\n            onTapCancel && onTapCancel(event, info);\r\n        }\r\n        else {\r\n            onTap && onTap(event, info);\r\n        }\r\n    };\r\n    function onPointerDown(event, info) {\r\n        removePointerUp();\r\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\r\n        var element = ref.current;\r\n        if (!element || isTapping.current)\r\n            return;\r\n        isTapping.current = true;\r\n        onTapStart && onTapStart(event, info);\r\n        if (controls && whileTap) {\r\n            controls.startOverride(tapGesturePriority);\r\n        }\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\r\n    useUnmountEffect(removePointerUp);\r\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\r\nvar filterTouch = function (listener) { return function (event, info) {\r\n    if (isMouseEvent(event))\r\n        listener(event, info);\r\n}; };\r\n/**\r\n *\r\n * @param props\r\n * @param ref\r\n * @internal\r\n */\r\nfunction useHoverGesture(_a, ref) {\r\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\r\n    if (whileHover && controls) {\r\n        controls.setOverride(whileHover, hoverPriority);\r\n    }\r\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\r\n        if (onHoverStart)\r\n            onHoverStart(event, info);\r\n        if (whileHover && controls) {\r\n            controls.startOverride(hoverPriority);\r\n        }\r\n    }));\r\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\r\n        if (onHoverEnd)\r\n            onHoverEnd(event, info);\r\n        if (whileHover && controls) {\r\n            controls.clearOverride(hoverPriority);\r\n        }\r\n    }));\r\n}\n\n/**\r\n * Add pan and tap gesture recognition to an element.\r\n *\r\n * @param props - Gesture event handlers\r\n * @param ref - React `ref` containing a DOM `Element`\r\n * @public\r\n */\r\nfunction useGestures(props, ref) {\r\n    usePanGesture(props, ref);\r\n    useTapGesture(props, ref);\r\n    useHoverGesture(props, ref);\r\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\r\n    hook(props);\r\n    return null;\r\n}; };\n\nvar gestureProps = [\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileTap\",\r\n    \"whileHover\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n];\r\nvar Gestures = {\r\n    key: \"gestures\",\r\n    shouldRender: function (props) {\r\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\r\n    },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var innerRef = _a.innerRef, props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"innerRef\"]);\r\n        useGestures(props, innerRef);\r\n    }),\r\n};\n\nvar isRefObject = function (ref) {\r\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\r\n};\n\nvar noop = function (v) { return v; };\r\nvar ComponentDragControls = /** @class */ (function () {\r\n    function ComponentDragControls(_a) {\r\n        var ref = _a.ref, values = _a.values, controls = _a.controls;\r\n        /**\r\n         * Track whether we're currently dragging.\r\n         *\r\n         * @internal\r\n         */\r\n        this.isDragging = false;\r\n        /**\r\n         * The current direction of drag, or `null` if both.\r\n         *\r\n         * @internal\r\n         */\r\n        this.currentDirection = null;\r\n        /**\r\n         * The permitted t/r/b/l boundaries of travel, in pixels.\r\n         *\r\n         * @internal\r\n         */\r\n        this.constraints = false;\r\n        /**\r\n         * A reference to the host component's latest props.\r\n         *\r\n         * @internal\r\n         */\r\n        this.props = {\r\n            transformPagePoint: noop,\r\n        };\r\n        /**\r\n         * References to the MotionValues used for tracking the current dragged point.\r\n         *\r\n         * @internal\r\n         */\r\n        this.point = {};\r\n        /**\r\n         * The origin point for the current drag gesture.\r\n         *\r\n         * @internal\r\n         */\r\n        this.origin = {\r\n            x: motionValue(0),\r\n            y: motionValue(0),\r\n        };\r\n        // This is a reference to the global drag gesture lock, ensuring only one component\r\n        // can \"capture\" the drag of one or both axes.\r\n        // TODO: Look into moving this into pansession?\r\n        this.openGlobalLock = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.panSession = null;\r\n        /**\r\n         * A reference to the previous constraints bounding box\r\n         *\r\n         * @internal\r\n         */\r\n        this.prevConstraintsBox = {\r\n            width: 0,\r\n            height: 0,\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        this.ref = ref;\r\n        this.values = values;\r\n        this.controls = controls;\r\n    }\r\n    /**\r\n     * Start dragging the host component.\r\n     *\r\n     * @param event - The originating pointer event.\r\n     * @param options -\r\n     *\r\n     * @public\r\n     */\r\n    ComponentDragControls.prototype.start = function (originEvent, _a) {\r\n        var _this = this;\r\n        var _b = (_a === void 0 ? {} : _a).snapToCursor, snapToCursor = _b === void 0 ? false : _b;\r\n        snapToCursor && this.snapToCursor(originEvent);\r\n        var onSessionStart = function () {\r\n            // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\r\n            // which has come out of the difficulty in us being able to do this once a scroll gesture\r\n            // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\r\n            // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\r\n            // trigger this once we've got a scroll direction determined. This approach sort-of worked\r\n            // but if the component was dragged too far in a single frame page scrolling would initiate.\r\n            blockViewportScroll();\r\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\r\n            // the component.\r\n            bothAxis(function (axis) {\r\n                var axisPoint = _this.point[axis];\r\n                axisPoint && axisPoint.stop();\r\n            });\r\n        };\r\n        var onStart = function (event, info) {\r\n            // If constraints are an element, resolve them again in case they've updated.\r\n            if (_this.constraintsNeedResolution) {\r\n                var _a = _this.props, dragConstraints = _a.dragConstraints, transformPagePoint_1 = _a.transformPagePoint;\r\n                _this.constraints = calculateConstraintsFromDom(dragConstraints, _this.ref, _this.point, transformPagePoint_1);\r\n                _this.applyConstraintsToPoint();\r\n            }\r\n            // Set point origin and stop any existing animations.\r\n            bothAxis(function (axis) {\r\n                var axisPoint = _this.point[axis];\r\n                if (!axisPoint)\r\n                    return;\r\n                _this.origin[axis].set(axisPoint.get());\r\n            });\r\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\r\n            var _b = _this.props, drag = _b.drag, dragPropagation = _b.dragPropagation;\r\n            if (drag && !dragPropagation) {\r\n                if (_this.openGlobalLock)\r\n                    _this.openGlobalLock();\r\n                _this.openGlobalLock = getGlobalLock(drag);\r\n                if (!_this.openGlobalLock)\r\n                    return;\r\n            }\r\n            _this.isDragging = true;\r\n            _this.currentDirection = null;\r\n            var onDragStart = _this.props.onDragStart;\r\n            onDragStart &&\r\n                onDragStart(event, convertPanToDrag(info, _this.point));\r\n        };\r\n        var onMove = function (event, info) {\r\n            var _a = _this.props, dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock;\r\n            // If we didn't successfully receive the gesture lock, early return.\r\n            if (!dragPropagation && !_this.openGlobalLock)\r\n                return;\r\n            var offset = info.offset;\r\n            // Attempt to detect drag direction if directionLock is true\r\n            if (dragDirectionLock && _this.currentDirection === null) {\r\n                _this.currentDirection = getCurrentDirection(offset);\r\n                // If we've successfully set a direction, notify listener\r\n                if (_this.currentDirection !== null) {\r\n                    var onDirectionLock = _this.props.onDirectionLock;\r\n                    onDirectionLock && onDirectionLock(_this.currentDirection);\r\n                }\r\n                return;\r\n            }\r\n            _this.updatePoint(\"x\", offset);\r\n            _this.updatePoint(\"y\", offset);\r\n            var onDrag = _this.props.onDrag;\r\n            onDrag && onDrag(event, convertPanToDrag(info, _this.point));\r\n        };\r\n        var onEnd = function (event, info) {\r\n            _this.stop(event, info);\r\n        };\r\n        var transformPagePoint = this.props.transformPagePoint;\r\n        this.panSession = new PanSession(originEvent, {\r\n            onSessionStart: onSessionStart,\r\n            onStart: onStart,\r\n            onMove: onMove,\r\n            onEnd: onEnd,\r\n        }, { transformPagePoint: transformPagePoint });\r\n    };\r\n    ComponentDragControls.prototype.cancelDrag = function () {\r\n        unblockViewportScroll();\r\n        this.isDragging = false;\r\n        this.panSession && this.panSession.end();\r\n        this.panSession = null;\r\n        if (!this.props.dragPropagation && this.openGlobalLock) {\r\n            this.openGlobalLock();\r\n            this.openGlobalLock = null;\r\n        }\r\n    };\r\n    ComponentDragControls.prototype.stop = function (event, info) {\r\n        var _a;\r\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\r\n        this.panSession = null;\r\n        var isDragging = this.isDragging;\r\n        this.cancelDrag();\r\n        if (!isDragging)\r\n            return;\r\n        var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;\r\n        if (dragMomentum || dragElastic) {\r\n            var velocity = info.velocity;\r\n            this.animateDragEnd(velocity);\r\n        }\r\n        else {\r\n            this.recordBoxInfo(this.constraints);\r\n        }\r\n        onDragEnd && onDragEnd(event, convertPanToDrag(info, this.point));\r\n    };\r\n    ComponentDragControls.prototype.recordBoxInfo = function (constraints) {\r\n        if (constraints) {\r\n            var right = constraints.right, left = constraints.left, bottom = constraints.bottom, top_1 = constraints.top;\r\n            this.prevConstraintsBox.width = (right || 0) - (left || 0);\r\n            this.prevConstraintsBox.height = (bottom || 0) - (top_1 || 0);\r\n        }\r\n        if (this.point.x)\r\n            this.prevConstraintsBox.x = this.point.x.get();\r\n        if (this.point.y)\r\n            this.prevConstraintsBox.y = this.point.y.get();\r\n    };\r\n    ComponentDragControls.prototype.snapToCursor = function (event) {\r\n        var _this = this;\r\n        var transformPagePoint = this.props.transformPagePoint;\r\n        var point = extractEventInfo(event).point;\r\n        var boundingBox = getBoundingBox(this.ref, transformPagePoint);\r\n        var center = {\r\n            x: boundingBox.width / 2 + boundingBox.left + window.scrollX,\r\n            y: boundingBox.height / 2 + boundingBox.top + window.scrollY,\r\n        };\r\n        var offset = {\r\n            x: point.x - center.x,\r\n            y: point.y - center.y,\r\n        };\r\n        bothAxis(function (axis) {\r\n            var point = _this.point[axis];\r\n            if (!point)\r\n                return;\r\n            _this.origin[axis].set(point.get());\r\n        });\r\n        this.updatePoint(\"x\", offset);\r\n        this.updatePoint(\"y\", offset);\r\n    };\r\n    ComponentDragControls.prototype.setPoint = function (axis, value) {\r\n        this.point[axis] = value;\r\n    };\r\n    ComponentDragControls.prototype.updatePoint = function (axis, offset) {\r\n        var _a = this.props, drag = _a.drag, dragElastic = _a.dragElastic;\r\n        var axisPoint = this.point[axis];\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!shouldDrag(axis, drag, this.currentDirection) || !axisPoint)\r\n            return;\r\n        var current = applyConstraints(axis, this.origin[axis].get() + offset[axis], this.constraints, dragElastic);\r\n        axisPoint.set(current);\r\n    };\r\n    ComponentDragControls.prototype.updateProps = function (_a) {\r\n        var _this = this;\r\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? true : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\r\n        this.props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ drag: drag,\r\n            dragDirectionLock: dragDirectionLock,\r\n            dragPropagation: dragPropagation,\r\n            dragConstraints: dragConstraints,\r\n            dragElastic: dragElastic,\r\n            dragMomentum: dragMomentum }, remainingProps);\r\n        var _dragValueX = remainingProps._dragValueX, _dragValueY = remainingProps._dragValueY, dragOriginX = remainingProps.dragOriginX, dragOriginY = remainingProps.dragOriginY;\r\n        if (dragOriginX)\r\n            this.origin.x = dragOriginX;\r\n        if (dragOriginY)\r\n            this.origin.y = dragOriginY;\r\n        // Get the `MotionValue` for both draggable axes, or create them if they don't already\r\n        // exist on this component.\r\n        bothAxis(function (axis) {\r\n            if (!shouldDrag(axis, drag, _this.currentDirection))\r\n                return;\r\n            var defaultValue = axis === \"x\" ? _dragValueX : _dragValueY;\r\n            _this.setPoint(axis, defaultValue || _this.values.get(axis, 0));\r\n        });\r\n        // If `dragConstraints` is a React `ref`, we should resolve the constraints once the\r\n        // component has rendered.\r\n        this.constraintsNeedResolution = isRefObject(dragConstraints);\r\n        this.constraints = this.constraintsNeedResolution\r\n            ? this.constraints || false\r\n            : dragConstraints;\r\n    };\r\n    ComponentDragControls.prototype.applyConstraintsToPoint = function (constraints) {\r\n        var _this = this;\r\n        if (constraints === void 0) { constraints = this.constraints; }\r\n        return bothAxis(function (axis) {\r\n            var axisPoint = _this.point[axis];\r\n            axisPoint &&\r\n                !axisPoint.isAnimating() &&\r\n                applyConstraints(axis, axisPoint, constraints, 0);\r\n        });\r\n    };\r\n    ComponentDragControls.prototype.animateDragEnd = function (velocity) {\r\n        var _this = this;\r\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, _dragValueX = _a._dragValueX, _dragValueY = _a._dragValueY, _dragTransitionControls = _a._dragTransitionControls;\r\n        var momentumAnimations = bothAxis(function (axis) {\r\n            var _a;\r\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\r\n                return;\r\n            }\r\n            var transition = _this.constraints\r\n                ? getConstraints(axis, _this.constraints)\r\n                : {};\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            var bounceStiffness = dragElastic ? 200 : 1000000;\r\n            var bounceDamping = dragElastic ? 40 : 10000000;\r\n            var animationControls = _dragTransitionControls || _this.controls;\r\n            var inertia = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\r\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1 }, dragTransition), transition);\r\n            var externalAxisMotionValue = axis === \"x\" ? _dragValueX : _dragValueY;\r\n            // If we're not animating on an externally-provided `MotionValue` we can use the\r\n            // component's animation controls which will handle interactions with whileHover (etc),\r\n            // otherwise we just have to animate the `MotionValue` itself.\r\n            return externalAxisMotionValue\r\n                ? startAnimation(axis, externalAxisMotionValue, 0, inertia)\r\n                : animationControls.start((_a = {},\r\n                    _a[axis] = 0,\r\n                    _a.transition = inertia,\r\n                    _a));\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        return Promise.all(momentumAnimations).then(function () {\r\n            _this.recordBoxInfo(_this.constraints);\r\n            _this.scalePoint();\r\n            var onDragTransitionEnd = _this.props.onDragTransitionEnd;\r\n            onDragTransitionEnd && onDragTransitionEnd();\r\n        });\r\n    };\r\n    ComponentDragControls.prototype.scalePoint = function () {\r\n        var _this = this;\r\n        var _a = this.props, dragConstraints = _a.dragConstraints, transformPagePoint = _a.transformPagePoint;\r\n        if (!isRefObject(dragConstraints))\r\n            return;\r\n        var constraintsBox = getBoundingBox(dragConstraints, transformPagePoint);\r\n        var draggableBox = getBoundingBox(this.ref, transformPagePoint);\r\n        // Scale a point relative to the transformation of a constraints-providing element.\r\n        var scaleAxisPoint = function (axis, dimension) {\r\n            var pointToScale = _this.point[axis];\r\n            if (!pointToScale)\r\n                return;\r\n            // Stop any current animations as they bug out if you resize during one\r\n            if (pointToScale.isAnimating()) {\r\n                pointToScale.stop();\r\n                _this.recordBoxInfo();\r\n                return;\r\n            }\r\n            // If the previous dimension was `0` (default), set `scale` to `1` to prevent\r\n            // divide by zero errors.\r\n            var scale = _this.prevConstraintsBox[dimension]\r\n                ? (constraintsBox[dimension] - draggableBox[dimension]) /\r\n                    _this.prevConstraintsBox[dimension]\r\n                : 1;\r\n            pointToScale.set(_this.prevConstraintsBox[axis] * scale);\r\n        };\r\n        scaleAxisPoint(\"x\", \"width\");\r\n        scaleAxisPoint(\"y\", \"height\");\r\n    };\r\n    ComponentDragControls.prototype.mount = function (element) {\r\n        var _this = this;\r\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\r\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\r\n            drag && dragListener && _this.start(event);\r\n        });\r\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\r\n            return _this.scalePoint();\r\n        });\r\n        if (this.constraintsNeedResolution) {\r\n            var _a = this.props, dragConstraints = _a.dragConstraints, transformPagePoint = _a.transformPagePoint;\r\n            var constraints = calculateConstraintsFromDom(dragConstraints, this.ref, this.point, transformPagePoint);\r\n            this.applyConstraintsToPoint(constraints);\r\n            this.recordBoxInfo(constraints);\r\n        }\r\n        else if (!this.isDragging && this.constraints) {\r\n            this.applyConstraintsToPoint();\r\n        }\r\n        return function () {\r\n            stopPointerListener && stopPointerListener();\r\n            stopResizeListener && stopResizeListener();\r\n            _this.cancelDrag();\r\n        };\r\n    };\r\n    return ComponentDragControls;\r\n}());\r\n// Call a handler once for each axis\r\nfunction bothAxis(handler) {\r\n    return [handler(\"x\"), handler(\"y\")];\r\n}\r\nfunction convertPanToDrag(info, point) {\r\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, info), { point: {\r\n            x: point.x ? point.x.get() : 0,\r\n            y: point.y ? point.y.get() : 0,\r\n        } });\r\n}\r\nfunction getConstraints(axis, _a) {\r\n    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\r\n    if (axis === \"x\") {\r\n        return { min: left, max: right };\r\n    }\r\n    else {\r\n        return { min: top, max: bottom };\r\n    }\r\n}\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold) {\r\n    if (lockThreshold === void 0) { lockThreshold = 10; }\r\n    var direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\r\n/**\r\n * Takes a parent Element and a draggable Element and returns pixel-based drag constraints.\r\n *\r\n * @param constraintsRef\r\n * @param draggableRef\r\n */\r\nfunction calculateConstraintsFromDom(constraintsRef, draggableRef, point, transformPagePoint) {\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(constraintsRef.current !== null && draggableRef.current !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n    var parentBoundingBox = getBoundingBox(constraintsRef, transformPagePoint);\r\n    var draggableBoundingBox = getBoundingBox(draggableRef, transformPagePoint);\r\n    var left = parentBoundingBox.left -\r\n        draggableBoundingBox.left +\r\n        getCurrentOffset(point.x);\r\n    var top = parentBoundingBox.top -\r\n        draggableBoundingBox.top +\r\n        getCurrentOffset(point.y);\r\n    var right = parentBoundingBox.width - draggableBoundingBox.width + left;\r\n    var bottom = parentBoundingBox.height - draggableBoundingBox.height + top;\r\n    return { top: top, left: left, right: right, bottom: bottom };\r\n}\r\nfunction getBoundingBox(ref, transformPagePoint) {\r\n    var rect = ref.current.getBoundingClientRect();\r\n    var _a = transformPagePoint({\r\n        x: rect.left,\r\n        y: rect.top,\r\n    }), left = _a.x, top = _a.y;\r\n    var _b = transformPagePoint({\r\n        x: rect.width,\r\n        y: rect.height,\r\n    }), width = _b.x, height = _b.y;\r\n    return { left: left, top: top, width: width, height: height };\r\n}\r\nfunction getCurrentOffset(point) {\r\n    return point ? point.get() : 0;\r\n}\r\nfunction applyConstraints(axis, value, constraints, dragElastic) {\r\n    var constrainedValue = value instanceof MotionValue ? value.get() : value;\r\n    if (!constraints) {\r\n        return constrainedValue;\r\n    }\r\n    var _a = getConstraints(axis, constraints), min = _a.min, max = _a.max;\r\n    if (min !== undefined && constrainedValue < min) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(min, constrainedValue, dragElastic)\r\n            : Math.max(min, constrainedValue);\r\n    }\r\n    else if (max !== undefined && constrainedValue > max) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(max, constrainedValue, dragElastic)\r\n            : Math.min(max, constrainedValue);\r\n    }\r\n    if (value instanceof MotionValue) {\r\n        value.set(constrainedValue);\r\n    }\r\n    return constrainedValue;\r\n}\r\nfunction applyOverdrag(origin, current, dragElastic) {\r\n    var dragFactor = typeof dragElastic === \"number\" ? dragElastic : 0.35;\r\n    return Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__[\"mix\"])(origin, current, dragFactor);\r\n}\n\n/**\r\n * A hook that allows an element to be dragged.\r\n *\r\n * @param param\r\n * @param ref\r\n * @param values\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useDrag(props, ref, values, controls) {\r\n    var groupDragControls = props.dragControls;\r\n    var transformPagePoint = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionPluginContext).transformPagePoint;\r\n    var dragControls = useConstant(function () { return new ComponentDragControls({ ref: ref, values: values, controls: controls }); });\r\n    dragControls.updateProps(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props), { transformPagePoint: transformPagePoint }));\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () { return dragControls.mount(ref.current); }, []);\r\n}\n\nvar Drag = {\r\n    key: \"drag\",\r\n    shouldRender: function (props) { return !!props.drag; },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var innerRef = _a.innerRef, values = _a.values, controls = _a.controls, props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"innerRef\", \"values\", \"controls\"]);\r\n        return useDrag(props, innerRef, values, controls);\r\n    }),\r\n};\n\nfunction isCSSVariable(value) {\r\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\r\n}\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\r\nfunction parseCSSVariable(current) {\r\n    var match = cssVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    var token = match[1], fallback = match[2];\r\n    return [token, fallback];\r\n}\r\nvar maxDepth = 4;\r\nfunction getVariableValue(current, element, depth) {\r\n    if (depth === void 0) { depth = 1; }\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\r\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        return resolved;\r\n    }\r\n    else if (isCSSVariable(fallback)) {\r\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\r\n        return getVariableValue(fallback, element, depth + 1);\r\n    }\r\n    else {\r\n        return fallback;\r\n    }\r\n}\r\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\r\nfunction resolveCSSVariables(values, ref, _a, transitionEnd) {\r\n    var target = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, []);\r\n    var element = ref.current;\r\n    if (!(element instanceof HTMLElement))\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\r\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\r\n    if (transitionEnd) {\r\n        transitionEnd = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, transitionEnd);\r\n    }\r\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\r\n    values.forEach(function (value) {\r\n        var current = value.get();\r\n        if (!isCSSVariable(current))\r\n            return;\r\n        var resolved = getVariableValue(current, element);\r\n        if (resolved)\r\n            value.set(resolved);\r\n    });\r\n    // Cycle through every target property and resolve CSS variables. Currently\r\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\r\n    for (var key in target) {\r\n        var current = target[key];\r\n        if (!isCSSVariable(current))\r\n            continue;\r\n        var resolved = getVariableValue(current, element);\r\n        if (!resolved)\r\n            continue;\r\n        // Clone target if it hasn't already been\r\n        target[key] = resolved;\r\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\r\n        // CSS variable. This will ensure that after the animation the component will reflect\r\n        // changes in the value of the CSS variable.\r\n        if (transitionEnd && transitionEnd[key] === undefined) {\r\n            transitionEnd[key] = current;\r\n        }\r\n    }\r\n    return { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"number\"] || v === style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"px\"];\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\r\n    var transform = _a.transform;\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}; };\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = stylefire__WEBPACK_IMPORTED_MODULE_4__[\"transformProps\"].filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(values, elementStyler) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = values.get(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        elementStyler.render();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a) {\r\n        var width = _a.width;\r\n        return width;\r\n    },\r\n    height: function (_a) {\r\n        var height = _a.height;\r\n        return height;\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var height = _a.height;\r\n        var top = _b.top;\r\n        return parseFloat(top) + height;\r\n    },\r\n    right: function (_a, _b) {\r\n        var width = _a.width;\r\n        var left = _b.left;\r\n        return parseFloat(left) + width;\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, values, element, elementStyler, changedKeys) {\r\n    var originBbox = element.getBoundingClientRect();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\r\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        elementStyler.set(\"display\", target.display || \"block\");\r\n    }\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    elementStyler.render();\r\n    var targetBbox = element.getBoundingClientRect();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = values.get(key);\r\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (values, ref, target, transitionEnd) {\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, target);\r\n    transitionEnd = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, transitionEnd);\r\n    var element = ref.current;\r\n    var elementStyler = Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(element);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = targetPositionalKeys.reduce(function (acc, key) {\r\n        var value = values.get(key);\r\n        if (!value)\r\n            return acc;\r\n        var from = value.get();\r\n        var to = target[key];\r\n        var fromType = getDimensionValueType(from);\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = getDimensionValueType(to[i]);\r\n                    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(toType === fromType ||\r\n                        (isNumOrPxType(fromType) &&\r\n                            isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(getDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = getDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === style_value_types__WEBPACK_IMPORTED_MODULE_6__[\"px\"]) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues = removeNonTranslationalTransform(values, elementStyler);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                acc.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n        return acc;\r\n    }, []);\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, values, element, elementStyler, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var key = _a[0], value = _a[1];\r\n                values.get(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        elementStyler.render();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @param values\r\n * @param ref\r\n * @param target\r\n * @param transitionEnd\r\n * @internal\r\n */\r\nfunction unitConversion(values, ref, target, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(values, ref, target, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar parseDomVariant = function (values, ref) {\r\n    return function (target, transitionEnd) {\r\n        var resolved = resolveCSSVariables(values, ref, target, transitionEnd);\r\n        target = resolved.target;\r\n        transitionEnd = resolved.transitionEnd;\r\n        return unitConversion(values, ref, target, transitionEnd);\r\n    };\r\n};\n\nfunction useForceUpdate() {\r\n    var _a = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useCallback\"])(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\r\n        forcedRenderCount,\r\n    ]);\r\n}\n\nvar SyncLayoutContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createContext\"])(null);\r\n/**\r\n * When layout changes happen asynchronously to their instigating render (ie when exiting\r\n * children of `AnimatePresence` are removed), `SyncLayout` can wrap parent and sibling\r\n * components that need to animate as a result of this layout change.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = ({ isVisible }) => {\r\n *   return (\r\n *     <SyncLayout>\r\n *       <AnimatePresence>\r\n *         {isVisible && (\r\n *           <motion.div exit={{ opacity: 0 }} />\r\n *         )}\r\n *       </AnimatePresence>\r\n *       <motion.div positionTransition />\r\n *     </SyncLayout>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * The way this component works is by memoising a function and passing it down via context.\r\n * The function, when called, updates the local state, which is used to invalidate the\r\n * memoisation cache. A new function is called, performing a synced re-render of components\r\n * that are using the SyncLayoutContext.\r\n *\r\n * @internal\r\n */\r\nvar UnstableSyncLayout = function (_a) {\r\n    var children = _a.children;\r\n    var forceUpdate = useForceUpdate();\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(SyncLayoutContext.Provider, { value: forceUpdate }, children));\r\n};\n\nvar _a;\r\nvar StepName;\r\n(function (StepName) {\r\n    StepName[\"Prepare\"] = \"prepare\";\r\n    StepName[\"Read\"] = \"read\";\r\n    StepName[\"Render\"] = \"render\";\r\n})(StepName || (StepName = {}));\r\nvar stepOrder = [StepName.Prepare, StepName.Read, StepName.Render];\r\nvar jobs = stepOrder.reduce(function (acc, key) {\r\n    acc[key] = [];\r\n    return acc;\r\n}, {});\r\nvar jobsNeedProcessing = false;\r\nfunction flushCallbackList(list) {\r\n    var numJobs = list.length;\r\n    for (var i = 0; i < numJobs; i++) {\r\n        list[i]();\r\n    }\r\n    list.length = 0;\r\n}\r\nfunction flushAllJobs() {\r\n    if (!jobsNeedProcessing)\r\n        return;\r\n    flushCallbackList(jobs.prepare);\r\n    flushCallbackList(jobs.read);\r\n    flushCallbackList(jobs.render);\r\n    jobsNeedProcessing = false;\r\n}\r\n// Note: The approach of schedulng jobs during the render step is incompatible with concurrent mode\r\n// where multiple renders might happen without a DOM update. This would result in unneccessary batched\r\n// jobs. But this was already a problem with our previous approach to positionTransition.\r\n// Hopefully the React team offer a getSnapshotBeforeUpdate-esque hook and we can move to that.\r\nvar createUseSyncEffect = function (stepName) { return function (callback) {\r\n    if (!callback)\r\n        return;\r\n    jobsNeedProcessing = true;\r\n    jobs[stepName].push(callback);\r\n}; };\r\nvar layoutSync = (_a = {},\r\n    _a[StepName.Prepare] = createUseSyncEffect(StepName.Prepare),\r\n    _a[StepName.Read] = createUseSyncEffect(StepName.Read),\r\n    _a[StepName.Render] = createUseSyncEffect(StepName.Render),\r\n    _a.flush = flushAllJobs,\r\n    _a);\n\nfunction isHTMLElement(element) {\r\n    return element instanceof HTMLElement;\r\n}\n\nvar defaultLayoutTransition = {\r\n    duration: 0.8,\r\n    ease: [0.45, 0.05, 0.19, 1.0],\r\n};\r\nvar defaultPositionTransition = underDampedSpring();\r\nfunction getDefaultLayoutTransition(isPositionOnly) {\r\n    return isPositionOnly ? defaultPositionTransition : defaultLayoutTransition;\r\n}\r\nfunction isResolver(transition) {\r\n    return typeof transition === \"function\";\r\n}\r\nvar axisLabels = {\r\n    x: {\r\n        id: \"x\",\r\n        size: \"width\",\r\n        min: \"left\",\r\n        max: \"right\",\r\n        origin: \"originX\",\r\n    },\r\n    y: {\r\n        id: \"y\",\r\n        size: \"height\",\r\n        min: \"top\",\r\n        max: \"bottom\",\r\n        origin: \"originY\",\r\n    },\r\n};\r\nfunction centerOf(min, max) {\r\n    return (min + max) / 2;\r\n}\r\nfunction calcAxisDelta(prev, next, names) {\r\n    var _a;\r\n    var sizeDelta = prev[names.size] - next[names.size];\r\n    var origin = 0.5;\r\n    // If the element has changed size we want to check whether either side is in\r\n    // the same position before/after the layout transition. If so, we can anchor\r\n    // the element to that position and only animate its size.\r\n    if (sizeDelta) {\r\n        if (prev[names.min] === next[names.min]) {\r\n            origin = 0;\r\n        }\r\n        else if (prev[names.max] === next[names.max]) {\r\n            origin = 1;\r\n        }\r\n    }\r\n    var delta = (_a = {},\r\n        _a[names.size] = sizeDelta,\r\n        _a[names.origin] = origin,\r\n        _a[names.id] = \r\n        // Only measure a position delta if we haven't anchored to one side\r\n        origin === 0.5\r\n            ? centerOf(prev[names.min], prev[names.max]) -\r\n                centerOf(next[names.min], next[names.max])\r\n            : 0,\r\n        _a);\r\n    return delta;\r\n}\r\nfunction calcDelta(prev, next) {\r\n    var delta = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, calcAxisDelta(prev, next, axisLabels.x)), calcAxisDelta(prev, next, axisLabels.y));\r\n    return delta;\r\n}\r\nvar offset = {\r\n    getLayout: function (_a) {\r\n        var offset = _a.offset;\r\n        return offset;\r\n    },\r\n    measure: function (element) {\r\n        var offsetLeft = element.offsetLeft, offsetTop = element.offsetTop, offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;\r\n        return {\r\n            left: offsetLeft,\r\n            top: offsetTop,\r\n            right: offsetLeft + offsetWidth,\r\n            bottom: offsetTop + offsetHeight,\r\n            width: offsetWidth,\r\n            height: offsetHeight,\r\n        };\r\n    },\r\n};\r\nvar boundingBox = {\r\n    getLayout: function (_a) {\r\n        var boundingBox = _a.boundingBox;\r\n        return boundingBox;\r\n    },\r\n    measure: function (element) {\r\n        var _a = element.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height, right = _a.right, bottom = _a.bottom;\r\n        return { left: left, top: top, width: width, height: height, right: right, bottom: bottom };\r\n    },\r\n};\r\nfunction readPositionStyle(element) {\r\n    return window.getComputedStyle(element).position;\r\n}\r\nfunction getLayoutType(prev, next, isPositionOnly) {\r\n    return isPositionOnly && prev === next ? offset : boundingBox;\r\n}\r\nfunction isSizeKey(key) {\r\n    return key === \"width\" || key === \"height\";\r\n}\r\nfunction getTransition(_a) {\r\n    var layoutTransition = _a.layoutTransition, positionTransition = _a.positionTransition;\r\n    return layoutTransition || positionTransition;\r\n}\r\nvar LayoutAnimation = /** @class */ (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LayoutAnimation, _super);\r\n    function LayoutAnimation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Measure the current state of the DOM before it's updated, and schedule checks to see\r\n    // if it's changed as a result of a React render.\r\n    LayoutAnimation.prototype.getSnapshotBeforeUpdate = function () {\r\n        var _a = this.props, innerRef = _a.innerRef, positionTransition = _a.positionTransition, values = _a.values, controls = _a.controls;\r\n        var element = innerRef.current;\r\n        if (!isHTMLElement(element))\r\n            return;\r\n        var layoutTransition = getTransition(this.props);\r\n        var isPositionOnly = !!positionTransition;\r\n        var positionStyle = readPositionStyle(element);\r\n        var prev = {\r\n            offset: offset.measure(element),\r\n            boundingBox: boundingBox.measure(element),\r\n        };\r\n        var transform;\r\n        var next;\r\n        var compare;\r\n        // We split the unsetting, read and reapplication of the `transform` style prop into\r\n        // different steps via useSyncEffect. Multiple components might all be doing the same\r\n        // thing and by splitting these jobs and flushing them in batches we prevent layout thrashing.\r\n        layoutSync.prepare(function () {\r\n            // Unset the transform of all layoutTransition components so we can accurately measure\r\n            // the target bounding box\r\n            transform = element.style.transform;\r\n            element.style.transform = \"\";\r\n        });\r\n        layoutSync.read(function () {\r\n            // Read the target VisualInfo of all layoutTransition components\r\n            next = {\r\n                offset: offset.measure(element),\r\n                boundingBox: boundingBox.measure(element),\r\n            };\r\n            var nextPosition = readPositionStyle(element);\r\n            compare = getLayoutType(positionStyle, nextPosition, isPositionOnly);\r\n        });\r\n        layoutSync.render(function () {\r\n            // Reverse the layout delta of all newly laid-out layoutTransition components into their\r\n            // prev visual state and then animate them into their new one using transforms.\r\n            var prevLayout = compare.getLayout(prev);\r\n            var nextLayout = compare.getLayout(next);\r\n            var delta = calcDelta(prevLayout, nextLayout);\r\n            var hasAnyChanged = delta.x || delta.y || delta.width || delta.height;\r\n            if (!hasAnyChanged) {\r\n                // If layout hasn't changed, reapply the transform and get out of here.\r\n                transform && (element.style.transform = transform);\r\n                return;\r\n            }\r\n            Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(element).set({\r\n                originX: delta.originX,\r\n                originY: delta.originY,\r\n            });\r\n            syncRenderSession.open();\r\n            var target = {};\r\n            var transition = {};\r\n            var transitionDefinition = isResolver(layoutTransition)\r\n                ? layoutTransition({ delta: delta })\r\n                : layoutTransition;\r\n            function makeTransition(layoutKey, transformKey, targetValue, visualOrigin) {\r\n                // If this dimension hasn't changed, early return\r\n                var deltaKey = isSizeKey(layoutKey) ? layoutKey : transformKey;\r\n                if (!delta[deltaKey])\r\n                    return;\r\n                var baseTransition = typeof transitionDefinition === \"boolean\"\r\n                    ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, getDefaultLayoutTransition(isPositionOnly)) : transitionDefinition;\r\n                var value = values.get(transformKey, targetValue);\r\n                var velocity = value.getVelocity();\r\n                transition[transformKey] = baseTransition[transformKey]\r\n                    ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, baseTransition[transformKey]) : Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, baseTransition);\r\n                if (transition[transformKey].velocity === undefined) {\r\n                    transition[transformKey].velocity = velocity || 0;\r\n                }\r\n                // The target value of all transforms is the default value of that prop (ie x = 0, scaleX = 1)\r\n                // This is because we're inverting the layout change with `transform` and then animating to `transform: none`\r\n                target[transformKey] = targetValue;\r\n                var offsetToApply = !isSizeKey(layoutKey) && compare === offset\r\n                    ? value.get()\r\n                    : 0;\r\n                value.set(visualOrigin + offsetToApply);\r\n            }\r\n            makeTransition(\"left\", \"x\", 0, delta.x);\r\n            makeTransition(\"top\", \"y\", 0, delta.y);\r\n            if (!isPositionOnly) {\r\n                makeTransition(\"width\", \"scaleX\", 1, prev.boundingBox.width / next.boundingBox.width);\r\n                makeTransition(\"height\", \"scaleY\", 1, prev.boundingBox.height / next.boundingBox.height);\r\n            }\r\n            target.transition = transition;\r\n            // Only start the transition if `transitionDefinition` isn't `false`. Otherwise we want\r\n            // to leave the values in their newly-inverted state and let the user cope with the rest.\r\n            transitionDefinition && controls.start(target);\r\n            // Force a render to ensure there's no visual flickering\r\n            syncRenderSession.flush();\r\n        });\r\n        return null;\r\n    };\r\n    LayoutAnimation.prototype.componentDidUpdate = function () {\r\n        layoutSync.flush();\r\n    };\r\n    LayoutAnimation.prototype.render = function () {\r\n        return null;\r\n    };\r\n    LayoutAnimation.contextType = SyncLayoutContext;\r\n    return LayoutAnimation;\r\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\r\nvar Layout = {\r\n    key: \"layout\",\r\n    shouldRender: function (_a) {\r\n        var positionTransition = _a.positionTransition, layoutTransition = _a.layoutTransition;\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(!(positionTransition && layoutTransition), \"Don't set both positionTransition and layoutTransition on the same component\");\r\n        return (typeof window !== \"undefined\" &&\r\n            !!(positionTransition || layoutTransition));\r\n    },\r\n    Component: LayoutAnimation,\r\n};\n\n/**\r\n * A list of all valid MotionProps\r\n *\r\n * @internalremarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nvar validMotionProps = new Set([\r\n    \"initial\",\r\n    \"animate\",\r\n    \"exit\",\r\n    \"style\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"transformValues\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"static\",\r\n    \"positionTransition\",\r\n    \"layoutTransition\",\r\n    \"onAnimationStart\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"drag\",\r\n    \"dragControls\",\r\n    \"dragListener\",\r\n    \"dragConstraints\",\r\n    \"dragDirectionLock\",\r\n    \"dragElastic\",\r\n    \"dragMomentum\",\r\n    \"dragPropagation\",\r\n    \"dragTransition\",\r\n    \"_dragValueX\",\r\n    \"_dragValueY\",\r\n    \"_dragTransitionControls\",\r\n    \"dragOriginX\",\r\n    \"dragOriginY\",\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"onHoverEnd\",\r\n    \"onHoverStart\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return validMotionProps.has(key);\r\n}\n\nvar AnimatePropType;\r\n(function (AnimatePropType) {\r\n    AnimatePropType[\"Target\"] = \"Target\";\r\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\r\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\r\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\r\n    if (prev === null)\r\n        return false;\r\n    var prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (var i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\n\nvar hasUpdated = function (prev, next) {\r\n    return (next !== undefined &&\r\n        (Array.isArray(prev) && Array.isArray(next)\r\n            ? !shallowCompare(next, prev)\r\n            : prev !== next));\r\n};\r\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\r\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\r\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"transition\", \"transitionEnd\"]);\r\n    return mergeTransitionEnd\r\n        ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, target), transitionEnd)\r\n        : target;\r\n}\r\n/**\r\n * Handle the `animate` prop when its an object of values, ie:\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ opacity: 1 }} />\r\n * ```\r\n *\r\n * @internalremarks\r\n * It might be worth consolidating this with `use-variants`\r\n *\r\n * ```jsx\r\n * <motion.div animate=\"visible\" />\r\n * ```\r\n *\r\n * @param target\r\n * @param controls\r\n * @param values\r\n * @param transition\r\n *\r\n * @internal\r\n */\r\nfunction useAnimateProp(targetAndTransition, controls, values, defaultTransition) {\r\n    var isInitialRender = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(true);\r\n    var prevValues = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    if (!prevValues.current) {\r\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\r\n    }\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        var targetToAnimate = {};\r\n        // These are the values we're actually animating\r\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\r\n        // This is the target as it'll be once transitionEnd values are applied\r\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\r\n        // Detect which values have changed between renders\r\n        for (var key in animatingTarget) {\r\n            // This value should animate on mount if this value doesn't already exist (wasn't\r\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\r\n            var shouldAnimateOnMount = isInitialRender.current &&\r\n                (!values.has(key) ||\r\n                    values.get(key).get() !== finalTarget[key]);\r\n            // If this value has updated between renders or it's we're animating this value on mount,\r\n            // add it to the animate target.\r\n            var isValidValue = finalTarget[key] !== null;\r\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\r\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\r\n                targetToAnimate[key] = animatingTarget[key];\r\n            }\r\n        }\r\n        isInitialRender.current = false;\r\n        prevValues.current = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, prevValues.current), finalTarget);\r\n        if (Object.keys(targetToAnimate).length) {\r\n            controls.start(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\r\n        }\r\n    }, [targetAndTransition]);\r\n}\n\nvar labelsToArray = function (label) {\r\n    if (!label) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(label)) {\r\n        return label;\r\n    }\r\n    return [label];\r\n};\r\nvar resolveVariantLabels = function (variant) {\r\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\r\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\r\n};\r\n/**\r\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\r\n * When values in this array change, React re-runs the dependency. However if the array\r\n * contains a variable number of items, React throws an error.\r\n */\r\nvar asDependencyList = function (list) { return [\r\n    list.join(\",\"),\r\n]; };\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\r\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\r\n};\r\n/**\r\n * Handle variants and the `animate` prop when its set as variant labels.\r\n *\r\n * @param initial - Initial variant(s)\r\n * @param animate - Variant(s) to animate to\r\n * @param inherit - `true` is inheriting animations from parent\r\n * @param controls - Animation controls\r\n *\r\n * @internal\r\n */\r\nfunction useVariants(initial, animate, inherit, controls) {\r\n    var targetVariants = resolveVariantLabels(animate);\r\n    var context = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext);\r\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\r\n    var hasMounted = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(false);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        var shouldAnimate = false;\r\n        if (inherit) {\r\n            // If we're inheriting variant changes and the parent has already\r\n            // mounted when this component loads, we need to manually trigger\r\n            // this animation.\r\n            shouldAnimate = !!parentAlreadyMounted;\r\n            targetVariants = resolveVariantLabels(context.animate);\r\n        }\r\n        else {\r\n            shouldAnimate =\r\n                hasMounted.current ||\r\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\r\n        }\r\n        shouldAnimate && controls.start(targetVariants);\r\n        hasMounted.current = true;\r\n    }, asDependencyList(targetVariants));\r\n}\n\n/**\r\n * `useAnimationGroupSubscription` allows a component to subscribe to an\r\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\r\n *\r\n * @param animation\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useAnimationGroupSubscription(animation, controls) {\r\n    var unsubscribe = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () { return animation.subscribe(controls); }, [\r\n        animation,\r\n    ]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () { return function () {\r\n        unsubscribe && unsubscribe();\r\n    }; }, [unsubscribe]);\r\n}\n\nvar _a$1, _b;\r\nvar AnimatePropComponents = (_a$1 = {},\r\n    _a$1[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls, values = _a.values, transition = _a.transition;\r\n        return useAnimateProp(animate, controls, values, transition);\r\n    }),\r\n    _a$1[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\r\n        return useVariants(initial, animate, inherit, controls);\r\n    }),\r\n    _a$1[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls;\r\n        return useAnimationGroupSubscription(animate, controls);\r\n    }),\r\n    _a$1);\r\nvar isVariantLabel$1 = function (prop) {\r\n    return Array.isArray(prop) || typeof prop === \"string\";\r\n};\r\nvar isAnimationSubscription = function (_a) {\r\n    var animate = _a.animate;\r\n    return animate instanceof AnimationControls;\r\n};\r\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\r\nvar animatePropTypeTests = (_b = {},\r\n    _b[AnimatePropType.Target] = function (props) {\r\n        return (props.animate !== undefined &&\r\n            !isVariantLabel$1(props.animate) &&\r\n            !isAnimationSubscription(props));\r\n    },\r\n    _b[AnimatePropType.VariantLabel] = function (props) {\r\n        return (props.variants !== undefined ||\r\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\r\n    },\r\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\r\n    _b);\r\nvar getAnimationComponent = function (props) {\r\n    var animatePropType = undefined;\r\n    for (var key in AnimatePropType) {\r\n        if (animatePropTypeTests[key](props)) {\r\n            animatePropType = key;\r\n        }\r\n    }\r\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\r\n};\n\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence() {\r\n    var context = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(PresenceContext);\r\n    if (context === null)\r\n        return [true];\r\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(register, []);\r\n    return !isPresent && onExitComplete ? [false, onExitComplete] : [true];\r\n}\n\nvar Exit = {\r\n    key: \"exit\",\r\n    shouldRender: function (props) { return !!props.exit && !checkShouldInheritVariant(props); },\r\n    Component: makeRenderlessComponent(function (props) {\r\n        var _a;\r\n        var animate = props.animate, controls = props.controls, exit = props.exit;\r\n        var _b = usePresence(), isPresent = _b[0], onExitComplete = _b[1];\r\n        var presenceContext = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(PresenceContext);\r\n        var isPlayingExitAnimation = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(false);\r\n        var custom = ((_a = presenceContext) === null || _a === void 0 ? void 0 : _a.custom) !== undefined\r\n            ? presenceContext.custom\r\n            : props.custom;\r\n        Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n            if (!isPresent) {\r\n                if (!isPlayingExitAnimation.current && exit) {\r\n                    controls.setProps(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props), { custom: custom }));\r\n                    controls.start(exit).then(onExitComplete);\r\n                }\r\n                isPlayingExitAnimation.current = true;\r\n            }\r\n            else if (isPlayingExitAnimation.current &&\r\n                animate &&\r\n                !(animate instanceof AnimationControls)) {\r\n                controls.start(animate);\r\n            }\r\n            if (isPresent) {\r\n                isPlayingExitAnimation.current = false;\r\n            }\r\n        }, [isPresent]);\r\n    }),\r\n};\n\nvar isPropValid = function (key) { return !isValidMotionProp(key); };\r\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\r\ntry {\r\n    var emotionIsPropValid_1 = __webpack_require__(/*! @emotion/is-prop-valid */ \"./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js\").default;\r\n    isPropValid = function (key) {\r\n        // Handle events explicitly as Emotion validates them all as true\r\n        if (key.startsWith(\"on\")) {\r\n            return !isValidMotionProp(key);\r\n        }\r\n        else {\r\n            return emotionIsPropValid_1(key);\r\n        }\r\n    };\r\n}\r\ncatch (_a) {\r\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\r\n}\r\nfunction filterValidProps(props) {\r\n    var domProps = {};\r\n    for (var key in props) {\r\n        if (isPropValid(key)) {\r\n            domProps[key] = props[key];\r\n        }\r\n    }\r\n    return domProps;\r\n}\r\nvar buildHTMLProps = function (values, style, isStatic, isDrag) {\r\n    // The `any` isn't ideal but it is the type of createElement props argument\r\n    var props = {\r\n        style: buildStyleAttr(values, style, isStatic),\r\n    };\r\n    if (isDrag) {\r\n        // Disable text selection\r\n        props.style.userSelect = \"none\";\r\n        // Disable the ghost element when a user drags\r\n        props.draggable = false;\r\n    }\r\n    return props;\r\n};\r\nvar buildSVGProps = function (values, style) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var props = Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"buildSVGAttrs\"])(motionValueStyles, undefined, undefined, undefined, undefined, false);\r\n    props.style = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, style), props.style);\r\n    return props;\r\n};\r\nvar functionalityComponents = [Layout, Drag, Gestures, Exit];\r\nvar numFunctionalityComponents = functionalityComponents.length;\r\n/**\r\n * Create a configuration for `motion` components that provides DOM-specific functionality.\r\n *\r\n * @internal\r\n */\r\nfunction createDomMotionConfig(Component) {\r\n    var isDOM = typeof Component === \"string\";\r\n    var isSVG = isDOM && svgElements.indexOf(Component) !== -1;\r\n    return {\r\n        renderComponent: function (ref, style, values, props, isStatic) {\r\n            var forwardedProps = isDOM ? filterValidProps(props) : props;\r\n            var staticVisualStyles = isSVG\r\n                ? buildSVGProps(values, style)\r\n                : buildHTMLProps(values, style, isStatic, !!props.drag);\r\n            return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Component, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, forwardedProps), { ref: ref }), staticVisualStyles));\r\n        },\r\n        /**\r\n         * loadFunctionalityComponents gets used by the `motion` component\r\n         *\r\n         * Each functionality component gets provided the `ref`, animation controls and the `MotionValuesMap`\r\n         * generated for that component, as well as all the `props` passed to it by the user.\r\n         *\r\n         * The pattern used to determine whether to load and use each piece of functionality is\r\n         * consistent (should render? Then push component) and could be used to extend functionality.\r\n         *\r\n         * By exposing a mutable piece of memory via an API like `extendMotionComponent` we could\r\n         * allow users to add `FunctionalComponentDefinition`s. This would allow us to offer file size\r\n         * reductions by shipping an entry point that doesn't load gesture and drag functionality, and\r\n         * also offer a way for users to develop plugins/other functionality. Because these functionalities\r\n         * are loaded as components, we can look into using Suspense for this purpose.\r\n         *\r\n         * For user-defined functionality we'd need to allow\r\n         *  1) User-defined prop typing (extending `P`)\r\n         *  2) User-defined \"clean props\" function that removes their plugin's props before being passed to the DOM.\r\n         */\r\n        loadFunctionalityComponents: function (ref, values, props, context, controls, inherit) {\r\n            var activeComponents = [];\r\n            // TODO: Consolidate Animation functionality loading strategy with other functionality components\r\n            var Animation = getAnimationComponent(props);\r\n            if (Animation) {\r\n                activeComponents.push(Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: inherit, values: values }));\r\n            }\r\n            for (var i = 0; i < numFunctionalityComponents; i++) {\r\n                var _a = functionalityComponents[i], shouldRender = _a.shouldRender, key = _a.key, Component_1 = _a.Component;\r\n                if (shouldRender(props, context)) {\r\n                    activeComponents.push(Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(Component_1, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ key: key }, props, { parentContext: context, values: values, controls: controls, innerRef: ref })));\r\n                }\r\n            }\r\n            return activeComponents;\r\n        },\r\n        getValueControlsConfig: function (ref, values) {\r\n            return {\r\n                values: values,\r\n                readValueFromSource: function (key) {\r\n                    return Object(stylefire__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ref.current).get(key);\r\n                },\r\n                // TODO: This is a good second source of plugins. This function contains the CSS variable\r\n                // and unit conversion support. These functions share a common signature. We could make another\r\n                // API for adding these.\r\n                makeTargetAnimatable: parseDomVariant(values, ref),\r\n            };\r\n        },\r\n    };\r\n}\n\nvar htmlMotionComponents = htmlElements.reduce(function (acc, Component) {\r\n    var config = createDomMotionConfig(Component);\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(config);\r\n    return acc;\r\n}, {});\r\nvar svgMotionComponents = svgElements.reduce(function (acc, Component) {\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(createDomMotionConfig(Component));\r\n    return acc;\r\n}, {});\r\n/**\r\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\r\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\r\n *\r\n * @internalremarks\r\n *\r\n * I'd like to make it possible for these to be loaded \"on demand\" - to reduce bundle size by only\r\n * including HTML/SVG stylers, animation and/or gesture support when necessary.\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ x: 100 }} />\r\n *\r\n * <motion.p animate={{ height: 200 }} />\r\n *\r\n * <svg><motion.circle r={10} animate={{ r: 20 }} /></svg>\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar motion = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ \r\n    /**\r\n     * Convert a custom React component into a `motion` component.\r\n     *\r\n     * It can also accept a string, to create [custom DOM elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).\r\n     *\r\n     * ```jsx\r\n     * const Component = React.forwardRef((props: Props, ref) => {\r\n     *   return <div ref={ref} />\r\n     * })\r\n     *\r\n     * const MotionComponent = motion.custom<Props>(Component)\r\n     * ```\r\n     *\r\n     * @param Component -\r\n     */\r\n    custom: function custom(Component) {\r\n        return createMotionComponent(createDomMotionConfig(Component));\r\n    } }, htmlMotionComponents), svgMotionComponents);\n\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    return useConstant(function () { return motionValue(initial); });\r\n}\n\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n *\r\n * @internal\r\n */\r\nfunction unwrapMotionValue(value) {\r\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\r\n    return isCustomValue(unwrappedValue)\r\n        ? unwrappedValue.toValue()\r\n        : unwrappedValue;\r\n}\n\nvar isCustomValueType = function (v) {\r\n    return typeof v === \"object\" && v.mix;\r\n};\r\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\r\nfunction transform() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var useImmediate = !Array.isArray(args[0]);\r\n    var argOffset = useImmediate ? 0 : -1;\r\n    var inputValue = args[0 + argOffset];\r\n    var inputRange = args[1 + argOffset];\r\n    var outputRange = args[2 + argOffset];\r\n    var options = args[3 + argOffset];\r\n    var interpolator = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__[\"interpolate\"])(inputRange, outputRange, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ mixer: getMixer(outputRange[0]) }, options));\r\n    return useImmediate ? interpolator(inputValue) : interpolator;\r\n}\n\nvar isTransformer = function (v) {\r\n    return typeof v === \"function\";\r\n};\r\nvar noop$1 = function (v) { return v; };\r\nfunction useTransform(parent, customTransform, to, options) {\r\n    var value = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    var comparitor = [parent];\r\n    var transformer = noop$1;\r\n    if (isTransformer(customTransform)) {\r\n        transformer = customTransform;\r\n    }\r\n    else if (Array.isArray(to)) {\r\n        var from = customTransform;\r\n        transformer = transform(from, to, options);\r\n        comparitor = [parent, from.join(\",\"), to.join(\",\")];\r\n    }\r\n    return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () {\r\n        if (value.current)\r\n            value.current.destroy();\r\n        value.current = parent.addChild({ transformer: transformer });\r\n        return value.current;\r\n    }, comparitor);\r\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\r\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\r\n// to simply hide content at unreasonable scales.\r\nvar maxScale = 100000;\r\nvar invertScale = function (scale) { return (scale > 0.001 ? 1 / scale : maxScale); };\r\n/**\r\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\r\n * of their respective parent scales.\r\n *\r\n * This is useful for undoing the distortion of content when scaling a parent component.\r\n *\r\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\r\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\r\n * of those instead.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = () => {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <motion.div style={{ scaleX, scaleY }} />\r\n * }\r\n * ```\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * function MyComponent() {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useInvertedScale(scale) {\r\n    var parentScaleX = useMotionValue(1);\r\n    var parentScaleY = useMotionValue(1);\r\n    var values = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext).values;\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(!!(scale || values), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\r\n    if (scale) {\r\n        parentScaleX = scale.scaleX || parentScaleX;\r\n        parentScaleY = scale.scaleY || parentScaleY;\r\n    }\r\n    else if (values) {\r\n        parentScaleX = values.get(\"scaleX\", 1);\r\n        parentScaleY = values.get(\"scaleY\", 1);\r\n    }\r\n    var scaleX = useTransform(parentScaleX, invertScale);\r\n    var scaleY = useTransform(parentScaleY, invertScale);\r\n    return { scaleX: scaleX, scaleY: scaleY };\r\n}\n\nfunction useOnChange(value, callback) {\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\r\n}\n\n/**\r\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\r\n *\r\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\r\n * to another `MotionValue`.\r\n *\r\n * @remarks\r\n *\r\n * ```jsx\r\n * const x = useSpring(0, { stiffness: 300 })\r\n * const y = useSpring(x, { damping: 10 })\r\n * ```\r\n *\r\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\r\n * @param springConfig - Configuration options for the spring.\r\n * @returns `MotionValue`\r\n *\r\n * @public\r\n */\r\nfunction useSpring(source, config) {\r\n    if (config === void 0) { config = {}; }\r\n    var activeSpringAnimation = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(null);\r\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () {\r\n        return value.attach(function (v, set) {\r\n            if (activeSpringAnimation.current) {\r\n                activeSpringAnimation.current.stop();\r\n            }\r\n            activeSpringAnimation.current = Object(popmotion__WEBPACK_IMPORTED_MODULE_7__[\"spring\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\r\n            return value.get();\r\n        });\r\n    }, Object.values(config));\r\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\r\n    return value;\r\n}\n\nfunction createScrollMotionValues() {\r\n    return {\r\n        scrollX: motionValue(0),\r\n        scrollY: motionValue(0),\r\n        scrollXProgress: motionValue(0),\r\n        scrollYProgress: motionValue(0),\r\n    };\r\n}\r\nfunction setProgress(offset, maxOffset, value) {\r\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\r\n}\r\nfunction createScrollUpdater(values, getOffsets) {\r\n    var update = function () {\r\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\r\n        // Set absolute positions\r\n        values.scrollX.set(xOffset);\r\n        values.scrollY.set(yOffset);\r\n        // Set 0-1 progress\r\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\r\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\r\n    };\r\n    update();\r\n    return update;\r\n}\n\nvar getElementScrollOffsets = function (element) { return function () {\r\n    return {\r\n        xOffset: element.scrollLeft,\r\n        yOffset: element.scrollTop,\r\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\r\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\r\n    };\r\n}; };\r\n/**\r\n * Returns MotionValues that update when the provided element scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useElementScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const ref = React.useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <Frame ref={ref}>\r\n *       <Frame scaleX={scrollYProgress} />\r\n *     </Frame>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const ref = useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <motion.div style={{ scaleX: scrollYProgress }} />\r\n *     </div>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useElementScroll(ref) {\r\n    var values = useConstant(createScrollMotionValues);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useLayoutEffect\"])(function () {\r\n        var element = ref.current;\r\n        Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\r\n        if (!element)\r\n            return;\r\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\r\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\r\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\r\n        return function () {\r\n            scrollListener && scrollListener();\r\n            resizeListener && resizeListener();\r\n        };\r\n    }, []);\r\n    return values;\r\n}\n\nvar viewportScrollValues = createScrollMotionValues();\r\nfunction getViewportScrollOffsets() {\r\n    return {\r\n        xOffset: window.pageXOffset,\r\n        yOffset: window.pageYOffset,\r\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\r\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\r\n    };\r\n}\r\nvar hasListeners = false;\r\nfunction addEventListeners() {\r\n    hasListeners = true;\r\n    if (typeof window === \"undefined\")\r\n        return;\r\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\r\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\r\n    addDomEvent(window, \"resize\", updateScrollValues);\r\n}\r\n/**\r\n * Returns MotionValues that update when the viewport scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useViewportScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <Frame scaleX={scrollYProgress} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useViewportScroll() {\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useLayoutEffect\"])(function () {\r\n        !hasListeners && addEventListeners();\r\n    }, []);\r\n    return viewportScrollValues;\r\n}\n\n/**\r\n * Creates `AnimationControls`, which can be used to manually start, stop\r\n * and sequence animations on one or more components.\r\n *\r\n * The returned `AnimationControls` should be passed to the `animate` property\r\n * of the components you want to animate.\r\n *\r\n * These components can then be animated with the `start` method.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { Frame, useAnimation } from 'framer'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <Frame animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { motion, useAnimation } from 'framer-motion'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <motion.div animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @returns Animation controller with `start` and `stop` methods\r\n *\r\n * @public\r\n */\r\nfunction useAnimation() {\r\n    var animationControls = useConstant(function () { return new AnimationControls(); });\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        animationControls.mount();\r\n        return function () { return animationControls.unmount(); };\r\n    }, []);\r\n    return animationControls;\r\n}\n\n/**\r\n * Experimental API.\r\n *\r\n * Makes an animated version of `useState`.\r\n *\r\n * @remarks\r\n *\r\n * When the returned state setter is called, values will be animated to their new target.\r\n *\r\n * This allows the animation of arbitrary React components.\r\n *\r\n * **Note:** When animating DOM components, it's always preferable to use the `animate` prop, as Framer\r\n * will bypass React's rendering cycle with one optimised for 60fps motion. This Hook is specifically\r\n * for animating props on arbitrary React components, or for animating text content.\r\n *\r\n * ```jsx\r\n * const [state, setState] = useAnimatedState({ percentage: 0 })\r\n *\r\n * return (\r\n *   <Graph\r\n *     percentage={state.percentage}\r\n *     onTap={() => setState({ percentage: 50 })}\r\n *   />\r\n * )\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * TODO:\r\n * - Make hook accept a typed version of Target that accepts any value (not just DOM values)\r\n * - Allow hook to accept single values. ie useAnimatedState(0)\r\n * - Allow providing MotionValues via initialState.\r\n *\r\n * @beta\r\n */\r\nfunction useAnimatedState(initialState) {\r\n    var _a = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(initialState), animationState = _a[0], onUpdate = _a[1];\r\n    var config = useConstant(function () { return ({ onUpdate: onUpdate }); });\r\n    var values = useMotionValues(config);\r\n    var controls = useValueAnimationControls({\r\n        values: values,\r\n        readValueFromSource: function (key) { return animationState[key]; },\r\n    }, {}, false);\r\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\r\n        return controls.start(animationDefinition);\r\n    }; });\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        values.mount();\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return [animationState, startAnimation];\r\n}\n\n/**\r\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { Frame, useCycle } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <Frame\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { motion, useCycle } from \"framer-motion\"\r\n *\r\n * export const MyComponent = () => {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <motion.div\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @param items - items to cycle through\r\n * @returns [currentState, cycleState]\r\n *\r\n * @public\r\n */\r\nfunction useCycle() {\r\n    var items = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        items[_i] = arguments[_i];\r\n    }\r\n    // TODO: After Framer X beta, remove this warning\r\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"warning\"])(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\r\n    var index = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(0);\r\n    var _a = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(items[index.current]), item = _a[0], setItem = _a[1];\r\n    return [\r\n        item,\r\n        function (next) {\r\n            index.current =\r\n                typeof next !== \"number\"\r\n                    ? Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_3__[\"wrap\"])(0, items.length, index.current + 1)\r\n                    : next;\r\n            setItem(items[index.current]);\r\n        },\r\n    ];\r\n}\n\n/**\r\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar DragControls = /** @class */ (function () {\r\n    function DragControls() {\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Subscribe a component's internal `ComponentDragControls` to the user-facing API.\r\n     *\r\n     * @internal\r\n     */\r\n    DragControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Start a drag gesture on every `motion` component that has this set of drag controls\r\n     * passed into it via the `dragControls` prop.\r\n     *\r\n     * ```jsx\r\n     * dragControls.start(e, {\r\n     *   snapToCursor: true\r\n     * })\r\n     * ```\r\n     *\r\n     * @param event - A mouse/touch/pointer event.\r\n     * @param options - Options\r\n     *\r\n     * @public\r\n     */\r\n    DragControls.prototype.start = function (event, options) {\r\n        this.componentControls.forEach(function (controls) {\r\n            controls.start(event.nativeEvent || event, options);\r\n        });\r\n    };\r\n    return DragControls;\r\n}());\r\nvar createDragControls = function () { return new DragControls(); };\r\n/**\r\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\r\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\r\n * might want to initiate that dragging from a different component than the draggable one.\r\n *\r\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\r\n * the draggable component's `dragControls` prop. It exposes a `start` method\r\n * that can start dragging from pointer events on other components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useDragControls() {\r\n    return useConstant(createDragControls);\r\n}\n\nvar PresenceChild = function (_a) {\r\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom;\r\n    var numPresenceChildren = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(0);\r\n    var numExitComplete = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(0);\r\n    var context = {\r\n        initial: initial,\r\n        isPresent: isPresent,\r\n        custom: custom,\r\n        onExitComplete: function () {\r\n            numExitComplete.current++;\r\n            var allComplete = numExitComplete.current >= numPresenceChildren.current;\r\n            onExitComplete && allComplete && onExitComplete();\r\n        },\r\n    };\r\n    var register = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () {\r\n        numExitComplete.current = 0;\r\n        return function () {\r\n            numPresenceChildren.current++;\r\n            return function () { return numPresenceChildren.current--; };\r\n        };\r\n    }, [isPresent]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(PresenceContext.Provider, { value: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, context), { register: register }) }, children));\r\n};\n\nfunction getChildKey(child) {\r\n    return child.key || \"\";\r\n}\r\nfunction updateChildLookup(children, allChildren) {\r\n    var seenChildren =  true ? new Set() : undefined;\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        if ( true && seenChildren) {\r\n            if (seenChildren.has(key)) {\r\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\r\n            }\r\n            seenChildren.add(key);\r\n        }\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    react__WEBPACK_IMPORTED_MODULE_1__[\"Children\"].forEach(children, function (child) {\r\n        if (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"isValidElement\"])(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceUpdate function, or one from a parent context if it exists.\r\n    var localForceUpdate = useForceUpdate();\r\n    var contextForceUpdate = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(SyncLayoutContext);\r\n    var forceUpdate = contextForceUpdate || localForceUpdate;\r\n    var isInitialRender = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(true);\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(filteredChildren);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(new Map())\r\n        .current;\r\n    // A living record of all currently exiting components.\r\n    var exiting = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(new Set()).current;\r\n    updateChildLookup(filteredChildren, allChildren);\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    if (isInitialRender.current) {\r\n        isInitialRender.current = false;\r\n        return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, filteredChildren.map(function (child) { return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    var childrenToRender = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(filteredChildren);\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n        else {\r\n            // In case this key has re-entered, remove from the exiting list\r\n            exiting.delete(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (child) { return child.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                forceUpdate();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(PresenceChild, { key: getChildKey(child), isPresent: true }, child));\r\n    });\r\n    presentChildren.current = childrenToRender;\r\n    if ( true &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_1__[\"Fragment\"], null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return Object(react__WEBPACK_IMPORTED_MODULE_1__[\"cloneElement\"])(child); })));\r\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\r\nvar prefersReducedMotion = motionValue(null);\r\nif (typeof window !== \"undefined\") {\r\n    if (window.matchMedia) {\r\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        var setReducedMotionPreferences = function () {\r\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\r\n        };\r\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.set(false);\r\n    }\r\n}\r\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\r\n    return typeof isReducedMotion === \"boolean\"\r\n        ? isReducedMotion\r\n        : Boolean(prefersReduced);\r\n}\n\n/**\r\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\r\n *\r\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\r\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\r\n *\r\n * It will actively respond to changes and re-render your components with the latest setting.\r\n *\r\n * ```jsx\r\n * export function Sidebar({ isOpen }) {\r\n *   const shouldReduceMotion = useReducedMotion()\r\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\r\n *\r\n *   return (\r\n *     <motion.div animate={{\r\n *       opacity: isOpen ? 1 : 0,\r\n *       x: isOpen ? 0 : closedX\r\n *     }} />\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @return boolean\r\n *\r\n * @public\r\n */\r\nfunction useReducedMotion() {\r\n    var isReducedMotion = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext).isReducedMotion;\r\n    var _a = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\r\n    Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\r\n        return prefersReducedMotion.onChange(function (v) {\r\n            setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\r\n        });\r\n    }, [setShouldReduceMotion, isReducedMotion]);\r\n    return shouldReduceMotion;\r\n}\n\n/**\r\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\r\n * or disable device detection.\r\n *\r\n * @internal\r\n */\r\nfunction ReducedMotion(_a) {\r\n    var children = _a.children, enabled = _a.enabled;\r\n    var context = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(MotionContext);\r\n    context = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useMemo\"])(function () { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, context), { isReducedMotion: enabled })); }, [enabled]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"])(MotionContext.Provider, { value: context }, children));\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9mcmFtZXItbW90aW9uLmVzLmpzPzY0YzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9FO0FBQ2dKO0FBQ3pKO0FBQzhCO0FBQ21DO0FBQzVFO0FBQ3lDO0FBQ0c7QUFDMUM7QUFDTTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsaURBQUksaUNBQWlDO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDLEVBQUU7QUFDckYsS0FBSztBQUNMO0FBQ0EsNENBQTRDLG9EQUFNO0FBQ2xEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxYUFBcWEsb0RBQU07QUFDM2EscUJBQXFCLHNEQUFRLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFVO0FBQ3BDLGFBQWEsc0RBQVE7QUFDckIsSUFBSSx1REFBUztBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBVTtBQUM1QixjQUFjLHFEQUFPLGNBQWMsU0FBUyxzREFBUSxDQUFDLHNEQUFRLEdBQUcsYUFBYSwyQkFBMkIsR0FBRyxFQUFFO0FBQzdHLFlBQVksMkRBQWEsMEJBQTBCLGlCQUFpQjtBQUNwRTs7QUFFd2hCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9mcmFtZXItbW90aW9uLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXlzLCBfX3Jlc3QsIF9fZXh0ZW5kcyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZVJlZiwgbWVtbywgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlLCBDb21wb25lbnQsIHVzZUxheW91dEVmZmVjdCwgY2xvbmVFbGVtZW50LCBDaGlsZHJlbiwgaXNWYWxpZEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3luYywgeyBnZXRGcmFtZURhdGEsIGNhbmNlbFN5bmMgfSBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQsIGRpc3RhbmNlLCBtaXgsIGludGVycG9sYXRlLCB3cmFwIH0gZnJvbSAnQHBvcG1vdGlvbi9wb3Bjb3JuJztcbmltcG9ydCBzdHlsZXIsIHsgY3JlYXRlU3R5bGVyRmFjdG9yeSwgYnVpbGRTdHlsZVByb3BlcnR5LCBpc1RyYW5zZm9ybVByb3AsIHRyYW5zZm9ybVByb3BzLCBidWlsZFNWR0F0dHJzIH0gZnJvbSAnc3R5bGVmaXJlJztcbmltcG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgY29sb3IsIGNvbXBsZXgsIG51bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IGFjdGlvbiwgZGVsYXksIHR3ZWVuLCBzcHJpbmcsIGtleWZyYW1lcyBhcyBrZXlmcmFtZXMkMSwgaW5lcnRpYSB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgKiBhcyBlYXNpbmdMb29rdXAgZnJvbSAnQHBvcG1vdGlvbi9lYXNpbmcnO1xuaW1wb3J0IHsgY3ViaWNCZXppZXIsIGxpbmVhciB9IGZyb20gJ0Bwb3Btb3Rpb24vZWFzaW5nJztcblxudmFyIGlzRmxvYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG59O1xyXG4vKipcclxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIE1vdGlvblZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE1vdGlvblZhbHVlKGluaXQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHJhbnNmb3JtZXIgPSBfYi50cmFuc2Zvcm1lciwgcGFyZW50ID0gX2IucGFyZW50O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIER1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHMsIHNpbmNlIGxhc3QgdXBkYXRpbmcgZnJhbWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGltZXN0YW1wIG9mIHRoZSBsYXN0IHRpbWUgdGhpcyBgTW90aW9uVmFsdWVgIHdhcyB1cGRhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgdGhpcyB2YWx1ZSBjYW4gb3V0cHV0IGEgdmVsb2NpdHkuIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdHJ1ZVxyXG4gICAgICAgICAqIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljYWwsIGJ1dCB3ZSBtaWdodCBiZSBhYmxlIHRvIHdpZGVuIHRoZSBzY29wZSBoZXJlIGFuZCBzdXBwb3J0XHJcbiAgICAgICAgICogb3RoZXIgdmFsdWUgdHlwZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9IGZ1bmN0aW9uICh2LCByZW5kZXIpIHtcclxuICAgICAgICAgICAgaWYgKHJlbmRlciA9PT0gdm9pZCAwKSB7IHJlbmRlciA9IHRydWU7IH1cclxuICAgICAgICAgICAgX3RoaXMucHJldiA9IF90aGlzLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnQgPSBfdGhpcy50cmFuc2Zvcm1lciA/IF90aGlzLnRyYW5zZm9ybWVyKHYpIDogdjtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnVwZGF0ZVN1YnNjcmliZXJzICYmIF90aGlzLnByZXYgIT09IF90aGlzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmZvckVhY2goX3RoaXMubm90aWZ5U3Vic2NyaWJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGlsZHJlbi5mb3JFYWNoKF90aGlzLnNldENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVuZGVyICYmIF90aGlzLnJlbmRlclN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5mb3JFYWNoKF90aGlzLm5vdGlmeVN1YnNjcmliZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aW1lc3RhbXBcclxuICAgICAgICAgICAgdmFyIF9hID0gZ2V0RnJhbWVEYXRhKCksIGRlbHRhID0gX2EuZGVsdGEsIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RVcGRhdGVkICE9PSB0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVEZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFVwZGF0ZWQgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICBzeW5jLnBvc3RSZW5kZXIoX3RoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm90aWZ5IGEgc3Vic2NyaWJlciB3aXRoIHRoZSBsYXRlc3QgdmFsdWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGFuIGluc3RhbmNlZCBhbmQgYm91bmQgZnVuY3Rpb24gdG8gcHJldmVudCBnZW5lcmF0aW5nIGEgbmV3XHJcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIFRoZSBzdWJzY3JpYmVyIHRvIG5vdGlmeS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlciA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XHJcbiAgICAgICAgICAgIHN1YnNjcmliZXIoX3RoaXMuY3VycmVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2hlZHVsZSBhIHZlbG9jaXR5IGNoZWNrIGZvciB0aGUgbmV4dCBmcmFtZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcclxuICAgICAgICAgKiBmdW5jdGlvbiBvbmNlIHBlciBmcmFtZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luYy5wb3N0UmVuZGVyKF90aGlzLnZlbG9jaXR5Q2hlY2spOyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYHByZXZgIHdpdGggYGN1cnJlbnRgIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgYmVlbiB1cGRhdGVkIHRoaXMgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyBlbnN1cmVzIHZlbG9jaXR5IGNhbGN1bGF0aW9ucyByZXR1cm4gYDBgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhbiBpbnN0YW5jZWQgYW5kIGJvdW5kIGZ1bmN0aW9uIHRvIHByZXZlbnQgZ2VuZXJhdGluZyBhIG5ld1xyXG4gICAgICAgICAqIGZ1bmN0aW9uIG9uY2UgcGVyIGZyYW1lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eUNoZWNrID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBfYS50aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgIT09IF90aGlzLmxhc3RVcGRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBjaGlsZCBgTW90aW9uVmFsdWVgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNoaWxkIC0gQ2hpbGQgYE1vdGlvblZhbHVlYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2V0Q2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnNldChfdGhpcy5jdXJyZW50KTsgfTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbiAgICAgICAgdGhpcy5zZXQoaW5pdCwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgTW90aW9uVmFsdWVgIHRoYXQncyBzdWJzY3JpYmVkIHRvIHRoZSBvdXRwdXQgb2YgdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIC0gIGB0cmFuc2Zvcm1lcmA6IEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGluY29taW5nIHZhbHVlcyB3aXRoLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IE1vdGlvblZhbHVlKHRoaXMuY3VycmVudCwgX19hc3NpZ24oeyBwYXJlbnQ6IHRoaXMgfSwgY29uZmlnKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKGNoaWxkKTtcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhIGBNb3Rpb25WYWx1ZWAgZnJvbSBiZWluZyBzdWJzY3JpYmVkIHRvIHRoaXMgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGlsZCAtIFRoZSBzdWJzY3JpYmVkIGBNb3Rpb25WYWx1ZWBcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBhIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYSBzdWJzY3JpcHRpb24gbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9ucyAtIEEgYFNldGAgb2Ygc3Vic2NyaWJlcnMuXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIC0gQSBzdWJzY3JpYmVyIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuc3Vic2NyaWJlVG8gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9ucywgc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdXBkYXRlU3Vic2NyaWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbihfdGhpcy5jdXJyZW50KTsgfTtcclxuICAgICAgICBzdWJzY3JpcHRpb25zLmFkZCh1cGRhdGVTdWJzY3JpYmVyKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaXB0aW9ucy5kZWxldGUodXBkYXRlU3Vic2NyaWJlcik7IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgaXMgdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBjYWxsaW5nIGBvbkNoYW5nZWAgaW5zaWRlIGEgUmVhY3QgY29tcG9uZW50LCBpdCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHRoZVxyXG4gICAgICogYHVzZUVmZmVjdGAgaG9vay4gQXMgaXQgcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWRcclxuICAgICAqIGZyb20gdGhlIGB1c2VFZmZlY3RgIGZ1bmN0aW9uIHRvIGVuc3VyZSB5b3UgZG9uJ3QgYWRkIGR1cGxpY2F0ZSBzdWJzY3JpYmVycy4uXHJcbiAgICAgKlxyXG4gICAgICogQGxpYnJhcnlcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc3hcclxuICAgICAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xyXG4gICAgICogICBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcclxuICAgICAqICAgY29uc3QgeSA9IHVzZU1vdGlvblZhbHVlKDApXHJcbiAgICAgKiAgIGNvbnN0IG9wYWNpdHkgPSB1c2VNb3Rpb25WYWx1ZSgxKVxyXG4gICAgICpcclxuICAgICAqICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAqICAgICBmdW5jdGlvbiB1cGRhdGVPcGFjaXR5KCkge1xyXG4gICAgICogICAgICAgY29uc3QgbWF4WFkgPSBNYXRoLm1heCh4LmdldCgpLCB5LmdldCgpKVxyXG4gICAgICogICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IHRyYW5zZm9ybShtYXhYWSwgWzAsIDEwMF0sIFsxLCAwXSlcclxuICAgICAqICAgICAgIG9wYWNpdHkuc2V0KG5ld09wYWNpdHkpXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVggPSB4Lm9uQ2hhbmdlKHVwZGF0ZU9wYWNpdHkpXHJcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVZID0geS5vbkNoYW5nZSh1cGRhdGVPcGFjaXR5KVxyXG4gICAgICpcclxuICAgICAqICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICogICAgICAgdW5zdWJzY3JpYmVYKClcclxuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWSgpXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9LCBbXSlcclxuICAgICAqXHJcbiAgICAgKiAgIHJldHVybiA8RnJhbWUgeD17eH0gLz5cclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBtb3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc3hcclxuICAgICAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcclxuICAgICAqICAgY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXHJcbiAgICAgKiAgIGNvbnN0IHkgPSB1c2VNb3Rpb25WYWx1ZSgwKVxyXG4gICAgICogICBjb25zdCBvcGFjaXR5ID0gdXNlTW90aW9uVmFsdWUoMSlcclxuICAgICAqXHJcbiAgICAgKiAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBkYXRlT3BhY2l0eSgpIHtcclxuICAgICAqICAgICAgIGNvbnN0IG1heFhZID0gTWF0aC5tYXgoeC5nZXQoKSwgeS5nZXQoKSlcclxuICAgICAqICAgICAgIGNvbnN0IG5ld09wYWNpdHkgPSB0cmFuc2Zvcm0obWF4WFksIFswLCAxMDBdLCBbMSwgMF0pXHJcbiAgICAgKiAgICAgICBvcGFjaXR5LnNldChuZXdPcGFjaXR5KVxyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVYID0geC5vbkNoYW5nZSh1cGRhdGVPcGFjaXR5KVxyXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWSA9IHkub25DaGFuZ2UodXBkYXRlT3BhY2l0eSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWCgpXHJcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVkoKVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfSwgW10pXHJcbiAgICAgKlxyXG4gICAgICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgeCB9fSAvPlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFscmVtYXJrc1xyXG4gICAgICpcclxuICAgICAqIFdlIGNvdWxkIGxvb2sgaW50byBhIGB1c2VPbkNoYW5nZWAgaG9vayBpZiB0aGUgYWJvdmUgbGlmZWN5Y2xlIG1hbmFnZW1lbnQgcHJvdmVzIGNvbmZ1c2luZy5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc3hcclxuICAgICAqIHVzZU9uQ2hhbmdlKHgsICgpID0+IHt9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy51cGRhdGVTdWJzY3JpYmVycylcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVUbyh0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLCBzdWJzY3JpcHRpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIHJlcXVlc3RzIGEgcmVuZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gQSBmdW5jdGlvbiB0aGF0J3MgcHJvdmlkZWQgdGhlIGxhdGVzdCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUub25SZW5kZXJSZXF1ZXN0ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJTdWJzY3JpYmVycylcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAvLyBSZW5kZXIgaW1tZWRpYXRlbHlcclxuICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVUbyh0aGlzLnJlbmRlclN1YnNjcmliZXJzLCBzdWJzY3JpcHRpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgYSBwYXNzaXZlIGVmZmVjdCB0byB0aGUgYE1vdGlvblZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwYXNzaXZlRWZmZWN0KSB7XHJcbiAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0ID0gcGFzc2l2ZUVmZmVjdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKlxyXG4gICAgICogYGBganN4XHJcbiAgICAgKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcclxuICAgICAqIHguc2V0KDEwKVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdGVzdCAtIExhdGVzdCB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0gcmVuZGVyIC0gV2hldGhlciB0byBub3RpZnkgcmVuZGVyIHN1YnNjcmliZXJzLiBEZWZhdWx0cyB0byBgdHJ1ZWBcclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgcmVuZGVyKSB7XHJcbiAgICAgICAgaWYgKHJlbmRlciA9PT0gdm9pZCAwKSB7IHJlbmRlciA9IHRydWU7IH1cclxuICAgICAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWAuIFJldHVybnMgYDBgIGlmIHRoZSBzdGF0ZSBpcyBub24tbnVtZXJpY2FsLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgaXNGbG9hdCh0aGlzLnByZXYpICYmIGlzRmxvYXQodGhpcy5jdXJyZW50KSwgYnV0IHRoYXQgd291bGQgYmUgd2FzdGVmdWxcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5UcmFja1ZlbG9jaXR5XHJcbiAgICAgICAgICAgID8gLy8gVGhlc2UgY2FzdHMgY291bGQgYmUgYXZvaWRlZCBpZiBwYXJzZUZsb2F0IHdvdWxkIGJlIHR5cGVkIGJldHRlclxyXG4gICAgICAgICAgICAgICAgdmVsb2NpdHlQZXJTZWNvbmQocGFyc2VGbG9hdCh0aGlzLmN1cnJlbnQpIC1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKVxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYW5pbWF0aW9uIHRvIGNvbnRyb2wgdGhpcyBgTW90aW9uVmFsdWVgLiBPbmx5IG9uZVxyXG4gICAgICogYW5pbWF0aW9uIGNhbiBkcml2ZSBhIGBNb3Rpb25WYWx1ZWAgYXQgb25lIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogYGBganN4XHJcbiAgICAgKiB2YWx1ZS5zdGFydCgpXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHN0YXJ0cyB0aGUgcHJvdmlkZWQgYW5pbWF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zdG9wQW5pbWF0aW9uID0gYW5pbWF0aW9uKHJlc29sdmUpO1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xlYXJBbmltYXRpb24oKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBjdXJyZW50bHkgYWN0aXZlIGFuaW1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0b3BBbmltYXRpb24pXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5pc0FuaW1hdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnN0b3BBbmltYXRpb247XHJcbiAgICB9O1xyXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmNsZWFyQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IGFuZCBjbGVhbiB1cCBzdWJzY3JpYmVycyB0byB0aGlzIGBNb3Rpb25WYWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBNb3Rpb25WYWx1ZWAgaG9va3MgbGlrZSBgdXNlTW90aW9uVmFsdWVgIGFuZCBgdXNlVHJhbnNmb3JtYCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiBoYW5kbGUgdGhlIGxpZmVjeWNsZSBvZiB0aGUgcmV0dXJuZWQgYE1vdGlvblZhbHVlYCwgc28gdGhpcyBtZXRob2QgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91J3ZlIG1hbnVhbGx5XHJcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzICYmIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclN1YnNjcmliZXJzICYmIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW90aW9uVmFsdWU7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQsIG9wdHMpIHtcclxuICAgIHJldHVybiBuZXcgTW90aW9uVmFsdWUoaW5pdCwgb3B0cyk7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSBvdmVyIHRoZSBsaWZlY3ljbGUgb2YgYSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEV2ZW4gaWYgYHVzZU1lbW9gIGlzIHByb3ZpZGVkIGFuIGVtcHR5IGFycmF5IGFzIGl0cyBmaW5hbCBhcmd1bWVudCwgaXQgZG9lc24ndCBvZmZlclxyXG4gKiBhIGd1YXJhbnRlZSB0aGF0IGl0IHdvbid0IHJlLXJ1biBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBsYXRlciBvbi4gQnkgdXNpbmcgYHVzZUNvbnN0YW50YFxyXG4gKiB5b3UgY2FuIGVuc3VyZSB0aGF0IGluaXRpYWxpc2VycyBkb24ndCBleGVjdXRlIHR3aWNlIG9yIG1vcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XHJcbiAgICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XHJcbn1cblxudmFyIGlzTW90aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1vdGlvblZhbHVlO1xyXG59O1xuXG4vLyBDcmVhdGluZyBhIHN0eWxlciBmYWN0b3J5IGZvciB0aGUgYG9uVXBkYXRlYCBwcm9wIGFsbG93cyBhbGwgdmFsdWVzXHJcbi8vIHRvIGZpcmUgYW5kIHRoZSBgb25VcGRhdGVgIHByb3Agd2lsbCBvbmx5IGZpcmUgb25jZSBwZXIgZnJhbWVcclxudmFyIHVwZGF0ZVN0eWxlciA9IGNyZWF0ZVN0eWxlckZhY3Rvcnkoe1xyXG4gICAgb25SZWFkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcclxuICAgICAgICB2YXIgb25VcGRhdGUgPSBfYS5vblVwZGF0ZTtcclxuICAgICAgICByZXR1cm4gb25VcGRhdGUoc3RhdGUpO1xyXG4gICAgfSxcclxufSk7XHJcbnZhciBNb3Rpb25WYWx1ZXNNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb3Rpb25WYWx1ZXNNYXAoKSB7XHJcbiAgICAgICAgdGhpcy5oYXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgTW90aW9uVmFsdWVzTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmhhcyhrZXkpO1xyXG4gICAgfTtcclxuICAgIE1vdGlvblZhbHVlc01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTW91bnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRWYWx1ZVRvT3V0cHV0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3Rpb25WYWx1ZXNNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgTW90aW9uVmFsdWVzTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIE1vdGlvblZhbHVlc01hcC5wcm90b3R5cGUuYmluZFZhbHVlVG9PdXRwdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uUmVuZGVyID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLm91dHB1dCAmJiBfdGhpcy5vdXRwdXQoa2V5LCB2KTsgfTtcclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmVPblJlbmRlciA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdChvblJlbmRlcik7XHJcbiAgICAgICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgX3RoaXMub25VcGRhdGUgJiYgX3RoaXMub25VcGRhdGUuc2V0KGtleSwgdik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmVPbkNoYW5nZSA9IHZhbHVlLm9uQ2hhbmdlKG9uQ2hhbmdlKTtcclxuICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZXJzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVycy5nZXQoa2V5KSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcnMuc2V0KGtleSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB1bnN1YnNjcmliZU9uUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlT25DaGFuZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb3Rpb25WYWx1ZXNNYXAucHJvdG90eXBlLnNldE9uVXBkYXRlID0gZnVuY3Rpb24gKG9uVXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAob25VcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZSA9IHVwZGF0ZVN0eWxlcih7IG9uVXBkYXRlOiBvblVwZGF0ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW90aW9uVmFsdWVzTWFwLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm1UZW1wbGF0ZSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybVRlbXBsYXRlICE9PSB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVRlbXBsYXRlID0gdHJhbnNmb3JtVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtVGVtcGxhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW90aW9uVmFsdWVzTWFwLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1UZW1wbGF0ZTtcclxuICAgIH07XHJcbiAgICBNb3Rpb25WYWx1ZXNNYXAucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybVRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dChcInRyYW5zZm9ybVwiLCB0aGlzLnRyYW5zZm9ybVRlbXBsYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW90aW9uVmFsdWVzTWFwLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGFzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKG91dHB1dClcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gX3RoaXMuYmluZFZhbHVlVG9PdXRwdXQoa2V5LCB2YWx1ZSk7IH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtVGVtcGxhdGUoKTtcclxuICAgIH07XHJcbiAgICBNb3Rpb25WYWx1ZXNNYXAucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBfdGhpcy51bnN1YnNjcmliZXJzLmdldChrZXkpO1xyXG4gICAgICAgICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb3Rpb25WYWx1ZXNNYXA7XHJcbn0oKSk7XHJcbnZhciBzcGVjaWFsTW90aW9uVmFsdWVQcm9wcyA9IG5ldyBTZXQoW1wiZHJhZ09yaWdpblhcIiwgXCJkcmFnT3JpZ2luWVwiXSk7XHJcbnZhciB1c2VNb3Rpb25WYWx1ZXMgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBtb3Rpb25WYWx1ZXMgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNb3Rpb25WYWx1ZXNNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb29wIHRocm91Z2ggZXZlcnkgcHJvcCBhbmQgYWRkIGFueSBkZXRlY3RlZCBgTW90aW9uVmFsdWVgcy4gVGhpcyBpcyBTVkctc3BlY2lmaWNcclxuICAgICAgICAgKiBjb2RlIHRoYXQgc2hvdWxkIGJlIGV4dHJhY3RlZCwgcGVyaGFwcyBjb25zaWRlcmVkIGhvbGxpc3RpY2FsbHkgd2l0aCBgdXNlTW90aW9uU3R5bGVzYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDxtb3Rpb24uY2lyY2xlIGN4PXttb3Rpb25WYWx1ZSgwKX0gLz5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUocHJvcHNba2V5XSkgJiZcclxuICAgICAgICAgICAgICAgICFzcGVjaWFsTW90aW9uVmFsdWVQcm9wcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIHByb3BzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9KTtcclxuICAgIG1vdGlvblZhbHVlcy5zZXRPblVwZGF0ZShwcm9wcy5vblVwZGF0ZSk7XHJcbiAgICBtb3Rpb25WYWx1ZXMuc2V0VHJhbnNmb3JtVGVtcGxhdGUocHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xyXG4gICAgcmV0dXJuIG1vdGlvblZhbHVlcztcclxufTtcblxudmFyIHNlc3Npb24gPSBudWxsO1xyXG52YXIgc3luY1JlbmRlclNlc3Npb24gPSB7XHJcbiAgICBpc09wZW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlc3Npb24gIT09IG51bGw7IH0sXHJcbiAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaW52YXJpYW50KCFzZXNzaW9uLCBcIlN5bmMgcmVuZGVyIHNlc3Npb24gYWxyZWFkeSBvcGVuXCIpO1xyXG4gICAgICAgIHNlc3Npb24gPSBbXTtcclxuICAgIH0sXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGludmFyaWFudChzZXNzaW9uICE9PSBudWxsLCBcIk5vIHN5bmMgcmVuZGVyIHNlc3Npb24gZm91bmRcIik7XHJcbiAgICAgICAgc2Vzc2lvbiAmJiBzZXNzaW9uLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlcikgeyByZXR1cm4gc3R5bGVyLnJlbmRlcigpOyB9KTtcclxuICAgICAgICBzZXNzaW9uID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBwdXNoOiBmdW5jdGlvbiAoc3R5bGVyKSB7XHJcbiAgICAgICAgaW52YXJpYW50KHNlc3Npb24gIT09IG51bGwsIFwiTm8gc3luYyByZW5kZXIgc2Vzc2lvbiBmb3VuZFwiKTtcclxuICAgICAgICBzZXNzaW9uICYmIHNlc3Npb24ucHVzaChzdHlsZXIpO1xyXG4gICAgfSxcclxufTtcblxuLyoqXHJcbiAqIGB1c2VFZmZlY3RgIGdldHMgcmVzb2x2ZWQgYm90dG9tLXVwLiBXZSBkZWZlciBzb21lIG9wdGlvbmFsIGZ1bmN0aW9uYWxpdHkgdG8gY2hpbGRcclxuICogY29tcG9uZW50cywgc28gdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcnVucyBjb3JyZWN0bHkgd2UgZXhwb3J0IHRoZSByZWYtYmluZGluZyBsb2dpY1xyXG4gKiB0byBhIG5ldyBjb21wb25lbnQgcmF0aGVyIHRoYW4gaW4gYHVzZU1vdGlvblZhbHVlc2AuXHJcbiAqL1xyXG52YXIgTW91bnRDb21wb25lbnQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByZWYgPSBfYS5pbm5lclJlZiwgdmFsdWVzID0gX2EudmFsdWVzLCBpc1N0YXRpYyA9IF9hLmlzU3RhdGljO1xyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpbnZhcmlhbnQocmVmLmN1cnJlbnQgaW5zdGFuY2VvZiBFbGVtZW50LCBcIk5vIGByZWZgIGZvdW5kLiBFbnN1cmUgY29tcG9uZW50cyBjcmVhdGVkIHdpdGggYG1vdGlvbi5jdXN0b21gIGZvcndhcmQgcmVmcyB1c2luZyBgUmVhY3QuZm9yd2FyZFJlZmBcIik7XHJcbiAgICAgICAgdmFyIGRvbVN0eWxlciA9IHN0eWxlcihyZWYuY3VycmVudCwge1xyXG4gICAgICAgICAgICBwcmVwYXJzZU91dHB1dDogZmFsc2UsXHJcbiAgICAgICAgICAgIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiAhaXNTdGF0aWMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFsdWVzLm1vdW50KGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvbVN0eWxlci5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChzeW5jUmVuZGVyU2Vzc2lvbi5pc09wZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1JlbmRlclNlc3Npb24ucHVzaChkb21TdHlsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlcy51bm1vdW50KCk7IH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxudmFyIE1vdW50ID0gbWVtbyhNb3VudENvbXBvbmVudCk7XG5cbnZhciBjcmVhdGVWYWx1ZVJlc29sdmVyID0gZnVuY3Rpb24gKHJlc29sdmVyKSB7IHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YXIgcmVzb2x2ZWRWYWx1ZXMgPSB7fTtcclxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiAocmVzb2x2ZWRWYWx1ZXNba2V5XSA9IHJlc29sdmVyKHZhbHVlKSk7IH0pO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkVmFsdWVzO1xyXG59OyB9O1xyXG52YXIgcmVzb2x2ZUN1cnJlbnQgPSBjcmVhdGVWYWx1ZVJlc29sdmVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUuZ2V0KCk7IH0pO1xuXG52YXIgdHJhbnNmb3JtT3JpZ2luUHJvcHMgPSBuZXcgU2V0KFtcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwib3JpZ2luWlwiXSk7XHJcbnZhciBpc1RyYW5zZm9ybU9yaWdpblByb3AgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0cmFuc2Zvcm1PcmlnaW5Qcm9wcy5oYXMoa2V5KTsgfTtcclxudmFyIGJ1aWxkU3R5bGVBdHRyID0gZnVuY3Rpb24gKHZhbHVlcywgc3R5bGVQcm9wLCBpc1N0YXRpYykge1xyXG4gICAgdmFyIG1vdGlvblZhbHVlU3R5bGVzID0gcmVzb2x2ZUN1cnJlbnQodmFsdWVzKTtcclxuICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHZhbHVlcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpO1xyXG4gICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XHJcbiAgICAgICAgLy8gSWYgYHRyYW5zZm9ybWAgaGFzIGJlZW4gbWFudWFsbHkgc2V0IGFzIGEgc3RyaW5nLCBwYXNzIHRoYXQgdGhyb3VnaCB0aGUgdGVtcGxhdGVcclxuICAgICAgICAvLyBvdGhlcndpc2UgcGFzcyBpdCBmb3J3YXJkIHRvIFN0eWxlZmlyZSdzIHN0eWxlIHByb3BlcnR5IGJ1aWxkZXJcclxuICAgICAgICBtb3Rpb25WYWx1ZVN0eWxlcy50cmFuc2Zvcm0gPSBzdHlsZVByb3AudHJhbnNmb3JtXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIHN0eWxlUHJvcC50cmFuc2Zvcm0pXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtVGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVpbGRTdHlsZVByb3BlcnR5KF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZVByb3ApLCBtb3Rpb25WYWx1ZVN0eWxlcyksICFpc1N0YXRpYyk7XHJcbn07XHJcbnZhciB1c2VNb3Rpb25TdHlsZXMgPSBmdW5jdGlvbiAodmFsdWVzLCBzdHlsZVByb3AsIGlzU3RhdGljLCB0cmFuc2Zvcm1WYWx1ZXMpIHtcclxuICAgIGlmIChzdHlsZVByb3AgPT09IHZvaWQgMCkgeyBzdHlsZVByb3AgPSB7fTsgfVxyXG4gICAgdmFyIHN0eWxlID0ge307XHJcbiAgICB2YXIgcHJldk1vdGlvblN0eWxlcyA9IHVzZVJlZih7fSkuY3VycmVudDtcclxuICAgIGZvciAodmFyIGtleSBpbiBzdHlsZVByb3ApIHtcclxuICAgICAgICB2YXIgdGhpc1N0eWxlID0gc3R5bGVQcm9wW2tleV07XHJcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUodGhpc1N0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbW90aW9uIHZhbHVlLCBhZGQgaXQgdG8gb3VyIE1vdGlvblZhbHVlc01hcFxyXG4gICAgICAgICAgICB2YWx1ZXMuc2V0KGtleSwgdGhpc1N0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzU3RhdGljICYmXHJcbiAgICAgICAgICAgIChpc1RyYW5zZm9ybVByb3Aoa2V5KSB8fCBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gT3IgaWYgaXQncyBhIHRyYW5zZm9ybSBwcm9wLCBjcmVhdGUgYSBtb3Rpb24gdmFsdWUgKG9yIHVwZGF0ZSBhbiBleGlzdGluZyBvbmUpXHJcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBTdHlsZWZpcmUgY2FuIHJlY29uY2lsZSBhbGwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgdG9nZXRoZXIuXHJcbiAgICAgICAgICAgIC8vIEEgZnVydGhlciBpdGVyYXRpb24gb24gdGhpcyB3b3VsZCBiZSB0byBjcmVhdGUgYSBzaW5nbGUgc3R5bGVyIHBlciBjb21wb25lbnQgdGhhdCBnZXRzXHJcbiAgICAgICAgICAgIC8vIHVzZWQgaW4gdGhlIERPTSByZW5kZXJlcidzIGJ1aWxkU3R5bGVBdHRyICphbmQqIGFuaW1hdGlvbnMsIHRoZW4gd2Ugd291bGQgb25seVxyXG4gICAgICAgICAgICAvLyBoYXZlIHRvIGNvbnZlcnQgYW5pbWF0aW5nIHZhbHVlcyB0byBgTW90aW9uVmFsdWVzYCAod2UgY291bGQgcHJvYmFibHkgcmVtb3ZlIHRoaXMgZW50aXJlIGZ1bmN0aW9uKS5cclxuICAgICAgICAgICAgLy8gVGhlIG9ubHkgYXJjaGl0ZWN0dXJhbCBjb25zaWRlcmF0aW9uIGlzIHRvIGFsbG93IFN0eWxlZmlyZSB0byBoYXZlIGVsZW1lbnRzIG1vdW50ZWQgYWZ0ZXJcclxuICAgICAgICAgICAgLy8gYSBzdHlsZXIgaXMgY3JlYXRlZC5cclxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QgYXMgYSBtb3Rpb24gdmFsdWUsIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnNldChrZXksIG1vdGlvblZhbHVlKHRoaXNTdHlsZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG9ubHkgdXBkYXRlIGl0IGlmIGl0J3MgY2hhbmdlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1N0eWxlICE9PSBwcmV2TW90aW9uU3R5bGVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KHRoaXNTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldk1vdGlvblN0eWxlc1trZXldID0gdGhpc1N0eWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVba2V5XSA9IHRoaXNTdHlsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtVmFsdWVzID8gdHJhbnNmb3JtVmFsdWVzKHN0eWxlKSA6IHN0eWxlO1xyXG59O1xuXG52YXIgaXNLZXlmcmFtZXNUYXJnZXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XHJcbn07XG5cbnZhciBpc0N1c3RvbVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcclxufTtcclxudmFyIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgLy8gVE9ETyBtYXliZSB0aHJvdyBpZiB2Lmxlbmd0aCAtIDEgaXMgcGxhY2Vob2xkZXIgdG9rZW4/XHJcbiAgICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XHJcbn07XG5cbnZhciBhdXRvID0ge1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IFwiYXV0b1wiOyB9LFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9LFxyXG59O1xyXG52YXIgZGltZW5zaW9uVHlwZXMgPSBbbnVtYmVyLCBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoLCBhdXRvXTtcclxudmFyIHZhbHVlVHlwZXMgPSBfX3NwcmVhZEFycmF5cyhkaW1lbnNpb25UeXBlcywgW2NvbG9yLCBjb21wbGV4XSk7XHJcbnZhciB0ZXN0VmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnRlc3Qodik7IH07IH07XHJcbnZhciBnZXREaW1lbnNpb25WYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIGRpbWVuc2lvblR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XHJcbn07XHJcbnZhciBnZXRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpOyB9O1xuXG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgdHlwZTogXCJzcHJpbmdcIixcclxuICAgIHN0aWZmbmVzczogNTAwLFxyXG4gICAgZGFtcGluZzogMjUsXHJcbiAgICByZXN0RGVsdGE6IDAuNSxcclxuICAgIHJlc3RTcGVlZDogMTAsXHJcbn0pOyB9O1xyXG52YXIgb3ZlckRhbXBlZFNwcmluZyA9IGZ1bmN0aW9uICh0bykgeyByZXR1cm4gKHtcclxuICAgIHR5cGU6IFwic3ByaW5nXCIsXHJcbiAgICBzdGlmZm5lc3M6IDcwMCxcclxuICAgIGRhbXBpbmc6IHRvID09PSAwID8gMTAwIDogMzUsXHJcbn0pOyB9O1xyXG52YXIgbGluZWFyVHdlZW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgZWFzZTogXCJsaW5lYXJcIixcclxuICAgIGR1cmF0aW9uOiAwLjMsXHJcbn0pOyB9O1xyXG52YXIga2V5ZnJhbWVzID0gZnVuY3Rpb24gKHZhbHVlcykgeyByZXR1cm4gKHtcclxuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXHJcbiAgICBkdXJhdGlvbjogMC44LFxyXG4gICAgdmFsdWVzOiB2YWx1ZXMsXHJcbn0pOyB9O1xyXG52YXIgZGVmYXVsdFRyYW5zaXRpb25zID0ge1xyXG4gICAgeDogdW5kZXJEYW1wZWRTcHJpbmcsXHJcbiAgICB5OiB1bmRlckRhbXBlZFNwcmluZyxcclxuICAgIHo6IHVuZGVyRGFtcGVkU3ByaW5nLFxyXG4gICAgcm90YXRlOiB1bmRlckRhbXBlZFNwcmluZyxcclxuICAgIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxyXG4gICAgcm90YXRlWTogdW5kZXJEYW1wZWRTcHJpbmcsXHJcbiAgICByb3RhdGVaOiB1bmRlckRhbXBlZFNwcmluZyxcclxuICAgIHNjYWxlWDogb3ZlckRhbXBlZFNwcmluZyxcclxuICAgIHNjYWxlWTogb3ZlckRhbXBlZFNwcmluZyxcclxuICAgIHNjYWxlOiBvdmVyRGFtcGVkU3ByaW5nLFxyXG4gICAgb3BhY2l0eTogbGluZWFyVHdlZW4sXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpbmVhclR3ZWVuLFxyXG4gICAgY29sb3I6IGxpbmVhclR3ZWVuLFxyXG4gICAgZGVmYXVsdDogb3ZlckRhbXBlZFNwcmluZyxcclxufTtcclxudmFyIGdldERlZmF1bHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlS2V5LCB0bykge1xyXG4gICAgdmFyIHRyYW5zaXRpb25GYWN0b3J5O1xyXG4gICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xyXG4gICAgICAgIHRyYW5zaXRpb25GYWN0b3J5ID0ga2V5ZnJhbWVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbkZhY3RvcnkgPVxyXG4gICAgICAgICAgICBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduKHsgdG86IHRvIH0sIHRyYW5zaXRpb25GYWN0b3J5KHRvKSk7XHJcbn07XG5cbi8qKlxyXG4gKiBBIFBvcG1vdGlvbiBhY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2luZ2xlIGB0b2AgcHJvcC4gV2hlbiBpdCBzdGFydHMsIGl0IGltbWVkaWF0ZWx5XHJcbiAqIHVwZGF0ZXMgd2l0aCBgdG9gIGFuZCB0aGVuIGNvbXBsZXRlcy4gQnkgdXNpbmcgdGhpcyB3ZSBjYW4gY29tcG9zZSBpbnN0YW50IHRyYW5zaXRpb25zXHJcbiAqIGluIHdpdGggdGhlIHNhbWUgbG9naWMgdGhhdCBhcHBsaWVzIGBkZWxheWAgb3IgcmV0dXJucyBhIGBQcm9taXNlYCBldGMuXHJcbiAqXHJcbiAqIEFjY2VwdGluZyBgZHVyYXRpb25gIGlzIGEgbGl0dGxlIGJpdCBvZiBhIGhhY2sgdGhhdCBzaW1wbHkgZGVmZXJzIHRoZSBjb21wbGV0ZXRpb24gb2ZcclxuICogdGhlIGFuaW1hdGlvbiB1bnRpbCBhZnRlciB0aGUgZHVyYXRpb24gZmluaXNoZXMuIFRoaXMgaXMgZm9yIHNpdHVhdGlvbnMgd2hlbiB5b3UncmUgKipvbmx5KipcclxuICogYW5pbWF0aW5nIG5vbi1hbmltYXRhYmxlIHZhbHVlcyBhbmQgdGhlbiBzZXR0aW5nIHNvbWV0aGluZyBvbiBgdHJhbnNpdGlvbkVuZGAuIFJlYWxseVxyXG4gKiB5b3Ugd2FudCB0aGlzIHRvIGZpcmUgYWZ0ZXIgdGhlIFwiYW5pbWF0aW9uXCIgZmluaXNoZXMsIHJhdGhlciB0aGFuIGluc3RhbnRseS5cclxuICpcclxuICogYGBgXHJcbiAqIGFuaW1hdGU9e3tcclxuICogICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gKiAgIHRyYW5zaXRpb25FbmQ6IHsgZGlzcGxheTogJ25vbmUnIH1cclxuICogfX1cclxuICogYGBgXHJcbiAqL1xyXG52YXIganVzdCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRvID0gX2EudG8sIGR1cmF0aW9uID0gX2EuZHVyYXRpb247XHJcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGUsIGNvbXBsZXRlID0gX2EuY29tcGxldGU7XHJcbiAgICAgICAgdXBkYXRlKHRvKTtcclxuICAgICAgICBkdXJhdGlvbiA/IGRlbGF5KGR1cmF0aW9uKS5zdGFydCh7IGNvbXBsZXRlOiBjb21wbGV0ZSB9KSA6IGNvbXBsZXRlKCk7XHJcbiAgICB9KTtcclxufTtcblxudmFyIGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgLy8gSWYgY3ViaWMgYmV6aWVyIGRlZmluaXRpb24sIGNyZWF0ZSBiZXppZXIgY3VydmVcclxuICAgICAgICBpbnZhcmlhbnQoZGVmaW5pdGlvbi5sZW5ndGggPT09IDQsIFwiQ3ViaWMgYmV6aWVyIGFycmF5cyBtdXN0IGNvbnRhaW4gZm91ciBudW1lcmljYWwgdmFsdWVzLlwiKTtcclxuICAgICAgICB2YXIgeDEgPSBkZWZpbml0aW9uWzBdLCB5MSA9IGRlZmluaXRpb25bMV0sIHgyID0gZGVmaW5pdGlvblsyXSwgeTIgPSBkZWZpbml0aW9uWzNdO1xyXG4gICAgICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIC8vIEVsc2UgbG9va3VwIGZyb20gdGFibGVcclxuICAgICAgICBpbnZhcmlhbnQoZWFzaW5nTG9va3VwW2RlZmluaXRpb25dICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBlYXNpbmcgdHlwZSAnXCIgKyBkZWZpbml0aW9uICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcclxufTtcclxudmFyIGlzRWFzaW5nQXJyYXkgPSBmdW5jdGlvbiAoZWFzZSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgdHlwZW9mIGVhc2VbMF0gIT09IFwibnVtYmVyXCI7XHJcbn07XG5cbnZhciBpc0R1cmF0aW9uQW5pbWF0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2Lmhhc093blByb3BlcnR5KFwiZHVyYXRpb25cIikgfHwgdi5oYXNPd25Qcm9wZXJ0eShcInJlcGVhdERlbGF5XCIpO1xyXG59O1xuXG4vKipcclxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbmltYXRhYmxlLiBFeGFtcGxlczpcclxuICpcclxuICog4pyFOiAxMDAsIFwiMTAwcHhcIiwgXCIjZmZmXCJcclxuICog4p2MOiBcImJsb2NrXCIsIFwidXJsKDIuanBnKVwiXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBpc0FuaW1hdGFibGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgLy8gSWYgdGhlIGxpc3Qgb2Yga2V5cyB0YXQgbWlnaHQgYmUgbm9uLWFuaW1hdGFibGUgZ3Jvd3MsIHJlcGxhY2Ugd2l0aCBTZXRcclxuICAgIGlmIChrZXkgPT09IFwiekluZGV4XCIpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gSWYgaXQncyBhIG51bWJlciBvciBhIGtleWZyYW1lcyBhcnJheSwgd2UgY2FuIGFuaW1hdGUgaXQuIFdlIG1pZ2h0IGF0IHNvbWUgcG9pbnRcclxuICAgIC8vIG5lZWQgdG8gZG8gYSBkZWVwIGlzQW5pbWF0YWJsZSBjaGVjayBvZiBrZXlmcmFtZXMsIG9yIGxldCBQb3Btb3Rpb24gaGFuZGxlIHRoaXMsXHJcbiAgICAvLyBidXQgZm9yIG5vdyBsZXRzIGxlYXZlIGl0IGxpa2UgdGhpcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgLy8gSXQncyBhbmltYXRhYmxlIGlmIHdlIGhhdmUgYSBzdHJpbmdcclxuICAgICAgICBjb21wbGV4LnRlc3QodmFsdWUpICYmIC8vIEFuZCBpdCBjb250YWlucyBudW1iZXJzIGFuZC9vciBjb2xvcnNcclxuICAgICAgICAhdmFsdWUuc3RhcnRzV2l0aChcInVybChcIikgLy8gVW5sZXNzIGl0IHN0YXJ0cyB3aXRoIFwidXJsKFwiXHJcbiAgICApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcblxuLyoqXHJcbiAqIENvbnZlcnRzIHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGltZSBpbiBzZWNvbmRzLlxyXG4gKiBAcmV0dXJuIG1pbGxpc2Vjb25kcyAtIENvbnZlcnRlZCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICovXHJcbnZhciBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoc2Vjb25kcykgeyByZXR1cm4gc2Vjb25kcyAqIDEwMDA7IH07XG5cbnZhciB0cmFuc2l0aW9ucyA9IHsgdHdlZW46IHR3ZWVuLCBzcHJpbmc6IHNwcmluZywga2V5ZnJhbWVzOiBrZXlmcmFtZXMkMSwgaW5lcnRpYTogaW5lcnRpYSwganVzdDoganVzdCB9O1xyXG52YXIgdHJhbnNpdGlvbk9wdGlvblBhcnNlciA9IHtcclxuICAgIHR3ZWVuOiBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIGlmIChvcHRzLmVhc2UpIHtcclxuICAgICAgICAgICAgdmFyIGVhc2UgPSBpc0Vhc2luZ0FycmF5KG9wdHMuZWFzZSkgPyBvcHRzLmVhc2VbMF0gOiBvcHRzLmVhc2U7XHJcbiAgICAgICAgICAgIG9wdHMuZWFzZSA9IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH0sXHJcbiAgICBrZXlmcmFtZXM6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgdmVsb2NpdHkgPSBfYS52ZWxvY2l0eSwgb3B0cyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCIsIFwidmVsb2NpdHlcIl0pO1xyXG4gICAgICAgIGlmIChvcHRzLnZhbHVlcyAmJiBvcHRzLnZhbHVlc1swXSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX19zcHJlYWRBcnJheXMob3B0cy52YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YWx1ZXNbMF0gPSBmcm9tO1xyXG4gICAgICAgICAgICBvcHRzLnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuZWFzZSkge1xyXG4gICAgICAgICAgICBvcHRzLmVhc2luZ3MgPSBpc0Vhc2luZ0FycmF5KG9wdHMuZWFzZSlcclxuICAgICAgICAgICAgICAgID8gb3B0cy5lYXNlLm1hcChlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIDogZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24ob3B0cy5lYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0cy5lYXNlID0gbGluZWFyO1xyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfSxcclxufTtcclxudmFyIGlzVHJhbnNpdGlvbkRlZmluZWQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciB3aGVuID0gX2Eud2hlbiwgZGVsYXkgPSBfYS5kZWxheSwgZGVsYXlDaGlsZHJlbiA9IF9hLmRlbGF5Q2hpbGRyZW4sIHN0YWdnZXJDaGlsZHJlbiA9IF9hLnN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiA9IF9hLnN0YWdnZXJEaXJlY3Rpb24sIHRyYW5zaXRpb24gPSBfX3Jlc3QoX2EsIFtcIndoZW5cIiwgXCJkZWxheVwiLCBcImRlbGF5Q2hpbGRyZW5cIiwgXCJzdGFnZ2VyQ2hpbGRyZW5cIiwgXCJzdGFnZ2VyRGlyZWN0aW9uXCJdKTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XHJcbn07XHJcbnZhciBnZXRUcmFuc2l0aW9uRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChrZXksIHRvLCB0cmFuc2l0aW9uRGVmaW5pdGlvbikge1xyXG4gICAgdmFyIGRlbGF5ID0gdHJhbnNpdGlvbkRlZmluaXRpb24gPyB0cmFuc2l0aW9uRGVmaW5pdGlvbi5kZWxheSA6IDA7XHJcbiAgICAvLyBJZiBubyBvYmplY3QsIHJldHVybiBkZWZhdWx0IHRyYW5zaXRpb25cclxuICAgIC8vIEEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcyB3b3VsZCBiZSB0byBkZWNvbnN0cnVjdCBvdXQgYWxsIHRoZSBzaGFyZWQgT3JjaGVzdHJhdGlvbiBwcm9wc1xyXG4gICAgLy8gYW5kIHNlZSBpZiB0aGVyZSdzIGFueSBwcm9wcyByZW1haW5pbmdcclxuICAgIGlmICh0cmFuc2l0aW9uRGVmaW5pdGlvbiA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgIWlzVHJhbnNpdGlvbkRlZmluZWQodHJhbnNpdGlvbkRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgZGVsYXk6IGRlbGF5IH0sIGdldERlZmF1bHRUcmFuc2l0aW9uKGtleSwgdG8pKTtcclxuICAgIH1cclxuICAgIHZhciB2YWx1ZVRyYW5zaXRpb25EZWZpbml0aW9uID0gdHJhbnNpdGlvbkRlZmluaXRpb25ba2V5XSB8fFxyXG4gICAgICAgIHRyYW5zaXRpb25EZWZpbml0aW9uLmRlZmF1bHQgfHxcclxuICAgICAgICB0cmFuc2l0aW9uRGVmaW5pdGlvbjtcclxuICAgIGlmICh2YWx1ZVRyYW5zaXRpb25EZWZpbml0aW9uLnR5cGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVsYXk6IHZhbHVlVHJhbnNpdGlvbkRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoXCJkZWxheVwiKVxyXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVRyYW5zaXRpb25EZWZpbml0aW9uLmRlbGF5XHJcbiAgICAgICAgICAgICAgICA6IGRlbGF5LFxyXG4gICAgICAgICAgICB0bzogaXNLZXlmcmFtZXNUYXJnZXQodG8pXHJcbiAgICAgICAgICAgICAgICA/IHRvW3RvLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgICAgICA6IHRvLFxyXG4gICAgICAgICAgICB0eXBlOiBcImp1c3RcIixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHsgdmFsdWVzOiB0bywgZHVyYXRpb246IDAuOCwgZGVsYXk6IGRlbGF5LCBlYXNlOiBcImxpbmVhclwiIH0sIHZhbHVlVHJhbnNpdGlvbkRlZmluaXRpb24pLCB7IFxyXG4gICAgICAgICAgICAvLyBUaGlzIGFuaW1hdGlvbiBtdXN0IGJlIGtleWZyYW1lcyBpZiB3ZSdyZSBhbmltYXRpbmcgdGhyb3VnaCBhbiBhcnJheVxyXG4gICAgICAgICAgICB0eXBlOiBcImtleWZyYW1lc1wiIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgdHlwZTogXCJ0d2VlblwiLCB0bzogdG8sXHJcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSB9LCB2YWx1ZVRyYW5zaXRpb25EZWZpbml0aW9uKTtcclxuICAgIH1cclxufTtcclxudmFyIHByZXByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKHR5cGUsIG9wdHMpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uT3B0aW9uUGFyc2VyW3R5cGVdXHJcbiAgICAgICAgPyB0cmFuc2l0aW9uT3B0aW9uUGFyc2VyW3R5cGVdKG9wdHMpXHJcbiAgICAgICAgOiBvcHRzO1xyXG59O1xyXG52YXIgZ2V0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbikge1xyXG4gICAgdmFyIG9yaWdpbiA9IHZhbHVlLmdldCgpO1xyXG4gICAgdmFyIGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShrZXksIG9yaWdpbik7XHJcbiAgICB2YXIgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleSwgdGFyZ2V0KTtcclxuICAgIC8vIFRPRE8gd2UgY291bGQgcHJvYmFibHkgaW1wcm92ZSB0aGlzIGNoZWNrIHRvIGVuc3VyZSBib3RoIHZhbHVlcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSAtXHJcbiAgICAvLyBmb3IgaW5zdGFuY2UgMTAwIHRvICNmZmYuIFRoaXMgbWlnaHQgbGl2ZSBiZXR0ZXIgaW4gUG9wbW90aW9uLlxyXG4gICAgd2FybmluZyhpc09yaWdpbkFuaW1hdGFibGUgPT09IGlzVGFyZ2V0QW5pbWF0YWJsZSwgXCJZb3UgYXJlIHRyeWluZyB0byBhbmltYXRlIFwiICsga2V5ICsgXCIgZnJvbSBcXFwiXCIgKyBvcmlnaW4gKyBcIlxcXCIgdG8gXCIgKyB0YXJnZXQgKyBcIi4gXFxcIlwiICsgb3JpZ2luICsgXCJcXFwiIGlzIG5vdCBhbiBhbmltYXRhYmxlIHZhbHVlIC0gdG8gZW5hYmxlIHRoaXMgYW5pbWF0aW9uIHNldCBcIiArIG9yaWdpbiArIFwiIHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byBcIiArIHRhcmdldCArIFwiIHZpYSB0aGUgYHN0eWxlYCBwcm9wZXJ0eS5cIik7XHJcbiAgICAvLyBQYXJzZSB0aGUgYHRyYW5zaXRpb25gIHByb3AgYW5kIHJldHVybiBvcHRpb25zIGZvciB0aGUgUG9wbW90aW9uIGFuaW1hdGlvblxyXG4gICAgdmFyIF9hID0gZ2V0VHJhbnNpdGlvbkRlZmluaXRpb24oa2V5LCB0YXJnZXQsIHRyYW5zaXRpb24pLCBfYiA9IF9hLnR5cGUsIHR5cGUgPSBfYiA9PT0gdm9pZCAwID8gXCJ0d2VlblwiIDogX2IsIHRyYW5zaXRpb25EZWZpbml0aW9uID0gX19yZXN0KF9hLCBbXCJ0eXBlXCJdKTtcclxuICAgIC8vIElmIHRoaXMgaXMgYW4gYW5pbWF0YWJsZSBwYWlyIG9mIHZhbHVlcywgcmV0dXJuIGFuIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIHVzZSBganVzdGBcclxuICAgIHZhciBhY3Rpb25GYWN0b3J5ID0gaXNPcmlnaW5BbmltYXRhYmxlICYmIGlzVGFyZ2V0QW5pbWF0YWJsZVxyXG4gICAgICAgID8gdHJhbnNpdGlvbnNbdHlwZV1cclxuICAgICAgICA6IGp1c3Q7XHJcbiAgICB2YXIgb3B0cyA9IHByZXByb2Nlc3NPcHRpb25zKHR5cGUsIF9fYXNzaWduKHsgZnJvbTogb3JpZ2luLCB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSB9LCB0cmFuc2l0aW9uRGVmaW5pdGlvbikpO1xyXG4gICAgLy8gQ29udmVydCBkdXJhdGlvbiBmcm9tIEZyYW1lciBNb3Rpb24ncyBzZWNvbmRzIGludG8gUG9wbW90aW9uJ3MgbWlsbGlzZWNvbmRzXHJcbiAgICBpZiAoaXNEdXJhdGlvbkFuaW1hdGlvbihvcHRzKSkge1xyXG4gICAgICAgIGlmIChvcHRzLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZHVyYXRpb24gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMob3B0cy5kdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnJlcGVhdERlbGF5KSB7XHJcbiAgICAgICAgICAgIG9wdHMucmVwZWF0RGVsYXkgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMob3B0cy5yZXBlYXREZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthY3Rpb25GYWN0b3J5LCBvcHRzXTtcclxufTtcclxuLyoqXHJcbiAqIFN0YXJ0IGFuaW1hdGlvbiBvbiBhIHZhbHVlLiBUaGlzIGZ1bmN0aW9uIGNvbXBsZXRlbHkgZW5jYXBzdWxhdGVzIFBvcG1vdGlvbi1zcGVjaWZpYyBsb2dpYy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihrZXksIHZhbHVlLCB0YXJnZXQsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYS5kZWxheSwgZGVsYXkkMSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIHRyYW5zaXRpb24gPSBfX3Jlc3QoX2EsIFtcImRlbGF5XCJdKTtcclxuICAgIHJldHVybiB2YWx1ZS5zdGFydChmdW5jdGlvbiAoY29tcGxldGUpIHtcclxuICAgICAgICB2YXIgYWN0aXZlQW5pbWF0aW9uO1xyXG4gICAgICAgIHZhciBfYSA9IGdldEFuaW1hdGlvbihrZXksIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24pLCBhbmltYXRpb25GYWN0b3J5ID0gX2FbMF0sIF9iID0gX2FbMV0sIHZhbHVlRGVsYXkgPSBfYi5kZWxheSwgb3B0aW9ucyA9IF9fcmVzdChfYiwgW1wiZGVsYXlcIl0pO1xyXG4gICAgICAgIGlmICh2YWx1ZURlbGF5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGVsYXkkMSA9IHZhbHVlRGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbmltYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uRmFjdG9yeShvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gQmluZCBhbmltYXRpb24gb3B0cyB0byBhbmltYXRpb25cclxuICAgICAgICAgICAgYWN0aXZlQW5pbWF0aW9uID0gYW5pbWF0aW9uLnN0YXJ0KHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlLnNldCh2KTsgfSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBkZWxheWluZyB0aGlzIGFuaW1hdGlvbiwgb25seSByZXNvbHZlIGl0ICoqYWZ0ZXIqKiB0aGUgZGVsYXkgdG9cclxuICAgICAgICAvLyBlbnN1cmUgdGhlIHZhbHVlJ3MgcmVzb2x2ZSB2ZWxvY2l0eSBpcyB1cC10by1kYXRlLlxyXG4gICAgICAgIGlmIChkZWxheSQxKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUFuaW1hdGlvbiA9IGRlbGF5KHNlY29uZHNUb01pbGxpc2Vjb25kcyhkZWxheSQxKSkuc3RhcnQoe1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGFuaW1hdGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYW5pbWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlQW5pbWF0aW9uKVxyXG4gICAgICAgICAgICAgICAgYWN0aXZlQW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBldmVyeSBgTW90aW9uVmFsdWVgXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLVxyXG4gKi9cclxudmFyIGdldEN1cnJlbnQgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IHt9O1xyXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuIChjdXJyZW50W2tleV0gPSB2YWx1ZS5nZXQoKSk7IH0pO1xyXG4gICAgcmV0dXJuIGN1cnJlbnQ7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgZXZlcnkgYE1vdGlvblZhbHVlYFxyXG4gKiBAcGFyYW0gdmFsdWVzIC1cclxuICovXHJcbnZhciBnZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgIHZhciB2ZWxvY2l0eSA9IHt9O1xyXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuICh2ZWxvY2l0eVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKSk7IH0pO1xyXG4gICAgcmV0dXJuIHZlbG9jaXR5O1xyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBgVGFyZ2V0YC4gQSBnZW5lcmljIHR5cGVvZiA9PT0gJ2Z1bmN0aW9uJ1xyXG4gKiBjaGVjaywganVzdCBoZWxwcyB3aXRoIHR5cGluZy5cclxuICogQHBhcmFtIHAgLVxyXG4gKi9cclxudmFyIGlzVGFyZ2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIGxpc3Qgb2YgdmFyaWFudCBsYWJlbHNcclxuICogQHBhcmFtIHYgLVxyXG4gKi9cclxudmFyIGlzVmFyaWFudExhYmVscyA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBBcnJheS5pc0FycmF5KHYpOyB9O1xyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBudW1lcmljYWwgc3RyaW5nLCBpZSBcIjEwMFwiIG9yIFwiMTAwcHhcIlxyXG4gKi9cclxudmFyIGlzTnVtZXJpY2FsU3RyaW5nID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIC9eXFxkKlxcLj9cXGQrJC8udGVzdCh2KTsgfTtcclxuLyoqXHJcbiAqIENvbnRyb2wgYW5pbWF0aW9ucyBmb3IgYSBzaW5nbGUgY29tcG9uZW50XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFZhbHVlQW5pbWF0aW9uQ29udHJvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzKF9hKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmFsdWVzID0gX2EudmFsdWVzLCByZWFkVmFsdWVGcm9tU291cmNlID0gX2EucmVhZFZhbHVlRnJvbVNvdXJjZSwgbWFrZVRhcmdldEFuaW1hdGFibGUgPSBfYS5tYWtlVGFyZ2V0QW5pbWF0YWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50J3MgbGF0ZXN0IHByb3BzLiBXZSBjb3VsZCBwcm9iYWJseSBkaXRjaCB0aGlzIGluXHJcbiAgICAgICAgICogZmF2b3VyIHRvIGEgcmVmZXJlbmNlIHRvIHRoZSBgY3VzdG9tYCBwcm9wIG5vdyB3ZSBkb24ndCBzZW5kIGFsbCBwcm9wcyB0aHJvdWdoXHJcbiAgICAgICAgICogdG8gdGFyZ2V0IHJlc29sdmVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByb3BzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbXBvbmVudCdzIHZhcmlhbnRzLCBhcyBwcm92aWRlZCBieSBgdmFyaWFudHNgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52YXJpYW50cyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc2V0IG9mIHZhbHVlcyB0aGF0IHdlIGFuaW1hdGUgYmFjayB0byB3aGVuIGEgdmFsdWUgaXMgY2xlYXJlZCBvZiBhbGwgb3ZlcnJpZGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmFzZVRhcmdldCA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc2VyaWVzIG9mIHRhcmdldCBvdmVycmlkZXMgdGhhdCB3ZSBjYW4gYW5pbWF0ZSB0by9mcm9tIHdoZW4gb3ZlcnJpZGVzIGFyZSBzZXQvY2xlYXJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc2VyaWVzIG9mIHRhcmdldCBvdmVycmlkZXMgYXMgdGhleSB3ZXJlIG9yaWdpbmFsbHkgcmVzb2x2ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHZlZE92ZXJyaWRlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2V0IG9mIGN1cnJlbnRseSBhY3RpdmUgb3ZlcnJpZGUgaW5kZXhlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT3ZlcnJpZGVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2V0IG9mIHZhbHVlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGFuaW1hdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGlmIHRoZSBhc3NvY2lhdGVkIGBNb3Rpb25WYWx1ZU1hcGAgaGFzIGEga2V5IHdpdGggdGhlIHByb3ZpZGVkIHN0cmluZy5cclxuICAgICAgICAgKiBQcmUtYm91bmQgdG8gdGhlIGNsYXNzIHNvIHdlIGNhbiBwcm92aWRlIGRpcmVjdGx5IHRvIHRoZSBgZmlsdGVyYCBpbiBgY2hlY2tGb3JOZXdWYWx1ZXNgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhX3RoaXMudmFsdWVzLmhhcyhrZXkpOyB9O1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgIHRoaXMucmVhZFZhbHVlRnJvbVNvdXJjZSA9IHJlYWRWYWx1ZUZyb21Tb3VyY2U7XHJcbiAgICAgICAgdGhpcy5tYWtlVGFyZ2V0QW5pbWF0YWJsZSA9IG1ha2VUYXJnZXRBbmltYXRhYmxlO1xyXG4gICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuIChfdGhpcy5iYXNlVGFyZ2V0W2tleV0gPSB2YWx1ZS5nZXQoKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50J3MgcHJvcHMuXHJcbiAgICAgKiBAcGFyYW0gcHJvcHMgLVxyXG4gICAgICovXHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQncyB2YXJpYW50c1xyXG4gICAgICogQHBhcmFtIHZhcmlhbnRzIC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuc2V0VmFyaWFudHMgPSBmdW5jdGlvbiAodmFyaWFudHMpIHtcclxuICAgICAgICBpZiAodmFyaWFudHMpXHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFudHMgPSB2YXJpYW50cztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29tcG9uZW50J3MgZGVmYXVsdCB0cmFuc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiAtXHJcbiAgICAgKi9cclxuICAgIFZhbHVlQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnNldERlZmF1bHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbilcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbW90aW9uIHZhbHVlcyB3aXRob3V0IGFuaW1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbiAtXHJcbiAgICAgKiBAcGFyYW0gaXNBY3RpdmUgLVxyXG4gICAgICovXHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgX2EpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmlzQWN0aXZlLCBpc0FjdGl2ZSA9IF9jID09PSB2b2lkIDAgPyBuZXcgU2V0KCkgOiBfYywgcHJpb3JpdHkgPSBfYi5wcmlvcml0eTtcclxuICAgICAgICB2YXIgX2QgPSB0aGlzLnJlc29sdmVWYXJpYW50KGRlZmluaXRpb24pLCB0YXJnZXQgPSBfZC50YXJnZXQsIHRyYW5zaXRpb25FbmQgPSBfZC50cmFuc2l0aW9uRW5kO1xyXG4gICAgICAgIHRhcmdldCA9IHRoaXMudHJhbnNmb3JtVmFsdWVzKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZS5oYXMoa2V5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaXNBY3RpdmUuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0W2tleV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLnZhbHVlcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAmJiB2YWx1ZS5zZXQodGFyZ2V0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWVzLnNldChrZXksIG1vdGlvblZhbHVlKHRhcmdldFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByaW9yaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJhc2VUYXJnZXRba2V5XSA9IHRhcmdldFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd3MgYHRyYW5zZm9ybVZhbHVlc2AgdG8gYmUgc2V0IGJ5IGEgY29tcG9uZW50IHRoYXQgYWxsb3dzIHVzIHRvXHJcbiAgICAgKiB0cmFuc2Zvcm0gdGhlIHZhbHVlcyBpbiBhIGdpdmVuIGBUYXJnZXRgLiBUaGlzIGFsbG93cyBGcmFtZXIgTGlicmFyeVxyXG4gICAgICogdG8gZXh0ZW5kIEZyYW1lciBNb3Rpb24gdG8gYW5pbWF0ZSBgQ29sb3JgIHZhcmlhYmxlcyBldGMuIEN1cnJlbnRseSB3ZSBoYXZlXHJcbiAgICAgKiB0byBtYW51YWxseSBzdXBwb3J0IHRoZXNlIGV4dGVuZGVkIHR5cGVzIGhlcmUgaW4gRnJhbWVyIE1vdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUudHJhbnNmb3JtVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1WYWx1ZXMgPSB0aGlzLnByb3BzLnRyYW5zZm9ybVZhbHVlcztcclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtVmFsdWVzID8gdHJhbnNmb3JtVmFsdWVzKHZhbHVlcykgOiB2YWx1ZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBhIGBUYXJnZXRgIGZvciBuZXcgdmFsdWVzIHdlIGhhdmVuJ3QgYW5pbWF0ZWQgeWV0LCBhbmQgYWRkIHRoZW1cclxuICAgICAqIHRvIHRoZSBgTW90aW9uVmFsdWVNYXBgLlxyXG4gICAgICpcclxuICAgICAqIEN1cnJlbnRseSB0aGVyZSdzIGZ1bmN0aW9uYWxpdHkgaGVyZSB0aGF0IGlzIERPTS1zcGVjaWZpYywgd2Ugc2hvdWxkIGFsbG93XHJcbiAgICAgKiB0aGlzIGZ1bmN0aW9uYWxpdHkgdG8gYmUgaW5qZWN0ZWQgYnkgdGhlIGZhY3RvcnkgdGhhdCBjcmVhdGVzIERPTS1zcGVjaWZpY1xyXG4gICAgICogY29tcG9uZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuY2hlY2tGb3JOZXdWYWx1ZXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKHRoaXMuaGFzVmFsdWUpO1xyXG4gICAgICAgIHZhciBudW1OZXdWYWx1ZXMgPSBuZXdWYWx1ZUtleXMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghbnVtTmV3VmFsdWVzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZXdWYWx1ZXM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gbmV3VmFsdWVLZXlzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGtleWZyYW1lcyB2YWx1ZSwgd2UgY2FuIGF0dGVtcHQgdG8gdXNlIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGVcclxuICAgICAgICAgICAgLy8gYXJyYXkgYXMgdGhhdCdzIGdvaW5nIHRvIGJlIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uIGFueXdheVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0VmFsdWVbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgYSBrZXlmcmFtZXMgb3IgdGhlIGZpcnN0IGtleWZyYW1lcyB2YWx1ZSB3YXMgc2V0IGFzIGBudWxsYCwgcmVhZCB0aGVcclxuICAgICAgICAgICAgLy8gdmFsdWUgZnJvbSB0aGUgRE9NLiBJdCBtaWdodCBiZSB3b3J0aCBpbnZlc3RpZ2F0aW5nIHdoZXRoZXIgdG8gY2hlY2sgcHJvcHMgKGZvciBTVkcpXHJcbiAgICAgICAgICAgIC8vIG9yIHByb3BzLnN0eWxlIChmb3IgSFRNTCkgaWYgdGhlIHZhbHVlIGV4aXN0cyB0aGVyZSBiZWZvcmUgYXR0ZW1wdGluZyB0byByZWFkLlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZWFkVmFsdWVGcm9tU291cmNlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnQodmFsdWUgIT09IG51bGwsIFwiTm8gaW5pdGlhbCB2YWx1ZSBmb3IgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBiZSBpbmZlcnJlZC4gRW5zdXJlIGFuIGluaXRpYWwgdmFsdWUgZm9yIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBkZWZpbmVkIG9uIHRoZSBjb21wb25lbnQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgaXNOdW1lcmljYWxTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbnVtYmVyIHJlYWQgYXMgYSBzdHJpbmcsIGllIFwiMFwiIG9yIFwiMjAwXCIsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXJcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWdldFZhbHVlVHlwZSh2YWx1ZSkgJiYgY29tcGxleC50ZXN0KHRhcmdldFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgbm90IHJlY29nbmlzZWQgYXMgYW5pbWF0YWJsZSwgaWUgXCJub25lXCIsIGNyZWF0ZSBhbiBhbmltYXRhYmxlIHZlcnNpb24gb3JpZ2luIGJhc2VkIG9uIHRoZSB0YXJnZXRcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY29tcGxleC5nZXRBbmltYXRhYmxlTm9uZSh0YXJnZXRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc2V0KGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlIGEgdmFyaWFudCBmcm9tIGl0cyBsYWJlbCBvciByZXNvbHZlciBpbnRvIGFuIGFjdHVhbCBgVGFyZ2V0YCB3ZSBjYW4gYW5pbWF0ZSB0by5cclxuICAgICAqIEBwYXJhbSB2YXJpYW50IC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUucmVzb2x2ZVZhcmlhbnQgPSBmdW5jdGlvbiAodmFyaWFudCkge1xyXG4gICAgICAgIGlmICghdmFyaWFudCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1RhcmdldFJlc29sdmVyKHZhcmlhbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgY3VycmVudCBhbmQgdmVsb2NpdHlcclxuICAgICAgICAgICAgdmFyaWFudCA9IHZhcmlhbnQodGhpcy5wcm9wcy5jdXN0b20sIGdldEN1cnJlbnQodGhpcy52YWx1ZXMpLCBnZXRWZWxvY2l0eSh0aGlzLnZhbHVlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSB2YXJpYW50LnRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBfYSA9PT0gdm9pZCAwID8gdGhpcy5kZWZhdWx0VHJhbnNpdGlvbiA6IF9hLCB0cmFuc2l0aW9uRW5kID0gdmFyaWFudC50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSBfX3Jlc3QodmFyaWFudCwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xyXG4gICAgICAgIHJldHVybiB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQsIHRhcmdldDogdGFyZ2V0IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGhpZ2hlc3QgYWN0aXZlIG92ZXJyaWRlIHByaW9yaXR5IGluZGV4XHJcbiAgICAgKi9cclxuICAgIFZhbHVlQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLmdldEhpZ2hlc3RQcmlvcml0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlT3ZlcnJpZGVzLnNpemUpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBBcnJheS5mcm9tKHRoaXMuYWN0aXZlT3ZlcnJpZGVzKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYW4gb3ZlcnJpZGUuIFdlIGFkZCB0aGlzIGxheWVyIG9mIGluZGlyZWN0aW9uIHNvIGlmLCBmb3IgaW5zdGFuY2UsIGEgdGFwIGdlc3R1cmVcclxuICAgICAqIHN0YXJ0cyBhbmQgb3ZlcnJpZGVzIGEgaG92ZXIgZ2VzdHVyZSwgd2hlbiB3ZSBjbGVhciB0aGUgdGFwIGdlc3R1cmUgYW5kIGZhbGxiYWNrIHRvIHRoZVxyXG4gICAgICogaG92ZXIgZ2VzdHVyZSwgaWYgdGhhdCBob3ZlciBnZXN0dXJlIGhhcyBjaGFuZ2VkIGluIHRoZSBtZWFudGltZSB3ZSBjYW4gZ28gdG8gdGhhdCByYXRoZXJcclxuICAgICAqIHRoYW4gdGhlIG9uZSB0aGF0IHdhcyByZXNvbHZlZCB3aGVuIHRoZSBob3ZlciBnZXN0dXJlIGFuaW1hdGlvbiBzdGFydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9uIC1cclxuICAgICAqIEBwYXJhbSBvdmVycmlkZUluZGV4IC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuc2V0T3ZlcnJpZGUgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgb3ZlcnJpZGVJbmRleCkge1xyXG4gICAgICAgIHRoaXMub3ZlcnJpZGVzW292ZXJyaWRlSW5kZXhdID0gZGVmaW5pdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0T3ZlcnJpZGUoZGVmaW5pdGlvbiwgb3ZlcnJpZGVJbmRleCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGFuIG92ZXJyaWRlIGFuaW1hdGlvbi5cclxuICAgICAqIEBwYXJhbSBvdmVycmlkZUluZGV4IC1cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuc3RhcnRPdmVycmlkZSA9IGZ1bmN0aW9uIChvdmVycmlkZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gdGhpcy5vdmVycmlkZXNbb3ZlcnJpZGVJbmRleF07XHJcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KG92ZXJyaWRlLCB7IHByaW9yaXR5OiBvdmVycmlkZUluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIGFuIG92ZXJyaWRlLiBXZSBjaGVjayBldmVyeSB2YWx1ZSB3ZSBhbmltYXRlZCB0byBpbiB0aGlzIG92ZXJyaWRlIHRvIHNlZSBpZlxyXG4gICAgICogaXRzIHByZXNlbnQgb24gYW55IGxvd2VyLXByaW9yaXR5IG92ZXJyaWRlcy4gSWYgbm90LCB3ZSBhbmltYXRlIGl0IGJhY2sgdG8gaXRzIGJhc2UgdGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIG92ZXJyaWRlSW5kZXggLVxyXG4gICAgICovXHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5jbGVhck92ZXJyaWRlID0gZnVuY3Rpb24gKG92ZXJyaWRlSW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmNsZWFyT3ZlcnJpZGUob3ZlcnJpZGVJbmRleCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLm92ZXJyaWRlc1tvdmVycmlkZUluZGV4XTtcclxuICAgICAgICBpZiAoIW92ZXJyaWRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPdmVycmlkZXMuZGVsZXRlKG92ZXJyaWRlSW5kZXgpO1xyXG4gICAgICAgIHZhciBoaWdoZXN0ID0gdGhpcy5nZXRIaWdoZXN0UHJpb3JpdHkoKTtcclxuICAgICAgICB0aGlzLnJlc2V0SXNBbmltYXRpbmcoKTtcclxuICAgICAgICBpZiAoaGlnaGVzdCkge1xyXG4gICAgICAgICAgICB2YXIgaGlnaGVzdE92ZXJyaWRlID0gdGhpcy5vdmVycmlkZXNbaGlnaGVzdF07XHJcbiAgICAgICAgICAgIGhpZ2hlc3RPdmVycmlkZSAmJiB0aGlzLnN0YXJ0T3ZlcnJpZGUoaGlnaGVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggcmVtYWluaW5nIHZhbHVlcyB3ZXJlIGFmZmVjdGVkIGJ5IHRoZSBvdmVycmlkZSBhbmQgYW5pbWF0ZSB0aG9zZVxyXG4gICAgICAgIHZhciBvdmVycmlkZVRhcmdldCA9IHRoaXMucmVzb2x2ZWRPdmVycmlkZXNbb3ZlcnJpZGVJbmRleF07XHJcbiAgICAgICAgaWYgKCFvdmVycmlkZVRhcmdldClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdWYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5iYXNlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChvdmVycmlkZVRhcmdldFtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1ZhbHVlc1trZXldID0gdGhpcy5iYXNlVGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vblN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRlKHJlbWFpbmluZ1ZhbHVlcykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkNvbXBsZXRlKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYSB0YXJnZXQvdmFyaWFudCB3aXRob3V0IGFueSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5VmFyaWFudExhYmVscyhkZWZpbml0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlWYXJpYW50TGFiZWxzKFtkZWZpbml0aW9uXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlcyhkZWZpbml0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB2YXJpYW50IGxhYmVscyB3aXRob3V0IGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5hcHBseVZhcmlhbnRMYWJlbHMgPSBmdW5jdGlvbiAodmFyaWFudExhYmVsTGlzdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciByZXZlcnNlZExpc3QgPSBfX3NwcmVhZEFycmF5cyh2YXJpYW50TGFiZWxMaXN0KS5yZXZlcnNlKCk7XHJcbiAgICAgICAgcmV2ZXJzZWRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5yZXNvbHZlVmFyaWFudChfdGhpcy52YXJpYW50c1trZXldKSwgdGFyZ2V0ID0gX2EudGFyZ2V0LCB0cmFuc2l0aW9uRW5kID0gX2EudHJhbnNpdGlvbkVuZDtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25FbmQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFZhbHVlcyh0cmFuc2l0aW9uRW5kLCB7IGlzQWN0aXZlOiBpc0FjdGl2ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRWYWx1ZXModGFyZ2V0LCB7IGlzQWN0aXZlOiBpc0FjdGl2ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2hpbGRyZW4gJiYgX3RoaXMuY2hpbGRyZW4uc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuYXBwbHlWYXJpYW50TGFiZWxzKHZhcmlhbnRMYWJlbExpc3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBvcHRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChvcHRzLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT3ZlcnJpZGVzLmFkZChvcHRzLnByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldElzQW5pbWF0aW5nKG9wdHMucHJpb3JpdHkpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb247XHJcbiAgICAgICAgaWYgKGlzVmFyaWFudExhYmVscyhkZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgICBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGVWYXJpYW50TGFiZWxzKGRlZmluaXRpb24sIG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGVWYXJpYW50KGRlZmluaXRpb24sIG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRlKGRlZmluaXRpb24sIG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uU3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Db21wbGV0ZSgpOyB9KTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGFuaW1hdGlvbkRlZmluaXRpb24sIF9hKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5kZWxheSwgZGVsYXkgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLCBfZCA9IF9iLnByaW9yaXR5LCBwcmlvcml0eSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIHRyYW5zaXRpb25PdmVycmlkZSA9IF9iLnRyYW5zaXRpb25PdmVycmlkZTtcclxuICAgICAgICB2YXIgX2UgPSB0aGlzLnJlc29sdmVWYXJpYW50KGFuaW1hdGlvbkRlZmluaXRpb24pLCB0YXJnZXQgPSBfZS50YXJnZXQsIHRyYW5zaXRpb24gPSBfZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kID0gX2UudHJhbnNpdGlvbkVuZDtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uT3ZlcnJpZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0KVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50cmFuc2Zvcm1WYWx1ZXModGFyZ2V0KTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbkVuZCkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gdGhpcy50cmFuc2Zvcm1WYWx1ZXModHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hlY2tGb3JOZXdWYWx1ZXModGFyZ2V0KTtcclxuICAgICAgICBpZiAodGhpcy5tYWtlVGFyZ2V0QW5pbWF0YWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0YWJsZSA9IHRoaXMubWFrZVRhcmdldEFuaW1hdGFibGUodGFyZ2V0LCB0cmFuc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgPSBhbmltYXRhYmxlLnRyYW5zaXRpb25FbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmlvcml0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkT3ZlcnJpZGVzW3ByaW9yaXR5XSA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGVja0Zvck5ld1ZhbHVlcyh0YXJnZXQpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdGFyZ2V0IHx8IHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIGlmICghcHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVRhcmdldFtrZXldID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh2YWx1ZVRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRpbmcuaGFzKGtleSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHZhbHVlVGFyZ2V0LCBfX2Fzc2lnbih7IGRlbGF5OiBkZWxheSB9LCB0cmFuc2l0aW9uKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsQW5pbWF0aW9ucyA9IFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uRW5kXHJcbiAgICAgICAgICAgID8gYWxsQW5pbWF0aW9ucy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFZhbHVlcyh0cmFuc2l0aW9uRW5kLCB7IHByaW9yaXR5OiBwcmlvcml0eSB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBhbGxBbmltYXRpb25zO1xyXG4gICAgfTtcclxuICAgIFZhbHVlQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLmFuaW1hdGVWYXJpYW50TGFiZWxzID0gZnVuY3Rpb24gKHZhcmlhbnRMYWJlbHMsIG9wdHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gX19zcHJlYWRBcnJheXModmFyaWFudExhYmVscykucmV2ZXJzZSgpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxhYmVsKSB7IHJldHVybiBfdGhpcy5hbmltYXRlVmFyaWFudChsYWJlbCwgb3B0cyk7IH0pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5hbmltYXRlVmFyaWFudCA9IGZ1bmN0aW9uICh2YXJpYW50TGFiZWwsIG9wdHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3aGVuID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRlbGF5Q2hpbGRyZW4gPSAwO1xyXG4gICAgICAgIHZhciBzdGFnZ2VyQ2hpbGRyZW4gPSAwO1xyXG4gICAgICAgIHZhciBzdGFnZ2VyRGlyZWN0aW9uID0gMTtcclxuICAgICAgICB2YXIgcHJpb3JpdHkgPSAob3B0cyAmJiBvcHRzLnByaW9yaXR5KSB8fCAwO1xyXG4gICAgICAgIHZhciB2YXJpYW50ID0gdGhpcy52YXJpYW50c1t2YXJpYW50TGFiZWxdO1xyXG4gICAgICAgIHZhciBnZXRBbmltYXRpb25zID0gdmFyaWFudFxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFuaW1hdGUodmFyaWFudCwgb3B0cyk7IH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfTtcclxuICAgICAgICB2YXIgZ2V0Q2hpbGRyZW5BbmltYXRpb25zID0gdGhpcy5jaGlsZHJlblxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hbmltYXRlQ2hpbGRyZW4odmFyaWFudExhYmVsLCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHByaW9yaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9O1xyXG4gICAgICAgIGlmICh2YXJpYW50ICYmIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnJlc29sdmVWYXJpYW50KHZhcmlhbnQpLnRyYW5zaXRpb247XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3aGVuID0gdHJhbnNpdGlvbi53aGVuIHx8IHdoZW47XHJcbiAgICAgICAgICAgICAgICBkZWxheUNoaWxkcmVuID0gdHJhbnNpdGlvbi5kZWxheUNoaWxkcmVuIHx8IGRlbGF5Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBzdGFnZ2VyQ2hpbGRyZW4gPSB0cmFuc2l0aW9uLnN0YWdnZXJDaGlsZHJlbiB8fCBzdGFnZ2VyQ2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBzdGFnZ2VyRGlyZWN0aW9uID1cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnN0YWdnZXJEaXJlY3Rpb24gfHwgc3RhZ2dlckRpcmVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2hlbikge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB3aGVuID09PSBcImJlZm9yZUNoaWxkcmVuXCJcclxuICAgICAgICAgICAgICAgID8gW2dldEFuaW1hdGlvbnMsIGdldENoaWxkcmVuQW5pbWF0aW9uc11cclxuICAgICAgICAgICAgICAgIDogW2dldENoaWxkcmVuQW5pbWF0aW9ucywgZ2V0QW5pbWF0aW9uc10sIGZpcnN0ID0gX2FbMF0sIGxhc3QgPSBfYVsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0KCkudGhlbihsYXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9ucygpLCBnZXRDaGlsZHJlbkFuaW1hdGlvbnMoKV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5hbmltYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAodmFyaWFudExhYmVsLCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKGRlbGF5Q2hpbGRyZW4gPT09IHZvaWQgMCkgeyBkZWxheUNoaWxkcmVuID0gMDsgfVxyXG4gICAgICAgIGlmIChzdGFnZ2VyQ2hpbGRyZW4gPT09IHZvaWQgMCkgeyBzdGFnZ2VyQ2hpbGRyZW4gPSAwOyB9XHJcbiAgICAgICAgaWYgKHN0YWdnZXJEaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBzdGFnZ2VyRGlyZWN0aW9uID0gMTsgfVxyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gMDsgfVxyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XHJcbiAgICAgICAgdmFyIG1heFN0YWdnZXJEdXJhdGlvbiA9ICh0aGlzLmNoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcclxuICAgICAgICB2YXIgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkgKiBzdGFnZ2VyQ2hpbGRyZW47IH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gbWF4U3RhZ2dlckR1cmF0aW9uIC0gaSAqIHN0YWdnZXJDaGlsZHJlbjsgfTtcclxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkQ29udHJvbHMsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGNoaWxkQ29udHJvbHMuYW5pbWF0ZVZhcmlhbnQodmFyaWFudExhYmVsLCB7XHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIFZhbHVlQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSB0aGlzLnByb3BzLm9uQW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgICAgb25BbmltYXRpb25TdGFydCAmJiBvbkFuaW1hdGlvblN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb25BbmltYXRpb25Db21wbGV0ZSA9IHRoaXMucHJvcHMub25BbmltYXRpb25Db21wbGV0ZTtcclxuICAgICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlICYmIG9uQW5pbWF0aW9uQ29tcGxldGUoKTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5jaGVja092ZXJyaWRlSXNBbmltYXRpbmcgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcclxuICAgICAgICB2YXIgbnVtT3ZlcnJpZGVzID0gdGhpcy5vdmVycmlkZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBwcmlvcml0eSArIDE7IGkgPCBudW1PdmVycmlkZXM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRPdmVycmlkZSA9IHRoaXMucmVzb2x2ZWRPdmVycmlkZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZE92ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzb2x2ZWRPdmVycmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUucmVzZXRJc0FuaW1hdGluZyA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gMDsgfVxyXG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcuY2xlYXIoKTtcclxuICAgICAgICAvLyBJZiB0aGlzIGlzbid0IHRoZSBoaWdoZXN0IHByaW9yaXR5IGdlc3R1cmUsIGJsb2NrIHRoZSBhbmltYXRpb25cclxuICAgICAgICAvLyBvZiBhbnl0aGluZyB0aGF0J3MgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkXHJcbiAgICAgICAgaWYgKHByaW9yaXR5IDwgdGhpcy5nZXRIaWdoZXN0UHJpb3JpdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrT3ZlcnJpZGVJc0FuaW1hdGluZyhwcmlvcml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJlc2V0SXNBbmltYXRpbmcocHJpb3JpdHkpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmFsdWVBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgY29udHJvbHMgb2YgYSBjaGlsZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gY29udHJvbHMgLVxyXG4gICAgICovXHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjb250cm9scykge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZChjb250cm9scyk7XHJcbiAgICAgICAgLy8gV2Ugc2V0IGNoaWxkIG92ZXJyaWRlcyB3aGVuIGBzZXRPdmVycmlkZWAgaXMgY2FsbGVkLCBidXQgYWxzbyBoYXZlIHRvIGRvIGl0IGhlcmVcclxuICAgICAgICAvLyBhcyB0aGUgZmlyc3QgdGltZSBgc2V0T3ZlcnJpZGVgIGlzIGNhbGxlZCBhbGwgdGhlIGNoaWxkcmVuIG1pZ2h0IG5vdCBoYXZlIGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIHRoaXMub3ZlcnJpZGVzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJyaWRlLCBpKSB7XHJcbiAgICAgICAgICAgIG92ZXJyaWRlICYmIGNvbnRyb2xzLnNldE92ZXJyaWRlKG92ZXJyaWRlLCBpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjb250cm9scykge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKGNvbnRyb2xzKTtcclxuICAgIH07XHJcbiAgICBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5yZXNldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmNsZWFyKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhbHVlQW5pbWF0aW9uQ29udHJvbHM7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBVc2UgY2FsbGJhY2sgZWl0aGVyIG9ubHkgb24gdGhlIGluaXRpYWwgcmVuZGVyIG9yIG9uIGFsbCByZW5kZXJzLiBJbiBjb25jdXJyZW50IG1vZGVcclxuICogdGhlIFwiaW5pdGlhbFwiIHJlbmRlciBtaWdodCBydW4gbXVsdGlwbGUgdGltZXNcclxuICpcclxuICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gcnVuXHJcbiAqIEBwYXJhbSBpc0luaXRpYWxPbmx5IC0gU2V0IHRvIGB0cnVlYCB0byBvbmx5IHJ1biBvbiBpbml0aWFsIHJlbmRlciwgb3IgYGZhbHNlYCBmb3IgYWxsIHJlbmRlcnMuIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVzZUluaXRpYWxPckV2ZXJ5UmVuZGVyKGNhbGxiYWNrLCBpc0luaXRpYWxPbmx5KSB7XHJcbiAgICBpZiAoaXNJbml0aWFsT25seSA9PT0gdm9pZCAwKSB7IGlzSW5pdGlhbE9ubHkgPSBmYWxzZTsgfVxyXG4gICAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IHVzZVJlZih0cnVlKTtcclxuICAgIGlmICghaXNJbml0aWFsT25seSB8fCAoaXNJbml0aWFsT25seSAmJiBpc0luaXRpYWxSZW5kZXIuY3VycmVudCkpIHtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgPSBmYWxzZTtcclxufVxuXG4vKipcclxuICogQ29udHJvbCBhbmltYXRpb25zIG9uIG9uZSBvciBtb3JlIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbnZhciBBbmltYXRpb25Db250cm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkNvbnRyb2xzKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhlIGhvc3QgY29tcG9uZW50IGhhcyBtb3VudGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVuZGluZyBhbmltYXRpb25zIHRoYXQgYXJlIHN0YXJ0ZWQgYmVmb3JlIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGxpbmtlZCBjb21wb25lbnQgYW5pbWF0aW9uIGNvbnRyb2xzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHZhcmlhbnRzIG9uIHRoaXMgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YXJpYW50cyAtIFRoZSB2YXJpYW50cyB0byBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnNldFZhcmlhbnRzID0gZnVuY3Rpb24gKHZhcmlhbnRzKSB7XHJcbiAgICAgICAgdGhpcy52YXJpYW50cyA9IHZhcmlhbnRzO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xzLnNldFZhcmlhbnRzKHZhcmlhbnRzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGRlZmF1bHQgdHJhbnNpdGlvbiBvbiB0aGlzIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2l0aW9uIC0gVGhlIGRlZmF1bHQgdHJhbnNpdGlvbiB0byBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnNldERlZmF1bHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scy5zZXREZWZhdWx0VHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgYSBjb21wb25lbnQncyBhbmltYXRpb24gY29udHJvbHMgdG8gdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJvbHMgLSBUaGUgY29udHJvbHMgdG8gc3Vic2NyaWJlXHJcbiAgICAgKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjb250cm9scykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5hZGQoY29udHJvbHMpO1xyXG4gICAgICAgIGlmICh0aGlzLnZhcmlhbnRzKVxyXG4gICAgICAgICAgICBjb250cm9scy5zZXRWYXJpYW50cyh0aGlzLnZhcmlhbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VHJhbnNpdGlvbilcclxuICAgICAgICAgICAgY29udHJvbHMuc2V0RGVmYXVsdFRyYW5zaXRpb24odGhpcy5kZWZhdWx0VHJhbnNpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbXBvbmVudENvbnRyb2xzLmRlbGV0ZShjb250cm9scyk7IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYW4gYW5pbWF0aW9uIG9uIGFsbCBsaW5rZWQgY29tcG9uZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICpcclxuICAgICAqIGBgYGpzeFxyXG4gICAgICogY29udHJvbHMuc3RhcnQoXCJ2YXJpYW50TGFiZWxcIilcclxuICAgICAqIGNvbnRyb2xzLnN0YXJ0KHtcclxuICAgICAqICAgeDogMCxcclxuICAgICAqICAgdHJhbnNpdGlvbjogeyBkdXJhdGlvbjogMSB9XHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gLSBQcm9wZXJ0aWVzIG9yIHZhcmlhbnQgbGFiZWwgdG8gYW5pbWF0ZSB0b1xyXG4gICAgICogQHBhcmFtIHRyYW5zaXRpb24gLSBPcHRpb25hbCBgdHJhbnN0aW9uYCB0byBhcHBseSB0byBhIHZhcmlhbnRcclxuICAgICAqIEByZXR1cm5zIC0gQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTW91bnRlZCkge1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uc18xID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBjb250cm9scy5zdGFydChkZWZpbml0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbk92ZXJyaWRlOiB0cmFuc2l0aW9uT3ZlcnJpZGUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uc18xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0FuaW1hdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBbZGVmaW5pdGlvbiwgdHJhbnNpdGlvbk92ZXJyaWRlXSxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRseSBzZXQgdG8gYSBzZXQgb2YgcHJvcGVydGllcyBvciBhIHZhcmlhbnQuXHJcbiAgICAgKlxyXG4gICAgICogYGBganN4XHJcbiAgICAgKiAvLyBXaXRoIHByb3BlcnRpZXNcclxuICAgICAqIGNvbnRyb2xzLnNldCh7IG9wYWNpdHk6IDAgfSlcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaXRoIHZhcmlhbnRzXHJcbiAgICAgKiBjb250cm9scy5zZXQoXCJoaWRkZW5cIilcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbHJlbWFya3NcclxuICAgICAqIFdlIGNvdWxkIHBlcmZvcm0gYSBzaW1pbGFyIHRyaWNrIHRvIGAuc3RhcnRgIHdoZXJlIHRoaXMgY2FuIGJlIGNhbGxlZCBiZWZvcmUgbW91bnRcclxuICAgICAqIGFuZCB3ZSBtYWludGFpbiBhIGxpc3Qgb2Ygb2YgcGVuZGluZyBhY3Rpb25zIHRoYXQgZ2V0IGFwcGxpZWQgb24gbW91bnQuIEJ1dCB0aGVcclxuICAgICAqIGV4cGVjdGF0aW9uIG9mIGBzZXRgIGlzIHRoYXQgaXQgaGFwcGVucyBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIHdvdWxkIGJlIGRpZmZpY3VsdFxyXG4gICAgICogdG8gZG8gYmVmb3JlIGFueSBjaGlsZHJlbiBoYXZlIGV2ZW4gYXR0YWNoZWQgdGhlbXNlbHZlcy4gSXQncyBhbHNvIHBvb3IgcHJhY3Rpc2VcclxuICAgICAqIGFuZCB3ZSBzaG91bGQgZGlzY291cmFnZSByZW5kZXItc3luY2hyb25vdXMgYC5zdGFydGAgY2FsbHMgcmF0aGVyIHRoYW4gbGVhbiBpbnRvIHRoaXMuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25Db250cm9scy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICBpbnZhcmlhbnQodGhpcy5oYXNNb3VudGVkLCBcImNvbnRyb2xzLnNldCgpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBoYXMgbW91bnRlZC4gQ29uc2lkZXIgY2FsbGluZyB3aXRoaW4gYSB1c2VFZmZlY3QgaG9vay5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Q29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xzLmFwcGx5KGRlZmluaXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYW5pbWF0aW9ucyBvbiBhbGwgbGlua2VkIGNvbXBvbmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYGBganN4XHJcbiAgICAgKiBjb250cm9scy5zdG9wKClcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9scykgeyByZXR1cm4gY29udHJvbHMuc3RvcCgpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2VzIHRoZSBhbmltYXRpb24gY29udHJvbHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkNvbnRyb2xzLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGFzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2EuYW5pbWF0aW9uLCByZXNvbHZlID0gX2EucmVzb2x2ZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXJ0LmFwcGx5KF90aGlzLCBhbmltYXRpb24pLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhbGwgY2hpbGQgYW5pbWF0aW9ucyB3aGVuIHRoZSBob3N0IGNvbXBvbmVudCB1bm1vdW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uQ29udHJvbHMucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oYXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuaW1hdGlvbkNvbnRyb2xzO1xyXG59KCkpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgYW5pbWF0aW9uQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQW5pbWF0aW9uQ29udHJvbHMoKTsgfTtcblxudmFyIFByZXNlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBNb3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XHJcbiAgICBzdGF0aWM6IGZhbHNlLFxyXG59KTtcclxudmFyIGlzVmFyaWFudExhYmVsID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHYpO1xyXG59O1xyXG52YXIgaXNBbmltYXRpb25Db250cm9scyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gdiBpbnN0YW5jZW9mIEFuaW1hdGlvbkNvbnRyb2xzO1xyXG59O1xyXG4vKipcclxuICogU2V0IHVwIHRoZSBjb250ZXh0IGZvciBjaGlsZHJlbiBtb3Rpb24gY29tcG9uZW50cy5cclxuICpcclxuICogV2UgYWxzbyB1c2UgdGhpcyBvcHBvcnR1bml0eSB0byBhcHBseSBgaW5pdGlhbGAgdmFsdWVzXHJcbiAqL1xyXG52YXIgdXNlTW90aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRDb250ZXh0LCBjb250cm9scywgdmFsdWVzLCBpc1N0YXRpYywgX2EpIHtcclxuICAgIGlmIChpc1N0YXRpYyA9PT0gdm9pZCAwKSB7IGlzU3RhdGljID0gZmFsc2U7IH1cclxuICAgIHZhciBpbml0aWFsID0gX2EuaW5pdGlhbCwgYW5pbWF0ZSA9IF9hLmFuaW1hdGUsIHZhcmlhbnRzID0gX2EudmFyaWFudHMsIHdoaWxlVGFwID0gX2Eud2hpbGVUYXAsIHdoaWxlSG92ZXIgPSBfYS53aGlsZUhvdmVyO1xyXG4gICAgdmFyIF9iO1xyXG4gICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcclxuICAgIC8vIE92ZXJyaWRlIGluaXRpYWwgd2l0aCB0aGF0IGZyb20gYSBwYXJlbnQgY29udGV4dCwgaWYgZGVmaW5lZFxyXG4gICAgaWYgKCgoX2IgPSBwcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbml0aWFsKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5pdGlhbCA9IHByZXNlbmNlQ29udGV4dC5pbml0aWFsO1xyXG4gICAgfVxyXG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcclxuICAgIGlmIChpbml0aWFsID09PSBmYWxzZSAmJiAhaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlKSkge1xyXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IGFuaW1hdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5pdGlhbCAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhY2sgbW91bnRlZCBzdGF0dXMgc28gY2hpbGRyZW4gY2FuIGRldGVjdCB3aGV0aGVyIHRoZXkgd2VyZSBwcmVzZW50IGR1cmluZyB0aGVpclxyXG4gICAgLy8gcGFyZW50J3MgZmlyc3QgcmVuZGVyXHJcbiAgICB2YXIgaGFzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICAvLyBXZSBwcm9wYWdhdGUgdGhpcyBjb21wb25lbnQncyBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzICppZiogd2UncmUgYmVpbmcgcHJvdmlkZWQgdmFyaWFudHMsXHJcbiAgICAvLyBpZiB3ZSdyZSBiZWluZyB1c2VkIHRvIGNvbnRyb2wgdmFyaWFudHMsIG9yIGlmIHdlJ3JlIGJlaW5nIHBhc3NlZCBhbmltYXRpb24gY29udHJvbHMuXHJcbiAgICAvLyBPdGhlcndpc2UgdGhpcyBjb21wb25lbnQgc2hvdWxkIGJlIFwiaW52aXNpYmxlXCIgdG8gdmFyaWFudCBwcm9wYWdhdGlvbi4gVGhpcyBpcyBhIHNsaWdodCBjb25jZXNzaW9uXHJcbiAgICAvLyB0byBGcmFtZXIgWCB3aGVyZSBldmVyeSBgRnJhbWVgIGlzIGEgYG1vdGlvbmAgY29tcG9uZW50IGFuZCBpdCBtaWdodCBiZSBpZiB3ZSBjaGFuZ2UgdGhhdCBpbiB0aGUgZnV0dXJlXHJcbiAgICAvLyB0aGF0IHRoaXMgcmVzdHJpY3Rpb24gaXMgcmVtb3ZlZC5cclxuICAgIHZhciBzaG91bGRQcm9wYWdhdGVDb250cm9scyA9IHZhcmlhbnRzIHx8XHJcbiAgICAgICAgaXNWYXJpYW50TGFiZWwoYW5pbWF0ZSkgfHxcclxuICAgICAgICBpc1ZhcmlhbnRMYWJlbCh3aGlsZVRhcCkgfHxcclxuICAgICAgICBpc1ZhcmlhbnRMYWJlbCh3aGlsZUhvdmVyKSB8fFxyXG4gICAgICAgIGlzQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0ZSk7XHJcbiAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCdzIGBpbml0aWFsYCBwcm9wIGlzIGEgdmFyaWFudCBsYWJlbCwgcHJvcGFnYXRlIGl0LiBPdGhlcndpc2UgcGFzcyB0aGUgcGFyZW50J3MuXHJcbiAgICB2YXIgdGFyZ2V0SW5pdGlhbCA9IGlzVmFyaWFudExhYmVsKGluaXRpYWxTdGF0ZSlcclxuICAgICAgICA/IGluaXRpYWxTdGF0ZVxyXG4gICAgICAgIDogcGFyZW50Q29udGV4dC5pbml0aWFsO1xyXG4gICAgLy8gSWYgdGhpcyBpcyBhIHZhcmlhbnQgdHJlZSB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgYGFuaW1hdGVgIHByb3AgaW4gY2FzZSBuZXcgY2hpbGRyZW4gYXJlIGFkZGVkIGFmdGVyXHJcbiAgICAvLyB0aGUgdHJlZSBpbml0aWFsbHkgYW5pbWF0ZXMuXHJcbiAgICB2YXIgdGFyZ2V0QW5pbWF0ZSA9IGlzVmFyaWFudExhYmVsKGFuaW1hdGUpXHJcbiAgICAgICAgPyBhbmltYXRlXHJcbiAgICAgICAgOiBwYXJlbnRDb250ZXh0LmFuaW1hdGU7XHJcbiAgICAvLyBPbmx5IGFsbG93IGBpbml0aWFsYCB0byB0cmlnZ2VyIGNvbnRleHQgcmUtcmVuZGVycyBpZiB0aGlzIGlzIGEgYHN0YXRpY2AgY29tcG9uZW50IChpZSB3ZSdyZSBvbiB0aGUgRnJhbWVyIGNhbnZhcylcclxuICAgIC8vIG9yIGluIGFub3RoZXIgbm9uLWFuaW1hdGlvbi9pbnRlcmFjdGlvbiBlbnZpcm9ubWVudC5cclxuICAgIHZhciBpbml0aWFsRGVwZW5kZW5jeSA9IGlzU3RhdGljID8gdGFyZ2V0SW5pdGlhbCA6IG51bGw7XHJcbiAgICAvLyBPbmx5IGFsbG93IGBhbmltYXRlYCB0byB0cmlnZ2VyIGNvbnRleHQgcmUtcmVuZGVycyBpZiBpdCdzIGEgdmFyaWFudCBsYWJlbC4gSWYgdGhpcyBpcyBhbiBhcnJheSBvZlxyXG4gICAgLy8gdmFyaWFudCBsYWJlbHMgdGhlcmUncyBwcm9iYWJseSBhbiBvcHRpbWlzYXRpb24gdG8gZGVlcC1jb21wYXJlIGJ1dCBpdCBtaWdodCBiZSBhbiBvdmVyLW9wdGltaXNhdGlvbi5cclxuICAgIC8vIFdlIHdhbnQgdG8gZG8gdGhpcyBhcyB3ZSByZWx5IG9uIFJlYWN0J3MgY29tcG9uZW50IHJlbmRlcmluZyBvcmRlciBlYWNoIHJlbmRlciBjeWNsZSB0byBkZXRlcm1pbmVcclxuICAgIC8vIHRoZSBuZXcgb3JkZXIgb2YgYW55IGNoaWxkIGNvbXBvbmVudHMgZm9yIHRoZSBgc3RhZ2dlckNoaWxkcmVuYCBmdW5jdGlvbmFsaXR5LlxyXG4gICAgdmFyIGFuaW1hdGVEZXBlbmRlbmN5ID0gc2hvdWxkUHJvcGFnYXRlQ29udHJvbHMgJiYgaXNWYXJpYW50TGFiZWwodGFyZ2V0QW5pbWF0ZSlcclxuICAgICAgICA/IHRhcmdldEFuaW1hdGVcclxuICAgICAgICA6IG51bGw7XHJcbiAgICAvLyBUaGUgY29udGV4dCB0byBwcm92aWRlIHRvIHRoZSBjaGlsZC4gV2UgYHVzZU1lbW9gIGJlY2F1c2UgYWx0aG91Z2ggYGNvbnRyb2xzYCBhbmQgYGluaXRpYWxgIGFyZVxyXG4gICAgLy8gdW5saWtlbHkgdG8gY2hhbmdlLCBieSBtYWtpbmcgdGhlIGNvbnRleHQgYW4gb2JqZWN0IGl0J2xsIGJlIGNvbnNpZGVyZWQgYSBuZXcgdmFsdWUgZXZlcnkgcmVuZGVyLlxyXG4gICAgLy8gU28gYWxsIGNoaWxkIG1vdGlvbiBjb21wb25lbnRzIHdpbGwgcmUtcmVuZGVyIGFzIGEgcmVzdWx0LlxyXG4gICAgdmFyIGNvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgY29udHJvbHM6IHNob3VsZFByb3BhZ2F0ZUNvbnRyb2xzXHJcbiAgICAgICAgICAgID8gY29udHJvbHNcclxuICAgICAgICAgICAgOiBwYXJlbnRDb250ZXh0LmNvbnRyb2xzLFxyXG4gICAgICAgIGluaXRpYWw6IHRhcmdldEluaXRpYWwsXHJcbiAgICAgICAgYW5pbWF0ZTogdGFyZ2V0QW5pbWF0ZSxcclxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcclxuICAgICAgICBoYXNNb3VudGVkOiBoYXNNb3VudGVkLFxyXG4gICAgICAgIGlzUmVkdWNlZE1vdGlvbjogcGFyZW50Q29udGV4dC5pc1JlZHVjZWRNb3Rpb24sXHJcbiAgICB9KTsgfSwgW2luaXRpYWxEZXBlbmRlbmN5LCBhbmltYXRlRGVwZW5kZW5jeSwgcGFyZW50Q29udGV4dC5pc1JlZHVjZWRNb3Rpb25dKTtcclxuICAgIC8vIFVwZGF0ZSB0aGUgYHN0YXRpY2AgcHJvcGVydHkgZXZlcnkgcmVuZGVyLiBUaGlzIGlzIHVubGlrZWx5IHRvIGNoYW5nZSBidXQgYWxzbyBlc3NlbnRpYWxseSBmcmVlLlxyXG4gICAgY29udGV4dC5zdGF0aWMgPSBpc1N0YXRpYztcclxuICAgIC8vIFNldCBpbml0aWFsIHN0YXRlLiBJZiB0aGlzIGlzIGEgc3RhdGljIGNvbXBvbmVudCAoaWUgaW4gRnJhbWVyIGNhbnZhcyksIHJlc3BvbmQgdG8gdXBkYXRlc1xyXG4gICAgLy8gaW4gYGluaXRpYWxgLlxyXG4gICAgdXNlSW5pdGlhbE9yRXZlcnlSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbml0aWFsVG9BcHBseSA9IGluaXRpYWxTdGF0ZSB8fCBwYXJlbnRDb250ZXh0LmluaXRpYWw7XHJcbiAgICAgICAgaW5pdGlhbFRvQXBwbHkgJiYgY29udHJvbHMuYXBwbHkoaW5pdGlhbFRvQXBwbHkpO1xyXG4gICAgfSwgIWlzU3RhdGljKTtcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaGFzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59O1xuXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbXBlcmF0aXZlIHNldCBvZiBjb250cm9scyB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgYWxsb3dzIGEgY29uc29saWRhdGVkLCB1bmlmb3JtIEFQSSBmb3IgYW5pbWF0aW9ucywgdG8gYmUgdHJpZ2dlcmVkIGJ5IG90aGVyIEFQSXMgbGlrZSB0aGUgYGFuaW1hdGVgIHByb3AsIG9yIHRoZSBnZXN0dXJlIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVzXHJcbiAqIEBwYXJhbSBwcm9wc1xyXG4gKiBAcGFyYW0gcmVmXHJcbiAqIEBwYXJhbSBzdWJzY3JpYmVUb1BhcmVudENvbnRyb2xzXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlVmFsdWVBbmltYXRpb25Db250cm9scyhjb25maWcsIHByb3BzLCBzdWJzY3JpYmVUb1BhcmVudENvbnRyb2xzKSB7XHJcbiAgICB2YXIgdmFyaWFudHMgPSBwcm9wcy52YXJpYW50cywgdHJhbnNpdGlvbiA9IHByb3BzLnRyYW5zaXRpb247XHJcbiAgICB2YXIgcGFyZW50Q29udHJvbHMgPSB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpLmNvbnRyb2xzO1xyXG4gICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcclxuICAgIHZhciBjb250cm9scyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBWYWx1ZUFuaW1hdGlvbkNvbnRyb2xzKGNvbmZpZyk7IH0pO1xyXG4gICAgLy8gUmVzZXQgYW5kIHJlc3Vic2NyaWJlIGNoaWxkcmVuIGV2ZXJ5IHJlbmRlciB0byBlbnN1cmUgc3RhZ2dlciBvcmRlciBpcyBjb3JyZWN0XHJcbiAgICBpZiAoIXByZXNlbmNlQ29udGV4dCB8fCBwcmVzZW5jZUNvbnRleHQuaXNQcmVzZW50KSB7XHJcbiAgICAgICAgY29udHJvbHMucmVzZXRDaGlsZHJlbigpO1xyXG4gICAgICAgIGNvbnRyb2xzLnNldFByb3BzKHByb3BzKTtcclxuICAgICAgICBjb250cm9scy5zZXRWYXJpYW50cyh2YXJpYW50cyk7XHJcbiAgICAgICAgY29udHJvbHMuc2V0RGVmYXVsdFRyYW5zaXRpb24odHJhbnNpdGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBoYXZlIHRvIHN1YnNjcmliZSB0byB0aGUgcGFyZW50IGNvbnRyb2xzIHdpdGhpbiBhIHVzZUVmZmVjdCByYXRoZXIgdGhhbiBkdXJpbmcgcmVuZGVyLFxyXG4gICAgLy8gYXNcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHN1YnNjcmliZVRvUGFyZW50Q29udHJvbHMgJiYgcGFyZW50Q29udHJvbHMpIHtcclxuICAgICAgICAgICAgcGFyZW50Q29udHJvbHMuYWRkQ2hpbGQoY29udHJvbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlIHRvIG9uQW5pbWF0aW9uQ29tcGxldGUgZnJvbSBjb250cm9scy4gQWxsIHRoZSBNb3Rpb25WYWx1ZXNcclxuICAgICAgICAgICAgLy8gYXJlIHVuc3Vic2NyaWJlZCBmcm9tIHRoaXMgY29tcG9uZW50IHNlcGFyYXRlbHkuIFdlIGxldCBhbmltYXRpb25zIHJ1biBvdXRcclxuICAgICAgICAgICAgLy8gYXMgdGhleSBtaWdodCBiZSBhbmltYXRpbmcgb3RoZXIgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgdmFyIG9uQW5pbWF0aW9uQ29tcGxldGUgPSBwcm9wcy5vbkFuaW1hdGlvbkNvbXBsZXRlLCB1bm1vdW50UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uQW5pbWF0aW9uQ29tcGxldGVcIl0pO1xyXG4gICAgICAgICAgICBjb250cm9scy5zZXRQcm9wcyh1bm1vdW50UHJvcHMpO1xyXG4gICAgICAgICAgICBwYXJlbnRDb250cm9scyAmJiBwYXJlbnRDb250cm9scy5yZW1vdmVDaGlsZChjb250cm9scyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiBjb250cm9scztcclxufVxuXG52YXIgY2hlY2tTaG91bGRJbmhlcml0VmFyaWFudCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGFuaW1hdGUgPSBfYS5hbmltYXRlLCB2YXJpYW50cyA9IF9hLnZhcmlhbnRzLCBfYiA9IF9hLmluaGVyaXQsIGluaGVyaXQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xyXG4gICAgcmV0dXJuIChpbmhlcml0ICYmXHJcbiAgICAgICAgISF2YXJpYW50cyAmJlxyXG4gICAgICAgICghYW5pbWF0ZSB8fCBhbmltYXRlIGluc3RhbmNlb2YgQW5pbWF0aW9uQ29udHJvbHMpKTtcclxufTtcblxuLyoqXHJcbiAqIFVzZXMgdGhlIHJlZiB0aGF0IGlzIHBhc3NlZCBpbiwgb3IgY3JlYXRlcyBhIG5ldyBvbmVcclxuICogQHBhcmFtIGV4dGVybmFsIC0gRXh0ZXJuYWwgcmVmXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlRXh0ZXJuYWxSZWYoZXh0ZXJuYWxSZWYpIHtcclxuICAgIC8vIFdlJ3JlIGNvbmRpdGlvbmFsbHkgY2FsbGluZyBgdXNlUmVmYCBoZXJlIHdoaWNoIGlzIHNvcnQgb2YgbmF1Z2h0eSBhcyBob29rc1xyXG4gICAgLy8gc2hvdWxkbid0IGJlIGNhbGxlZCBjb25kaXRpb25hbGx5LiBIb3dldmVyLCBGcmFtZXIgTW90aW9uIHdpbGwgYnJlYWsgaWYgdGhpc1xyXG4gICAgLy8gY29uZGl0aW9uIGNoYW5nZXMgYW55d2F5LiBJdCBtaWdodCBiZSBwb3NzaWJsZSB0byB1c2UgYW4gaW52YXJpYW50IGhlcmUgdG9cclxuICAgIC8vIG1ha2UgaXQgZXhwbGljaXQsIGJ1dCBJIGV4cGVjdCBjaGFuZ2luZyBgcmVmYCBpcyBub3Qgbm9ybWFsIGJlaGF2aW91ci5cclxuICAgIHZhciByZWYgPSAhZXh0ZXJuYWxSZWYgfHwgdHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/IHVzZVJlZihudWxsKVxyXG4gICAgICAgIDogZXh0ZXJuYWxSZWY7XHJcbiAgICAvLyBIYW5kbGUgYHJlZmAgZnVuY3Rpb25zLiBBZ2FpbiwgY2FsbGluZyB0aGUgaG9vayBjb25kaXRpb25hbGx5IGlzIGtpbmQgb2YgbmF1Z2h0eVxyXG4gICAgLy8gYnV0IGByZWZgIHR5cGVzIGNoYW5naW5nIGJldHdlZW4gcmVuZGVycyB3b3VsZCBicmVhayBNb3Rpb24gYW55d2F5LiBJZiB3ZSByZWNlaXZlXHJcbiAgICAvLyBidWcgcmVwb3J0cyBhYm91dCB0aGlzLCB3ZSBzaG91bGQgdHJhY2sgdGhlIHByb3ZpZGVkIHJlZiBhbmQgdGhyb3cgYW4gaW52YXJpYW50XHJcbiAgICAvLyByYXRoZXIgdGhhbiBtb3ZlIHRoZSBjb25kaXRpb25hbCB0byBpbnNpZGUgdGhlIHVzZUVmZmVjdCBhcyB0aGlzIHdpbGwgYmUgZmlyZWRcclxuICAgIC8vIGZvciBldmVyeSBGcmFtZSBjb21wb25lbnQgd2l0aGluIEZyYW1lci5cclxuICAgIGlmIChleHRlcm5hbFJlZiAmJiB0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsUmVmKHJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4dGVybmFsUmVmKG51bGwpOyB9O1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWY7XHJcbn1cblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIGNyZWF0ZU1vdGlvbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGdldFZhbHVlQ29udHJvbHNDb25maWcgPSBfYS5nZXRWYWx1ZUNvbnRyb2xzQ29uZmlnLCBsb2FkRnVuY3Rpb25hbGl0eUNvbXBvbmVudHMgPSBfYS5sb2FkRnVuY3Rpb25hbGl0eUNvbXBvbmVudHMsIHJlbmRlckNvbXBvbmVudCA9IF9hLnJlbmRlckNvbXBvbmVudDtcclxuICAgIGZ1bmN0aW9uIE1vdGlvbkNvbXBvbmVudChwcm9wcywgZXh0ZXJuYWxSZWYpIHtcclxuICAgICAgICB2YXIgcmVmID0gdXNlRXh0ZXJuYWxSZWYoZXh0ZXJuYWxSZWYpO1xyXG4gICAgICAgIHZhciBwYXJlbnRDb250ZXh0ID0gdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcclxuICAgICAgICB2YXIgaXNTdGF0aWMgPSBwYXJlbnRDb250ZXh0LnN0YXRpYyB8fCBwcm9wcy5zdGF0aWMgfHwgZmFsc2U7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHVzZU1vdGlvblZhbHVlcyhwcm9wcyk7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdXNlTW90aW9uU3R5bGVzKHZhbHVlcywgcHJvcHMuc3R5bGUsIGlzU3RhdGljLCBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMpO1xyXG4gICAgICAgIHZhciBzaG91bGRJbmhlcml0VmFyaWFudCA9IGNoZWNrU2hvdWxkSW5oZXJpdFZhcmlhbnQocHJvcHMpO1xyXG4gICAgICAgIHZhciBjb250cm9sc0NvbmZpZyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlQ29udHJvbHNDb25maWcocmVmLCB2YWx1ZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBjb250cm9scyA9IHVzZVZhbHVlQW5pbWF0aW9uQ29udHJvbHMoY29udHJvbHNDb25maWcsIHByb3BzLCBzaG91bGRJbmhlcml0VmFyaWFudCk7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB1c2VNb3Rpb25Db250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRyb2xzLCB2YWx1ZXMsIGlzU3RhdGljLCBwcm9wcyk7XHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uYWxpdHkgPSBpc1N0YXRpY1xyXG4gICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgOiBsb2FkRnVuY3Rpb25hbGl0eUNvbXBvbmVudHMocmVmLCB2YWx1ZXMsIHByb3BzLCBwYXJlbnRDb250ZXh0LCBjb250cm9scywgc2hvdWxkSW5oZXJpdFZhcmlhbnQpO1xyXG4gICAgICAgIHZhciByZW5kZXJlZENvbXBvbmVudCA9IHJlbmRlckNvbXBvbmVudChyZWYsIHN0eWxlLCB2YWx1ZXMsIHByb3BzLCBpc1N0YXRpYyk7XHJcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KE1vdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgcmVuZGVyZWRDb21wb25lbnQpLFxyXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChNb3VudCwgeyBpbm5lclJlZjogcmVmLCB2YWx1ZXM6IHZhbHVlcywgaXNTdGF0aWM6IGlzU3RhdGljIH0pLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eSkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3J3YXJkUmVmKE1vdGlvbkNvbXBvbmVudCk7XHJcbn07XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBodG1sRWxlbWVudHMgPSBbXHJcbiAgICBcImFcIixcclxuICAgIFwiYWJiclwiLFxyXG4gICAgXCJhZGRyZXNzXCIsXHJcbiAgICBcImFyZWFcIixcclxuICAgIFwiYXJ0aWNsZVwiLFxyXG4gICAgXCJhc2lkZVwiLFxyXG4gICAgXCJhdWRpb1wiLFxyXG4gICAgXCJiXCIsXHJcbiAgICBcImJhc2VcIixcclxuICAgIFwiYmRpXCIsXHJcbiAgICBcImJkb1wiLFxyXG4gICAgXCJiaWdcIixcclxuICAgIFwiYmxvY2txdW90ZVwiLFxyXG4gICAgXCJib2R5XCIsXHJcbiAgICBcImJyXCIsXHJcbiAgICBcImJ1dHRvblwiLFxyXG4gICAgXCJjYW52YXNcIixcclxuICAgIFwiY2FwdGlvblwiLFxyXG4gICAgXCJjaXRlXCIsXHJcbiAgICBcImNvZGVcIixcclxuICAgIFwiY29sXCIsXHJcbiAgICBcImNvbGdyb3VwXCIsXHJcbiAgICBcImRhdGFcIixcclxuICAgIFwiZGF0YWxpc3RcIixcclxuICAgIFwiZGRcIixcclxuICAgIFwiZGVsXCIsXHJcbiAgICBcImRldGFpbHNcIixcclxuICAgIFwiZGZuXCIsXHJcbiAgICBcImRpYWxvZ1wiLFxyXG4gICAgXCJkaXZcIixcclxuICAgIFwiZGxcIixcclxuICAgIFwiZHRcIixcclxuICAgIFwiZW1cIixcclxuICAgIFwiZW1iZWRcIixcclxuICAgIFwiZmllbGRzZXRcIixcclxuICAgIFwiZmlnY2FwdGlvblwiLFxyXG4gICAgXCJmaWd1cmVcIixcclxuICAgIFwiZm9vdGVyXCIsXHJcbiAgICBcImZvcm1cIixcclxuICAgIFwiaDFcIixcclxuICAgIFwiaDJcIixcclxuICAgIFwiaDNcIixcclxuICAgIFwiaDRcIixcclxuICAgIFwiaDVcIixcclxuICAgIFwiaDZcIixcclxuICAgIFwiaGVhZFwiLFxyXG4gICAgXCJoZWFkZXJcIixcclxuICAgIFwiaGdyb3VwXCIsXHJcbiAgICBcImhyXCIsXHJcbiAgICBcImh0bWxcIixcclxuICAgIFwiaVwiLFxyXG4gICAgXCJpZnJhbWVcIixcclxuICAgIFwiaW1nXCIsXHJcbiAgICBcImlucHV0XCIsXHJcbiAgICBcImluc1wiLFxyXG4gICAgXCJrYmRcIixcclxuICAgIFwia2V5Z2VuXCIsXHJcbiAgICBcImxhYmVsXCIsXHJcbiAgICBcImxlZ2VuZFwiLFxyXG4gICAgXCJsaVwiLFxyXG4gICAgXCJsaW5rXCIsXHJcbiAgICBcIm1haW5cIixcclxuICAgIFwibWFwXCIsXHJcbiAgICBcIm1hcmtcIixcclxuICAgIFwibWVudVwiLFxyXG4gICAgXCJtZW51aXRlbVwiLFxyXG4gICAgXCJtZXRhXCIsXHJcbiAgICBcIm1ldGVyXCIsXHJcbiAgICBcIm5hdlwiLFxyXG4gICAgXCJub3NjcmlwdFwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwib2xcIixcclxuICAgIFwib3B0Z3JvdXBcIixcclxuICAgIFwib3B0aW9uXCIsXHJcbiAgICBcIm91dHB1dFwiLFxyXG4gICAgXCJwXCIsXHJcbiAgICBcInBhcmFtXCIsXHJcbiAgICBcInBpY3R1cmVcIixcclxuICAgIFwicHJlXCIsXHJcbiAgICBcInByb2dyZXNzXCIsXHJcbiAgICBcInFcIixcclxuICAgIFwicnBcIixcclxuICAgIFwicnRcIixcclxuICAgIFwicnVieVwiLFxyXG4gICAgXCJzXCIsXHJcbiAgICBcInNhbXBcIixcclxuICAgIFwic2NyaXB0XCIsXHJcbiAgICBcInNlY3Rpb25cIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcInNtYWxsXCIsXHJcbiAgICBcInNvdXJjZVwiLFxyXG4gICAgXCJzcGFuXCIsXHJcbiAgICBcInN0cm9uZ1wiLFxyXG4gICAgXCJzdHlsZVwiLFxyXG4gICAgXCJzdWJcIixcclxuICAgIFwic3VtbWFyeVwiLFxyXG4gICAgXCJzdXBcIixcclxuICAgIFwidGFibGVcIixcclxuICAgIFwidGJvZHlcIixcclxuICAgIFwidGRcIixcclxuICAgIFwidGV4dGFyZWFcIixcclxuICAgIFwidGZvb3RcIixcclxuICAgIFwidGhcIixcclxuICAgIFwidGhlYWRcIixcclxuICAgIFwidGltZVwiLFxyXG4gICAgXCJ0aXRsZVwiLFxyXG4gICAgXCJ0clwiLFxyXG4gICAgXCJ0cmFja1wiLFxyXG4gICAgXCJ1XCIsXHJcbiAgICBcInVsXCIsXHJcbiAgICBcInZhclwiLFxyXG4gICAgXCJ2aWRlb1wiLFxyXG4gICAgXCJ3YnJcIixcclxuICAgIFwid2Vidmlld1wiLFxyXG5dO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgc3ZnRWxlbWVudHMgPSBbXHJcbiAgICBcImFuaW1hdGVcIixcclxuICAgIFwiY2lyY2xlXCIsXHJcbiAgICBcImNsaXBQYXRoXCIsXHJcbiAgICBcImRlZnNcIixcclxuICAgIFwiZGVzY1wiLFxyXG4gICAgXCJlbGxpcHNlXCIsXHJcbiAgICBcImZlQmxlbmRcIixcclxuICAgIFwiZmVDb2xvck1hdHJpeFwiLFxyXG4gICAgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXHJcbiAgICBcImZlQ29tcG9zaXRlXCIsXHJcbiAgICBcImZlQ29udm9sdmVNYXRyaXhcIixcclxuICAgIFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcclxuICAgIFwiZmVEaXNwbGFjZW1lbnRNYXBcIixcclxuICAgIFwiZmVEaXN0YW50TGlnaHRcIixcclxuICAgIFwiZmVEcm9wU2hhZG93XCIsXHJcbiAgICBcImZlRmxvb2RcIixcclxuICAgIFwiZmVGdW5jQVwiLFxyXG4gICAgXCJmZUZ1bmNCXCIsXHJcbiAgICBcImZlRnVuY0dcIixcclxuICAgIFwiZmVGdW5jUlwiLFxyXG4gICAgXCJmZUdhdXNzaWFuQmx1clwiLFxyXG4gICAgXCJmZUltYWdlXCIsXHJcbiAgICBcImZlTWVyZ2VcIixcclxuICAgIFwiZmVNZXJnZU5vZGVcIixcclxuICAgIFwiZmVNb3JwaG9sb2d5XCIsXHJcbiAgICBcImZlT2Zmc2V0XCIsXHJcbiAgICBcImZlUG9pbnRMaWdodFwiLFxyXG4gICAgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIixcclxuICAgIFwiZmVTcG90TGlnaHRcIixcclxuICAgIFwiZmVUaWxlXCIsXHJcbiAgICBcImZlVHVyYnVsZW5jZVwiLFxyXG4gICAgXCJmaWx0ZXJcIixcclxuICAgIFwiZm9yZWlnbk9iamVjdFwiLFxyXG4gICAgXCJnXCIsXHJcbiAgICBcImltYWdlXCIsXHJcbiAgICBcImxpbmVcIixcclxuICAgIFwibGluZWFyR3JhZGllbnRcIixcclxuICAgIFwibWFya2VyXCIsXHJcbiAgICBcIm1hc2tcIixcclxuICAgIFwibWV0YWRhdGFcIixcclxuICAgIFwicGF0aFwiLFxyXG4gICAgXCJwYXR0ZXJuXCIsXHJcbiAgICBcInBvbHlnb25cIixcclxuICAgIFwicG9seWxpbmVcIixcclxuICAgIFwicmFkaWFsR3JhZGllbnRcIixcclxuICAgIFwicmVjdFwiLFxyXG4gICAgXCJzdG9wXCIsXHJcbiAgICBcInN2Z1wiLFxyXG4gICAgXCJzd2l0Y2hcIixcclxuICAgIFwic3ltYm9sXCIsXHJcbiAgICBcInRleHRcIixcclxuICAgIFwidGV4dFBhdGhcIixcclxuICAgIFwidHNwYW5cIixcclxuICAgIFwidXNlXCIsXHJcbiAgICBcInZpZXdcIixcclxuXTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIE1vdGlvblBsdWdpbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcclxuICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogZnVuY3Rpb24gKHApIHsgcmV0dXJuIHA7IH0sXHJcbn0pO1xyXG4vKipcclxuICogQHJlbWFya3MgRm9yIG5vdyBJIHRoaW5rIHRoaXMgc2hvdWxkIHJlbWFpbiBhIHByaXZhdGUgQVBJIGZvciBvdXIgb3duIHVzZVxyXG4gKiB1bnRpbCB3ZSBjYW4gZmlndXJlIG91dCBhIG5pY2VyIHdheSBvZiBhbGxvd2luZyBwZW9wbGUgdG8gYWRkIHRoZXNlXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gTW90aW9uUGx1Z2lucyhfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIHByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiXSk7XHJcbiAgICB2YXIgcGx1Z2luQ29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uUGx1Z2luQ29udGV4dCk7XHJcbiAgICB2YXIgdmFsdWUgPSB1c2VSZWYoX19hc3NpZ24oe30sIHBsdWdpbkNvbnRleHQpKS5jdXJyZW50O1xyXG4gICAgLy8gTXV0YXRpdmUgdG8gcHJldmVudCB0cmlnZ2VyaW5nIHJlcmVuZGVycyBpbiBhbGwgbGlzdGVuaW5nXHJcbiAgICAvLyBjb21wb25lbnRzIGV2ZXJ5IHRpbWUgdGhpcyBjb21wb25lbnQgcmVuZGVyc1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgdmFsdWVba2V5XSA9IHByb3BzW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW90aW9uUGx1Z2luQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUgfSwgY2hpbGRyZW4pKTtcclxufVxuXG5mdW5jdGlvbiB1c2VVbm1vdW50RWZmZWN0KGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH07IH0sIFtdKTtcclxufVxuXG5mdW5jdGlvbiBhZGREb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFoYW5kbGVyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTsgfTtcclxufVxyXG4vKipcclxuICogQXR0YWNoZXMgYW4gZXZlbnQgbGlzdGVuZXIgZGlyZWN0bHkgdG8gdGhlIHByb3ZpZGVkIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBCeXBhc3NpbmcgUmVhY3QncyBldmVudCBzeXN0ZW0gY2FuIGJlIGRlc2lyYWJsZSwgZm9yIGluc3RhbmNlIHdoZW4gYXR0YWNoaW5nIG5vbi1wYXNzaXZlXHJcbiAqIGV2ZW50IGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogY29uc3QgcmVmID0gdXNlUmVmKG51bGwpXHJcbiAqXHJcbiAqIHVzZURvbUV2ZW50KHJlZiwgJ3doZWVsJywgb25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxyXG4gKlxyXG4gKiByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBSZWFjdC5SZWZPYmplY3QgdGhhdCdzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gYmluZCB0aGUgbGlzdGVuZXIgdG8uXHJcbiAqIEBwYXJhbSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB5b3Ugd2FudCBsaXN0ZW4gZm9yLlxyXG4gKiBAcGFyYW0gaGFuZGxlciAtIEZ1bmN0aW9uIHRvIGZpcmUgd2hlbiByZWNlaXZpbmcgdGhlIGV2ZW50LlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBgRXZlbnQuYWRkRXZlbnRMaXN0ZW5lcmAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIgJiYgZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnNdKTtcclxufVxuXG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcclxuICAgIC8vIFBvaW50ZXJFdmVudCBpbmhlcml0cyBmcm9tIE1vdXNlRXZlbnQgc28gd2UgY2FuJ3QgdXNlIGEgc3RyYWlnaHQgaW5zdGFuY2VvZiBjaGVjay5cclxuICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICEhKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcclxufVxyXG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcclxuICAgIHZhciBoYXNUb3VjaGVzID0gISFldmVudC50b3VjaGVzO1xyXG4gICAgcmV0dXJuIGhhc1RvdWNoZXM7XHJcbn1cblxuLyoqXHJcbiAqIEZpbHRlcnMgb3V0IGV2ZW50cyBub3QgYXR0YWNoZWQgdG8gdGhlIHByaW1hcnkgcG9pbnRlciAoY3VycmVudGx5IGxlZnQgbW91c2UgYnV0dG9uKVxyXG4gKiBAcGFyYW0gZXZlbnRIYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJQcmltYXJ5UG9pbnRlcihldmVudEhhbmRsZXIpIHtcclxuICAgIGlmICghZXZlbnRIYW5kbGVyKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGlzTW91c2VFdmVudCA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudDtcclxuICAgICAgICB2YXIgaXNQcmltYXJ5UG9pbnRlciA9ICFpc01vdXNlRXZlbnQgfHxcclxuICAgICAgICAgICAgKGlzTW91c2VFdmVudCAmJiBldmVudC5idXR0b24gPT09IDApO1xyXG4gICAgICAgIGlmIChpc1ByaW1hcnlQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG52YXIgZGVmYXVsdFBhZ2VQb2ludCA9IHsgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XHJcbmZ1bmN0aW9uIHBvaW50RnJvbVRvdWNoKGUpIHtcclxuICAgIHZhciBwcmltYXJ5VG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgIHZhciBfYSA9IHByaW1hcnlUb3VjaCB8fCBkZWZhdWx0UGFnZVBvaW50LCBwYWdlWCA9IF9hLnBhZ2VYLCBwYWdlWSA9IF9hLnBhZ2VZO1xyXG4gICAgcmV0dXJuIHsgeDogcGFnZVgsIHk6IHBhZ2VZIH07XHJcbn1cclxuZnVuY3Rpb24gcG9pbnRGcm9tTW91c2UoX2EpIHtcclxuICAgIHZhciBfYiA9IF9hLnBhZ2VYLCBwYWdlWCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gX2EucGFnZVksIHBhZ2VZID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcclxuICAgIHJldHVybiB7IHg6IHBhZ2VYLCB5OiBwYWdlWSB9O1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9pbnQ6IGlzVG91Y2hFdmVudChldmVudClcclxuICAgICAgICAgICAgPyBwb2ludEZyb21Ub3VjaChldmVudClcclxuICAgICAgICAgICAgOiBwb2ludEZyb21Nb3VzZShldmVudCksXHJcbiAgICB9O1xyXG59XHJcbnZhciB3cmFwSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlcikge1xyXG4gICAgaWYgKHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyID09PSB2b2lkIDApIHsgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPSBmYWxzZTsgfVxyXG4gICAgaWYgKCFoYW5kbGVyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpOyB9O1xyXG4gICAgcmV0dXJuIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyXHJcbiAgICAgICAgPyBmaWx0ZXJQcmltYXJ5UG9pbnRlcihsaXN0ZW5lcilcclxuICAgICAgICA6IGxpc3RlbmVyO1xyXG59O1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcclxuLy8gV2UgY2hlY2sgZm9yIGV2ZW50IHN1cHBvcnQgdmlhIGZ1bmN0aW9ucyBpbiBjYXNlIHRoZXkndmUgYmVlbiBtb2NrZWQgYnkgYSB0ZXN0aW5nIHN1aXRlLlxyXG52YXIgc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcclxufTtcclxudmFyIHN1cHBvcnRzVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XHJcbn07XHJcbnZhciBzdXBwb3J0c01vdXNlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XHJcbn07XG5cbnZhciBtb3VzZUV2ZW50TmFtZXMgPSB7XHJcbiAgICBwb2ludGVyZG93bjogXCJtb3VzZWRvd25cIixcclxuICAgIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxyXG4gICAgcG9pbnRlcnVwOiBcIm1vdXNldXBcIixcclxuICAgIHBvaW50ZXJjYW5jZWw6IFwibW91c2VjYW5jZWxcIixcclxuICAgIHBvaW50ZXJvdmVyOiBcIm1vdXNlb3ZlclwiLFxyXG4gICAgcG9pbnRlcm91dDogXCJtb3VzZW91dFwiLFxyXG4gICAgcG9pbnRlcmVudGVyOiBcIm1vdXNlZW50ZXJcIixcclxuICAgIHBvaW50ZXJsZWF2ZTogXCJtb3VzZWxlYXZlXCIsXHJcbn07XHJcbnZhciB0b3VjaEV2ZW50TmFtZXMgPSB7XHJcbiAgICBwb2ludGVyZG93bjogXCJ0b3VjaHN0YXJ0XCIsXHJcbiAgICBwb2ludGVybW92ZTogXCJ0b3VjaG1vdmVcIixcclxuICAgIHBvaW50ZXJ1cDogXCJ0b3VjaGVuZFwiLFxyXG4gICAgcG9pbnRlcmNhbmNlbDogXCJ0b3VjaGNhbmNlbFwiLFxyXG59O1xyXG5mdW5jdGlvbiBnZXRQb2ludGVyRXZlbnROYW1lKG5hbWUpIHtcclxuICAgIGlmIChzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3VwcG9ydHNUb3VjaEV2ZW50cygpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdWNoRXZlbnROYW1lc1tuYW1lXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN1cHBvcnRzTW91c2VFdmVudHMoKSkge1xyXG4gICAgICAgIHJldHVybiBtb3VzZUV2ZW50TmFtZXNbbmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZTtcclxufVxyXG5mdW5jdGlvbiBhZGRQb2ludGVyRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGREb21FdmVudCh0YXJnZXQsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB1c2VEb21FdmVudChyZWYsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcclxufVxuXG4vKiogQHB1YmxpYyAqL1xyXG52YXIgUG9pbnQ7XHJcbihmdW5jdGlvbiAoUG9pbnQpIHtcclxuICAgIC8qKiBAYmV0YSAqL1xyXG4gICAgUG9pbnQuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH07XHJcbiAgICB9O1xyXG4gICAgLyoqIEBiZXRhICovXHJcbiAgICBQb2ludC5yZWxhdGl2ZVRvID0gZnVuY3Rpb24gKGlkT3JFbGVtKSB7XHJcbiAgICAgICAgdmFyIGVsZW07XHJcbiAgICAgICAgdmFyIGdldEVsZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIENhY2hpbmcgZWxlbWVudCBoZXJlIGNvdWxkIGJlIGxlYWt5IGJlY2F1c2Ugb2YgUmVhY3QgbGlmZWN5Y2xlXHJcbiAgICAgICAgICAgIGlmIChlbGVtICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZE9yRWxlbSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkT3JFbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW0gPSBpZE9yRWxlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsRWxlbSA9IGdldEVsZW0oKTtcclxuICAgICAgICAgICAgaWYgKCFsb2NhbEVsZW0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGxvY2FsRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHggLSByZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgIHk6IHkgLSByZWN0LnRvcCAtIHdpbmRvdy5zY3JvbGxZLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59KShQb2ludCB8fCAoUG9pbnQgPSB7fSkpO1xuXG52YXIgaXNWaWV3cG9ydFNjcm9sbEJsb2NrZWQgPSBmYWxzZTtcclxudmFyIGlzQnJvd3NlciQxID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcclxuaWYgKGlzQnJvd3NlciQxKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmIChpc1ZpZXdwb3J0U2Nyb2xsQmxvY2tlZCkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbn1cclxudmFyIGJsb2NrVmlld3BvcnRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoaXNWaWV3cG9ydFNjcm9sbEJsb2NrZWQgPSB0cnVlKTsgfTtcclxudmFyIHVuYmxvY2tWaWV3cG9ydFNjcm9sbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChpc1ZpZXdwb3J0U2Nyb2xsQmxvY2tlZCA9IGZhbHNlKTsgfTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFBhblNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYW5TZXNzaW9uKGV2ZW50LCBoYW5kbGVycywgX2EpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1QYWdlUG9pbnQgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnRyYW5zZm9ybVBhZ2VQb2ludDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghKF90aGlzLmxhc3RNb3ZlRXZlbnQgJiYgX3RoaXMubGFzdE1vdmVFdmVudEluZm8pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdldFBhbkluZm8oX3RoaXMubGFzdE1vdmVFdmVudEluZm8sIF90aGlzLmhpc3RvcnkpO1xyXG4gICAgICAgICAgICB2YXIgaXNQYW5TdGFydGVkID0gX3RoaXMuc3RhcnRFdmVudCAhPT0gbnVsbDtcclxuICAgICAgICAgICAgLy8gT25seSBzdGFydCBwYW5uaW5nIGlmIHRoZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gMyBwaXhlbHMuIElmIHdlIG1ha2UgaXRcclxuICAgICAgICAgICAgLy8gYW55IGxhcmdlciB0aGFuIHRoaXMgd2UnbGwgd2FudCB0byByZXNldCB0aGUgcG9pbnRlciBoaXN0b3J5XHJcbiAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCB1cGRhdGUgdG8gYXZvaWQgdmlzdWFsIHNuYXBwaW5nIHRvIHRoZSBjdXJzb2UuXHJcbiAgICAgICAgICAgIHZhciBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlKGluZm8ub2Zmc2V0LCB7IHg6IDAsIHk6IDAgfSkgPj0gMztcclxuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBpbmZvLnBvaW50O1xyXG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xyXG4gICAgICAgICAgICBfdGhpcy5oaXN0b3J5LnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHBvaW50KSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KSk7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhhbmRsZXJzLCBvblN0YXJ0ID0gX2Eub25TdGFydCwgb25Nb3ZlID0gX2Eub25Nb3ZlO1xyXG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgb25TdGFydCAmJiBvblN0YXJ0KF90aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRFdmVudCA9IF90aGlzLmxhc3RNb3ZlRXZlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25Nb3ZlICYmIG9uTW92ZShfdGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSB0b3VjaCwgZG9uJ3Qgc3RhcnQgZGV0ZWN0aW5nIHRoaXMgZ2VzdHVyZVxyXG4gICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCA9IHRyYW5zZm9ybVBhZ2VQb2ludDtcclxuICAgICAgICB2YXIgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xyXG4gICAgICAgIHZhciBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcclxuICAgICAgICB2YXIgcG9pbnQgPSBpbml0aWFsSW5mby5wb2ludDtcclxuICAgICAgICB2YXIgdGltZXN0YW1wID0gZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFtfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcG9pbnQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pXTtcclxuICAgICAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBoYW5kbGVycy5vblNlc3Npb25TdGFydDtcclxuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxyXG4gICAgICAgICAgICBvblNlc3Npb25TdGFydChldmVudCwgZ2V0UGFuSW5mbyhpbml0aWFsSW5mbywgdGhpcy5oaXN0b3J5KSk7XHJcbiAgICAgICAgdmFyIHJlbW92ZU9uUG9pbnRlck1vdmUgPSBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIGZ1bmN0aW9uIChldmVudCwgaW5mbykgeyByZXR1cm4gX3RoaXMuaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQsIGluZm8pOyB9KTtcclxuICAgICAgICB2YXIgcmVtb3ZlT25Qb2ludGVyVXAgPSBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHsgcmV0dXJuIF90aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudCwgaW5mbyk7IH0pO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1vdmVPblBvaW50ZXJNb3ZlICYmIHJlbW92ZU9uUG9pbnRlck1vdmUoKTtcclxuICAgICAgICAgICAgcmVtb3ZlT25Qb2ludGVyVXAgJiYgcmVtb3ZlT25Qb2ludGVyVXAoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgUGFuU2Vzc2lvbi5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcclxuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBldmVudDtcclxuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xyXG4gICAgICAgIC8vIEJlY2F1c2UgU2FmYXJpIGRvZXNuJ3QgdHJpZ2dlciBtb3VzZXVwIGV2ZW50cyB3aGVuIGl0J3MgYWJvdmUgYSBgPHNlbGVjdD5gXHJcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudCwgaW5mbyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxyXG4gICAgICAgIHN5bmMudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFBhblNlc3Npb24ucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xyXG4gICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgdmFyIG9uRW5kID0gdGhpcy5oYW5kbGVycy5vbkVuZDtcclxuICAgICAgICBpZiAoIW9uRW5kKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgdGhpcy5oaXN0b3J5KTtcclxuICAgICAgICBvbkVuZCAmJiBvbkVuZChldmVudCwgcGFuSW5mbyk7XHJcbiAgICB9O1xyXG4gICAgUGFuU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlSGFuZGxlcnMgPSBmdW5jdGlvbiAoaGFuZGxlcnMpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XHJcbiAgICB9O1xyXG4gICAgUGFuU2Vzc2lvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy51cGRhdGVQb2ludCk7XHJcbiAgICAgICAgdW5ibG9ja1ZpZXdwb3J0U2Nyb2xsKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhblNlc3Npb247XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhZ2VQb2ludCA/IHsgcG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludChpbmZvLnBvaW50KSB9IDogaW5mbztcclxufVxyXG5mdW5jdGlvbiBnZXRQYW5JbmZvKF9hLCBoaXN0b3J5KSB7XHJcbiAgICB2YXIgcG9pbnQgPSBfYS5wb2ludDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxyXG4gICAgICAgIGRlbHRhOiBQb2ludC5zdWJ0cmFjdChwb2ludCwgbGFzdERldmljZVBvaW50KGhpc3RvcnkpKSxcclxuICAgICAgICBvZmZzZXQ6IFBvaW50LnN1YnRyYWN0KHBvaW50LCBzdGFydERldmljZVBvaW50KGhpc3RvcnkpKSxcclxuICAgICAgICB2ZWxvY2l0eTogZ2V0VmVsb2NpdHkkMShoaXN0b3J5LCAwLjEpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcclxuICAgIHJldHVybiBoaXN0b3J5WzBdO1xyXG59XHJcbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XHJcbiAgICByZXR1cm4gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZlbG9jaXR5JDEoaGlzdG9yeSwgdGltZURlbHRhKSB7XHJcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xyXG4gICAgd2hpbGUgKGkgPj0gMCkge1xyXG4gICAgICAgIHRpbWVzdGFtcGVkUG9pbnQgPSBoaXN0b3J5W2ldO1xyXG4gICAgICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPlxyXG4gICAgICAgICAgICBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG4gICAgdmFyIHRpbWUgPSAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wKSAvIDEwMDA7XHJcbiAgICBpZiAodGltZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuICAgIHZhciBjdXJyZW50VmVsb2NpdHkgPSB7XHJcbiAgICAgICAgeDogKGxhc3RQb2ludC54IC0gdGltZXN0YW1wZWRQb2ludC54KSAvIHRpbWUsXHJcbiAgICAgICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWUsXHJcbiAgICB9O1xyXG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS54ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcclxuICAgIH1cclxuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICBjdXJyZW50VmVsb2NpdHkueSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xyXG59XG5cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gaGFuZGxlcnMgLVxyXG4gKiBAcGFyYW0gcmVmIC1cclxuICpcclxuICogQGludGVybmFscmVtYXJrc1xyXG4gKiBDdXJyZW50bHkgdGhpcyBzZXRzIG5ldyBwYW4gZ2VzdHVyZSBmdW5jdGlvbnMgZXZlcnkgcmVuZGVyLiBUaGUgbWVtbyByb3V0ZSBoYXMgYmVlbiBleHBsb3JlZFxyXG4gKiBpbiB0aGUgcGFzdCBidXQgdWx0aW1hdGVseSB3ZSdyZSBzdGlsbCBjcmVhdGluZyBuZXcgZnVuY3Rpb25zIGV2ZXJ5IHJlbmRlci4gQW4gb3B0aW1pc2F0aW9uXHJcbiAqIHRvIGV4cGxvcmUgaXMgY3JlYXRpbmcgdGhlIHBhbiBnZXN0dXJlcyBhbmQgbG9hZGluZyB0aGVtIGludG8gYSBgcmVmYC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VQYW5HZXN0dXJlKF9hLCByZWYpIHtcclxuICAgIHZhciBvblBhbiA9IF9hLm9uUGFuLCBvblBhblN0YXJ0ID0gX2Eub25QYW5TdGFydCwgb25QYW5FbmQgPSBfYS5vblBhbkVuZCwgb25QYW5TZXNzaW9uU3RhcnQgPSBfYS5vblBhblNlc3Npb25TdGFydDtcclxuICAgIHZhciBoYXNQYW5FdmVudHMgPSBvblBhbiB8fCBvblBhblN0YXJ0IHx8IG9uUGFuRW5kIHx8IG9uUGFuU2Vzc2lvblN0YXJ0O1xyXG4gICAgdmFyIHBhblNlc3Npb24gPSB1c2VSZWYobnVsbCk7XHJcbiAgICB2YXIgdHJhbnNmb3JtUGFnZVBvaW50ID0gdXNlQ29udGV4dChNb3Rpb25QbHVnaW5Db250ZXh0KS50cmFuc2Zvcm1QYWdlUG9pbnQ7XHJcbiAgICB2YXIgaGFuZGxlcnMgPSB7XHJcbiAgICAgICAgb25TZXNzaW9uU3RhcnQ6IG9uUGFuU2Vzc2lvblN0YXJ0LFxyXG4gICAgICAgIG9uU3RhcnQ6IG9uUGFuU3RhcnQsXHJcbiAgICAgICAgb25Nb3ZlOiBvblBhbixcclxuICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XHJcbiAgICAgICAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIG9uUGFuRW5kICYmIG9uUGFuRW5kKGV2ZW50LCBpbmZvKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIGlmIChwYW5TZXNzaW9uLmN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICBwYW5TZXNzaW9uLmN1cnJlbnQudXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xyXG4gICAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG5ldyBQYW5TZXNzaW9uKGV2ZW50LCBoYW5kbGVycywge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVzZVBvaW50ZXJFdmVudChyZWYsIFwicG9pbnRlcmRvd25cIiwgaGFzUGFuRXZlbnRzICYmIG9uUG9pbnRlckRvd24pO1xyXG4gICAgdXNlVW5tb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBwYW5TZXNzaW9uLmN1cnJlbnQgJiYgcGFuU2Vzc2lvbi5jdXJyZW50LmVuZCgpOyB9KTtcclxufVxuXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgdXAgdGhlIHRyZWUgdG8gY2hlY2sgd2hldGhlciB0aGUgcHJvdmlkZWQgY2hpbGQgbm9kZVxyXG4gKiBpcyB0aGUgcGFyZW50IG9yIGEgZGVzY2VuZGFudCBvZiBpdC5cclxuICpcclxuICogQHBhcmFtIHBhcmVudCAtIEVsZW1lbnQgdG8gZmluZFxyXG4gKiBAcGFyYW0gY2hpbGQgLSBFbGVtZW50IHRvIHRlc3QgYWdhaW5zdCBwYXJlbnRcclxuICovXHJcbnZhciBpc05vZGVPckNoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcclxuICAgIGlmICghY2hpbGQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJlbnQgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xyXG4gICAgfVxyXG59O1xuXG52YXIgb3JkZXIgPSBbXCJ3aGlsZUhvdmVyXCIsIFwid2hpbGVUYXBcIiwgXCJ3aGlsZURyYWdcIl07XHJcbnZhciBnZXRHZXN0dXJlUHJpb3JpdHkgPSBmdW5jdGlvbiAoZ2VzdHVyZSkge1xyXG4gICAgcmV0dXJuIG9yZGVyLmluZGV4T2YoZ2VzdHVyZSkgKyAxO1xyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMb2NrKG5hbWUpIHtcclxuICAgIHZhciBsb2NrID0gbnVsbDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wZW5Mb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsb2NrID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxvY2sgPSBuYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gb3BlbkxvY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbn1cclxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xyXG52YXIgZ2xvYmFsVmVydGljYWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdWZXJ0aWNhbFwiKTtcclxuZnVuY3Rpb24gZ2V0R2xvYmFsTG9jayhkcmFnKSB7XHJcbiAgICB2YXIgbG9jayA9IGZhbHNlO1xyXG4gICAgaWYgKGRyYWcgPT09IFwieVwiKSB7XHJcbiAgICAgICAgbG9jayA9IGdsb2JhbFZlcnRpY2FsTG9jaygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZHJhZyA9PT0gXCJ4XCIpIHtcclxuICAgICAgICBsb2NrID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBvcGVuSG9yaXpvbnRhbF8xID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcclxuICAgICAgICB2YXIgb3BlblZlcnRpY2FsXzEgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcclxuICAgICAgICBpZiAob3Blbkhvcml6b250YWxfMSAmJiBvcGVuVmVydGljYWxfMSkge1xyXG4gICAgICAgICAgICBsb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xyXG4gICAgICAgICAgICAgICAgb3BlblZlcnRpY2FsXzEoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIGxvY2tzIGJlY2F1c2Ugd2UgZG9uJ3QgdXNlIHRoZW1cclxuICAgICAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEpXHJcbiAgICAgICAgICAgICAgICBvcGVuSG9yaXpvbnRhbF8xKCk7XHJcbiAgICAgICAgICAgIGlmIChvcGVuVmVydGljYWxfMSlcclxuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2s7XHJcbn1cblxudmFyIHRhcEdlc3R1cmVQcmlvcml0eSA9IGdldEdlc3R1cmVQcmlvcml0eShcIndoaWxlVGFwXCIpO1xyXG4vKipcclxuICogQHBhcmFtIGhhbmRsZXJzIC1cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VUYXBHZXN0dXJlKF9hLCByZWYpIHtcclxuICAgIHZhciBvblRhcCA9IF9hLm9uVGFwLCBvblRhcFN0YXJ0ID0gX2Eub25UYXBTdGFydCwgb25UYXBDYW5jZWwgPSBfYS5vblRhcENhbmNlbCwgd2hpbGVUYXAgPSBfYS53aGlsZVRhcCwgY29udHJvbHMgPSBfYS5jb250cm9scztcclxuICAgIHZhciBoYXNUYXBMaXN0ZW5lcnMgPSBvblRhcCB8fCBvblRhcFN0YXJ0IHx8IG9uVGFwQ2FuY2VsIHx8IHdoaWxlVGFwO1xyXG4gICAgdmFyIGlzVGFwcGluZyA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICB2YXIgY2FuY2VsUG9pbnRlckV2ZW50TGlzdGVuZXIgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyVXAoKSB7XHJcbiAgICAgICAgY2FuY2VsUG9pbnRlckV2ZW50TGlzdGVuZXIuY3VycmVudCAmJlxyXG4gICAgICAgICAgICBjYW5jZWxQb2ludGVyRXZlbnRMaXN0ZW5lci5jdXJyZW50KCk7XHJcbiAgICAgICAgY2FuY2VsUG9pbnRlckV2ZW50TGlzdGVuZXIuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAod2hpbGVUYXAgJiYgY29udHJvbHMpIHtcclxuICAgICAgICBjb250cm9scy5zZXRPdmVycmlkZSh3aGlsZVRhcCwgdGFwR2VzdHVyZVByaW9yaXR5KTtcclxuICAgIH1cclxuICAgIC8vIFdlIGxvYWQgdGhpcyBldmVudCBoYW5kbGVyIGludG8gYSByZWYgc28gd2UgY2FuIGxhdGVyIHJlZmVyIHRvXHJcbiAgICAvLyBvblBvaW50ZXJVcC5jdXJyZW50IHdoaWNoIHdpbGwgYWx3YXlzIGhhdmUgcmVmZXJlbmNlIHRvIHRoZSBsYXRlc3QgcHJvcHNcclxuICAgIHZhciBvblBvaW50ZXJVcCA9IHVzZVJlZihudWxsKTtcclxuICAgIG9uUG9pbnRlclVwLmN1cnJlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xyXG4gICAgICAgIHJlbW92ZVBvaW50ZXJVcCgpO1xyXG4gICAgICAgIGlmICghaXNUYXBwaW5nLmN1cnJlbnQgfHwgIWVsZW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpc1RhcHBpbmcuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChjb250cm9scyAmJiB3aGlsZVRhcCkge1xyXG4gICAgICAgICAgICBjb250cm9scy5jbGVhck92ZXJyaWRlKHRhcEdlc3R1cmVQcmlvcml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIHRoZSBnZXN0dXJlIGxvY2sgLSBpZiB3ZSBnZXQgaXQsIGl0IG1lYW5zIG5vIGRyYWcgZ2VzdHVyZSBpcyBhY3RpdmVcclxuICAgICAgICAvLyBhbmQgd2UgY2FuIHNhZmVseSBmaXJlIHRoZSB0YXAgZ2VzdHVyZS5cclxuICAgICAgICB2YXIgb3Blbkdlc3R1cmVMb2NrID0gZ2V0R2xvYmFsTG9jayh0cnVlKTtcclxuICAgICAgICBpZiAoIW9wZW5HZXN0dXJlTG9jaylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIG9wZW5HZXN0dXJlTG9jaygpO1xyXG4gICAgICAgIGlmICghaXNOb2RlT3JDaGlsZChlbGVtZW50LCBldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIG9uVGFwQ2FuY2VsICYmIG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9uVGFwICYmIG9uVGFwKGV2ZW50LCBpbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgaW5mbykge1xyXG4gICAgICAgIHJlbW92ZVBvaW50ZXJVcCgpO1xyXG4gICAgICAgIGNhbmNlbFBvaW50ZXJFdmVudExpc3RlbmVyLmN1cnJlbnQgPSBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHsgcmV0dXJuIG9uUG9pbnRlclVwLmN1cnJlbnQoZXZlbnQsIGluZm8pOyB9KTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghZWxlbWVudCB8fCBpc1RhcHBpbmcuY3VycmVudClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlzVGFwcGluZy5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICBvblRhcFN0YXJ0ICYmIG9uVGFwU3RhcnQoZXZlbnQsIGluZm8pO1xyXG4gICAgICAgIGlmIChjb250cm9scyAmJiB3aGlsZVRhcCkge1xyXG4gICAgICAgICAgICBjb250cm9scy5zdGFydE92ZXJyaWRlKHRhcEdlc3R1cmVQcmlvcml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXNlUG9pbnRlckV2ZW50KHJlZiwgXCJwb2ludGVyZG93blwiLCBoYXNUYXBMaXN0ZW5lcnMgPyBvblBvaW50ZXJEb3duIDogdW5kZWZpbmVkKTtcclxuICAgIHVzZVVubW91bnRFZmZlY3QocmVtb3ZlUG9pbnRlclVwKTtcclxufVxuXG52YXIgaG92ZXJQcmlvcml0eSA9IGdldEdlc3R1cmVQcmlvcml0eShcIndoaWxlSG92ZXJcIik7XHJcbnZhciBmaWx0ZXJUb3VjaCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XHJcbiAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSlcclxuICAgICAgICBsaXN0ZW5lcihldmVudCwgaW5mbyk7XHJcbn07IH07XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvcHNcclxuICogQHBhcmFtIHJlZlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHVzZUhvdmVyR2VzdHVyZShfYSwgcmVmKSB7XHJcbiAgICB2YXIgd2hpbGVIb3ZlciA9IF9hLndoaWxlSG92ZXIsIG9uSG92ZXJTdGFydCA9IF9hLm9uSG92ZXJTdGFydCwgb25Ib3ZlckVuZCA9IF9hLm9uSG92ZXJFbmQsIGNvbnRyb2xzID0gX2EuY29udHJvbHM7XHJcbiAgICBpZiAod2hpbGVIb3ZlciAmJiBjb250cm9scykge1xyXG4gICAgICAgIGNvbnRyb2xzLnNldE92ZXJyaWRlKHdoaWxlSG92ZXIsIGhvdmVyUHJpb3JpdHkpO1xyXG4gICAgfVxyXG4gICAgdXNlUG9pbnRlckV2ZW50KHJlZiwgXCJwb2ludGVyZW50ZXJcIiwgZmlsdGVyVG91Y2goZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XHJcbiAgICAgICAgaWYgKG9uSG92ZXJTdGFydClcclxuICAgICAgICAgICAgb25Ib3ZlclN0YXJ0KGV2ZW50LCBpbmZvKTtcclxuICAgICAgICBpZiAod2hpbGVIb3ZlciAmJiBjb250cm9scykge1xyXG4gICAgICAgICAgICBjb250cm9scy5zdGFydE92ZXJyaWRlKGhvdmVyUHJpb3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxuICAgIHVzZVBvaW50ZXJFdmVudChyZWYsIFwicG9pbnRlcmxlYXZlXCIsIGZpbHRlclRvdWNoKGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xyXG4gICAgICAgIGlmIChvbkhvdmVyRW5kKVxyXG4gICAgICAgICAgICBvbkhvdmVyRW5kKGV2ZW50LCBpbmZvKTtcclxuICAgICAgICBpZiAod2hpbGVIb3ZlciAmJiBjb250cm9scykge1xyXG4gICAgICAgICAgICBjb250cm9scy5jbGVhck92ZXJyaWRlKGhvdmVyUHJpb3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxufVxuXG4vKipcclxuICogQWRkIHBhbiBhbmQgdGFwIGdlc3R1cmUgcmVjb2duaXRpb24gdG8gYW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHByb3BzIC0gR2VzdHVyZSBldmVudCBoYW5kbGVyc1xyXG4gKiBAcGFyYW0gcmVmIC0gUmVhY3QgYHJlZmAgY29udGFpbmluZyBhIERPTSBgRWxlbWVudGBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlR2VzdHVyZXMocHJvcHMsIHJlZikge1xyXG4gICAgdXNlUGFuR2VzdHVyZShwcm9wcywgcmVmKTtcclxuICAgIHVzZVRhcEdlc3R1cmUocHJvcHMsIHJlZik7XHJcbiAgICB1c2VIb3Zlckdlc3R1cmUocHJvcHMsIHJlZik7XHJcbn1cblxudmFyIG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgaG9vayhwcm9wcyk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTsgfTtcblxudmFyIGdlc3R1cmVQcm9wcyA9IFtcclxuICAgIFwib25QYW5cIixcclxuICAgIFwib25QYW5TdGFydFwiLFxyXG4gICAgXCJvblBhbkVuZFwiLFxyXG4gICAgXCJvblBhblNlc3Npb25TdGFydFwiLFxyXG4gICAgXCJvblRhcFwiLFxyXG4gICAgXCJvblRhcFN0YXJ0XCIsXHJcbiAgICBcIm9uVGFwQ2FuY2VsXCIsXHJcbiAgICBcIndoaWxlVGFwXCIsXHJcbiAgICBcIndoaWxlSG92ZXJcIixcclxuICAgIFwib25Ib3ZlclN0YXJ0XCIsXHJcbiAgICBcIm9uSG92ZXJFbmRcIixcclxuXTtcclxudmFyIEdlc3R1cmVzID0ge1xyXG4gICAga2V5OiBcImdlc3R1cmVzXCIsXHJcbiAgICBzaG91bGRSZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgIHJldHVybiBnZXN0dXJlUHJvcHMuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpOyB9KTtcclxuICAgIH0sXHJcbiAgICBDb21wb25lbnQ6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBpbm5lclJlZiA9IF9hLmlubmVyUmVmLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiaW5uZXJSZWZcIl0pO1xyXG4gICAgICAgIHVzZUdlc3R1cmVzKHByb3BzLCBpbm5lclJlZik7XHJcbiAgICB9KSxcclxufTtcblxudmFyIGlzUmVmT2JqZWN0ID0gZnVuY3Rpb24gKHJlZikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKTtcclxufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfTtcclxudmFyIENvbXBvbmVudERyYWdDb250cm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudERyYWdDb250cm9scyhfYSkge1xyXG4gICAgICAgIHZhciByZWYgPSBfYS5yZWYsIHZhbHVlcyA9IF9hLnZhbHVlcywgY29udHJvbHMgPSBfYS5jb250cm9scztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFjayB3aGV0aGVyIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGRpcmVjdGlvbiBvZiBkcmFnLCBvciBgbnVsbGAgaWYgYm90aC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBlcm1pdHRlZCB0L3IvYi9sIGJvdW5kYXJpZXMgb2YgdHJhdmVsLCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGhvc3QgY29tcG9uZW50J3MgbGF0ZXN0IHByb3BzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9wcyA9IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtUGFnZVBvaW50OiBub29wLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlcyB0byB0aGUgTW90aW9uVmFsdWVzIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBjdXJyZW50IGRyYWdnZWQgcG9pbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvaW50ID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9yaWdpbiBwb2ludCBmb3IgdGhlIGN1cnJlbnQgZHJhZyBnZXN0dXJlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB7XHJcbiAgICAgICAgICAgIHg6IG1vdGlvblZhbHVlKDApLFxyXG4gICAgICAgICAgICB5OiBtb3Rpb25WYWx1ZSgwKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jaywgZW5zdXJpbmcgb25seSBvbmUgY29tcG9uZW50XHJcbiAgICAgICAgLy8gY2FuIFwiY2FwdHVyZVwiIHRoZSBkcmFnIG9mIG9uZSBvciBib3RoIGF4ZXMuXHJcbiAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIG1vdmluZyB0aGlzIGludG8gcGFuc2Vzc2lvbj9cclxuICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyBjb25zdHJhaW50cyBib3VuZGluZyBib3hcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJldkNvbnN0cmFpbnRzQm94ID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBkcmFnZ2luZyB0aGUgaG9zdCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG9yaWdpbmF0aW5nIHBvaW50ZXIgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBDb21wb25lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9yaWdpbkV2ZW50LCBfYSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5zbmFwVG9DdXJzb3IsIHNuYXBUb0N1cnNvciA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xyXG4gICAgICAgIHNuYXBUb0N1cnNvciAmJiB0aGlzLnNuYXBUb0N1cnNvcihvcmlnaW5FdmVudCk7XHJcbiAgICAgICAgdmFyIG9uU2Vzc2lvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBJbml0aWF0ZSB2aWV3cG9ydCBzY3JvbGwgYmxvY2tpbmcgb24gdG91Y2ggc3RhcnQuIFRoaXMgaXMgYSB2ZXJ5IGFnZ3Jlc3NpdmUgYXBwcm9hY2hcclxuICAgICAgICAgICAgLy8gd2hpY2ggaGFzIGNvbWUgb3V0IG9mIHRoZSBkaWZmaWN1bHR5IGluIHVzIGJlaW5nIGFibGUgdG8gZG8gdGhpcyBvbmNlIGEgc2Nyb2xsIGdlc3R1cmVcclxuICAgICAgICAgICAgLy8gaGFzIGluaXRpYXRlZCBpbiBtb2JpbGUgYnJvd3NlcnMuIFRoaXMgbWVhbnMgaWYgdGhlcmUncyBhIGhvcml6b250YWxseS1zY3JvbGxpbmcgY2Fyb3VzZWxcclxuICAgICAgICAgICAgLy8gb24gYSBwYWdlIHdlIGNhbid0IGxldCBhIHVzZXIgc2Nyb2xsIHRoZSBwYWdlIGl0c2VsZiBmcm9tIGl0LiBJZGVhbGx5IHdoYXQgd2UnZCBkbyBpc1xyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoaXMgb25jZSB3ZSd2ZSBnb3QgYSBzY3JvbGwgZGlyZWN0aW9uIGRldGVybWluZWQuIFRoaXMgYXBwcm9hY2ggc29ydC1vZiB3b3JrZWRcclxuICAgICAgICAgICAgLy8gYnV0IGlmIHRoZSBjb21wb25lbnQgd2FzIGRyYWdnZWQgdG9vIGZhciBpbiBhIHNpbmdsZSBmcmFtZSBwYWdlIHNjcm9sbGluZyB3b3VsZCBpbml0aWF0ZS5cclxuICAgICAgICAgICAgYmxvY2tWaWV3cG9ydFNjcm9sbCgpO1xyXG4gICAgICAgICAgICAvLyBTdG9wIGFueSBhbmltYXRpb25zIG9uIGJvdGggYXhpcyB2YWx1ZXMgaW1tZWRpYXRlbHkuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHRocm93IGFuZCBjYXRjaFxyXG4gICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50LlxyXG4gICAgICAgICAgICBib3RoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb2ludCA9IF90aGlzLnBvaW50W2F4aXNdO1xyXG4gICAgICAgICAgICAgICAgYXhpc1BvaW50ICYmIGF4aXNQb2ludC5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcclxuICAgICAgICAgICAgLy8gSWYgY29uc3RyYWludHMgYXJlIGFuIGVsZW1lbnQsIHJlc29sdmUgdGhlbSBhZ2FpbiBpbiBjYXNlIHRoZXkndmUgdXBkYXRlZC5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnN0cmFpbnRzTmVlZFJlc29sdXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIHRyYW5zZm9ybVBhZ2VQb2ludF8xID0gX2EudHJhbnNmb3JtUGFnZVBvaW50O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBjYWxjdWxhdGVDb25zdHJhaW50c0Zyb21Eb20oZHJhZ0NvbnN0cmFpbnRzLCBfdGhpcy5yZWYsIF90aGlzLnBvaW50LCB0cmFuc2Zvcm1QYWdlUG9pbnRfMSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBseUNvbnN0cmFpbnRzVG9Qb2ludCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNldCBwb2ludCBvcmlnaW4gYW5kIHN0b3AgYW55IGV4aXN0aW5nIGFuaW1hdGlvbnMuXHJcbiAgICAgICAgICAgIGJvdGhBeGlzKGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1BvaW50ID0gX3RoaXMucG9pbnRbYXhpc107XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNQb2ludClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5bYXhpc10uc2V0KGF4aXNQb2ludC5nZXQoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jayAtIG1heWJlIG1ha2UgdGhpcyBwYXJ0IG9mIFBhblNlc3Npb25cclxuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRyYWcgPSBfYi5kcmFnLCBkcmFnUHJvcGFnYXRpb24gPSBfYi5kcmFnUHJvcGFnYXRpb247XHJcbiAgICAgICAgICAgIGlmIChkcmFnICYmICFkcmFnUHJvcGFnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcGVuR2xvYmFsTG9jaylcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub3Blbkdsb2JhbExvY2sgPSBnZXRHbG9iYWxMb2NrKGRyYWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcGVuR2xvYmFsTG9jaylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgb25EcmFnU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkRyYWdTdGFydDtcclxuICAgICAgICAgICAgb25EcmFnU3RhcnQgJiZcclxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0KGV2ZW50LCBjb252ZXJ0UGFuVG9EcmFnKGluZm8sIF90aGlzLnBvaW50KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkcmFnUHJvcGFnYXRpb24gPSBfYS5kcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrID0gX2EuZHJhZ0RpcmVjdGlvbkxvY2s7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBzdWNjZXNzZnVsbHkgcmVjZWl2ZSB0aGUgZ2VzdHVyZSBsb2NrLCBlYXJseSByZXR1cm4uXHJcbiAgICAgICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICFfdGhpcy5vcGVuR2xvYmFsTG9jaylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGluZm8ub2Zmc2V0O1xyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBkcmFnIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb25Mb2NrIGlzIHRydWVcclxuICAgICAgICAgICAgaWYgKGRyYWdEaXJlY3Rpb25Mb2NrICYmIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzdWNjZXNzZnVsbHkgc2V0IGEgZGlyZWN0aW9uLCBub3RpZnkgbGlzdGVuZXJcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uRGlyZWN0aW9uTG9jayA9IF90aGlzLnByb3BzLm9uRGlyZWN0aW9uTG9jaztcclxuICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgJiYgb25EaXJlY3Rpb25Mb2NrKF90aGlzLmN1cnJlbnREaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVBvaW50KFwieFwiLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVQb2ludChcInlcIiwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIG9uRHJhZyA9IF90aGlzLnByb3BzLm9uRHJhZztcclxuICAgICAgICAgICAgb25EcmFnICYmIG9uRHJhZyhldmVudCwgY29udmVydFBhblRvRHJhZyhpbmZvLCBfdGhpcy5wb2ludCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xyXG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKG9yaWdpbkV2ZW50LCB7XHJcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBvblNlc3Npb25TdGFydCxcclxuICAgICAgICAgICAgb25TdGFydDogb25TdGFydCxcclxuICAgICAgICAgICAgb25Nb3ZlOiBvbk1vdmUsXHJcbiAgICAgICAgICAgIG9uRW5kOiBvbkVuZCxcclxuICAgICAgICB9LCB7IHRyYW5zZm9ybVBhZ2VQb2ludDogdHJhbnNmb3JtUGFnZVBvaW50IH0pO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudERyYWdDb250cm9scy5wcm90b3R5cGUuY2FuY2VsRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1bmJsb2NrVmlld3BvcnRTY3JvbGwoKTtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhblNlc3Npb24gJiYgdGhpcy5wYW5TZXNzaW9uLmVuZCgpO1xyXG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5HbG9iYWxMb2NrKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2soKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLnBhblNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQoKTtcclxuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBudWxsO1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsRHJhZygpO1xyXG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIGRyYWdNb21lbnR1bSA9IF9iLmRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMgPSBfYi5kcmFnRWxhc3RpYywgb25EcmFnRW5kID0gX2Iub25EcmFnRW5kO1xyXG4gICAgICAgIGlmIChkcmFnTW9tZW50dW0gfHwgZHJhZ0VsYXN0aWMpIHtcclxuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gaW5mby52ZWxvY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlRHJhZ0VuZCh2ZWxvY2l0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZEJveEluZm8odGhpcy5jb25zdHJhaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uRHJhZ0VuZCAmJiBvbkRyYWdFbmQoZXZlbnQsIGNvbnZlcnRQYW5Ub0RyYWcoaW5mbywgdGhpcy5wb2ludCkpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudERyYWdDb250cm9scy5wcm90b3R5cGUucmVjb3JkQm94SW5mbyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBjb25zdHJhaW50cy5yaWdodCwgbGVmdCA9IGNvbnN0cmFpbnRzLmxlZnQsIGJvdHRvbSA9IGNvbnN0cmFpbnRzLmJvdHRvbSwgdG9wXzEgPSBjb25zdHJhaW50cy50b3A7XHJcbiAgICAgICAgICAgIHRoaXMucHJldkNvbnN0cmFpbnRzQm94LndpZHRoID0gKHJpZ2h0IHx8IDApIC0gKGxlZnQgfHwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJldkNvbnN0cmFpbnRzQm94LmhlaWdodCA9IChib3R0b20gfHwgMCkgLSAodG9wXzEgfHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBvaW50LngpXHJcbiAgICAgICAgICAgIHRoaXMucHJldkNvbnN0cmFpbnRzQm94LnggPSB0aGlzLnBvaW50LnguZ2V0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnQueSlcclxuICAgICAgICAgICAgdGhpcy5wcmV2Q29uc3RyYWludHNCb3gueSA9IHRoaXMucG9pbnQueS5nZXQoKTtcclxuICAgIH07XHJcbiAgICBDb21wb25lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNuYXBUb0N1cnNvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xyXG4gICAgICAgIHZhciBwb2ludCA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpLnBvaW50O1xyXG4gICAgICAgIHZhciBib3VuZGluZ0JveCA9IGdldEJvdW5kaW5nQm94KHRoaXMucmVmLCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB7XHJcbiAgICAgICAgICAgIHg6IGJvdW5kaW5nQm94LndpZHRoIC8gMiArIGJvdW5kaW5nQm94LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgICAgICAgeTogYm91bmRpbmdCb3guaGVpZ2h0IC8gMiArIGJvdW5kaW5nQm94LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHtcclxuICAgICAgICAgICAgeDogcG9pbnQueCAtIGNlbnRlci54LFxyXG4gICAgICAgICAgICB5OiBwb2ludC55IC0gY2VudGVyLnksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBib3RoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBfdGhpcy5wb2ludFtheGlzXTtcclxuICAgICAgICAgICAgaWYgKCFwb2ludClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgX3RoaXMub3JpZ2luW2F4aXNdLnNldChwb2ludC5nZXQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQb2ludChcInhcIiwgb2Zmc2V0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50KFwieVwiLCBvZmZzZXQpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudERyYWdDb250cm9scy5wcm90b3R5cGUuc2V0UG9pbnQgPSBmdW5jdGlvbiAoYXhpcywgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnBvaW50W2F4aXNdID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS51cGRhdGVQb2ludCA9IGZ1bmN0aW9uIChheGlzLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkcmFnID0gX2EuZHJhZywgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYztcclxuICAgICAgICB2YXIgYXhpc1BvaW50ID0gdGhpcy5wb2ludFtheGlzXTtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXHJcbiAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikgfHwgIWF4aXNQb2ludClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gYXBwbHlDb25zdHJhaW50cyhheGlzLCB0aGlzLm9yaWdpbltheGlzXS5nZXQoKSArIG9mZnNldFtheGlzXSwgdGhpcy5jb25zdHJhaW50cywgZHJhZ0VsYXN0aWMpO1xyXG4gICAgICAgIGF4aXNQb2ludC5zZXQoY3VycmVudCk7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9iID0gX2EuZHJhZywgZHJhZyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLmRyYWdEaXJlY3Rpb25Mb2NrLCBkcmFnRGlyZWN0aW9uTG9jayA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRyYWdQcm9wYWdhdGlvbiwgZHJhZ1Byb3BhZ2F0aW9uID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCBkcmFnQ29uc3RyYWludHMgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYS5kcmFnRWxhc3RpYywgZHJhZ0VsYXN0aWMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9hLmRyYWdNb21lbnR1bSwgZHJhZ01vbWVudHVtID0gX2cgPT09IHZvaWQgMCA/IHRydWUgOiBfZywgcmVtYWluaW5nUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImRyYWdcIiwgXCJkcmFnRGlyZWN0aW9uTG9ja1wiLCBcImRyYWdQcm9wYWdhdGlvblwiLCBcImRyYWdDb25zdHJhaW50c1wiLCBcImRyYWdFbGFzdGljXCIsIFwiZHJhZ01vbWVudHVtXCJdKTtcclxuICAgICAgICB0aGlzLnByb3BzID0gX19hc3NpZ24oeyBkcmFnOiBkcmFnLFxyXG4gICAgICAgICAgICBkcmFnRGlyZWN0aW9uTG9jazogZHJhZ0RpcmVjdGlvbkxvY2ssXHJcbiAgICAgICAgICAgIGRyYWdQcm9wYWdhdGlvbjogZHJhZ1Byb3BhZ2F0aW9uLFxyXG4gICAgICAgICAgICBkcmFnQ29uc3RyYWludHM6IGRyYWdDb25zdHJhaW50cyxcclxuICAgICAgICAgICAgZHJhZ0VsYXN0aWM6IGRyYWdFbGFzdGljLFxyXG4gICAgICAgICAgICBkcmFnTW9tZW50dW06IGRyYWdNb21lbnR1bSB9LCByZW1haW5pbmdQcm9wcyk7XHJcbiAgICAgICAgdmFyIF9kcmFnVmFsdWVYID0gcmVtYWluaW5nUHJvcHMuX2RyYWdWYWx1ZVgsIF9kcmFnVmFsdWVZID0gcmVtYWluaW5nUHJvcHMuX2RyYWdWYWx1ZVksIGRyYWdPcmlnaW5YID0gcmVtYWluaW5nUHJvcHMuZHJhZ09yaWdpblgsIGRyYWdPcmlnaW5ZID0gcmVtYWluaW5nUHJvcHMuZHJhZ09yaWdpblk7XHJcbiAgICAgICAgaWYgKGRyYWdPcmlnaW5YKVxyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi54ID0gZHJhZ09yaWdpblg7XHJcbiAgICAgICAgaWYgKGRyYWdPcmlnaW5ZKVxyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi55ID0gZHJhZ09yaWdpblk7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBgTW90aW9uVmFsdWVgIGZvciBib3RoIGRyYWdnYWJsZSBheGVzLCBvciBjcmVhdGUgdGhlbSBpZiB0aGV5IGRvbid0IGFscmVhZHlcclxuICAgICAgICAvLyBleGlzdCBvbiB0aGlzIGNvbXBvbmVudC5cclxuICAgICAgICBib3RoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBheGlzID09PSBcInhcIiA/IF9kcmFnVmFsdWVYIDogX2RyYWdWYWx1ZVk7XHJcbiAgICAgICAgICAgIF90aGlzLnNldFBvaW50KGF4aXMsIGRlZmF1bHRWYWx1ZSB8fCBfdGhpcy52YWx1ZXMuZ2V0KGF4aXMsIDApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiBgZHJhZ0NvbnN0cmFpbnRzYCBpcyBhIFJlYWN0IGByZWZgLCB3ZSBzaG91bGQgcmVzb2x2ZSB0aGUgY29uc3RyYWludHMgb25jZSB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgaGFzIHJlbmRlcmVkLlxyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHNOZWVkUmVzb2x1dGlvbiA9IGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cyk7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHNOZWVkUmVzb2x1dGlvblxyXG4gICAgICAgICAgICA/IHRoaXMuY29uc3RyYWludHMgfHwgZmFsc2VcclxuICAgICAgICAgICAgOiBkcmFnQ29uc3RyYWludHM7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzVG9Qb2ludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzID09PSB2b2lkIDApIHsgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzOyB9XHJcbiAgICAgICAgcmV0dXJuIGJvdGhBeGlzKGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnQgPSBfdGhpcy5wb2ludFtheGlzXTtcclxuICAgICAgICAgICAgYXhpc1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICAhYXhpc1BvaW50LmlzQW5pbWF0aW5nKCkgJiZcclxuICAgICAgICAgICAgICAgIGFwcGx5Q29uc3RyYWludHMoYXhpcywgYXhpc1BvaW50LCBjb25zdHJhaW50cywgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5hbmltYXRlRHJhZ0VuZCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZHJhZyA9IF9hLmRyYWcsIGRyYWdNb21lbnR1bSA9IF9hLmRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYywgZHJhZ1RyYW5zaXRpb24gPSBfYS5kcmFnVHJhbnNpdGlvbiwgX2RyYWdWYWx1ZVggPSBfYS5fZHJhZ1ZhbHVlWCwgX2RyYWdWYWx1ZVkgPSBfYS5fZHJhZ1ZhbHVlWSwgX2RyYWdUcmFuc2l0aW9uQ29udHJvbHMgPSBfYS5fZHJhZ1RyYW5zaXRpb25Db250cm9scztcclxuICAgICAgICB2YXIgbW9tZW50dW1BbmltYXRpb25zID0gYm90aEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IF90aGlzLmNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgICAgICA/IGdldENvbnN0cmFpbnRzKGF4aXMsIF90aGlzLmNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICAgICAgOiB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE92ZXJkYW1wIHRoZSBib3VuZGFyeSBzcHJpbmcgaWYgYGRyYWdFbGFzdGljYCBpcyBkaXNhYmxlZC4gVGhlcmUncyBzdGlsbCBhIGZyYW1lXHJcbiAgICAgICAgICAgICAqIG9mIHNwcmluZyBhbmltYXRpb25zIHNvIHdlIHNob3VsZCBsb29rIGludG8gYWRkaW5nIGEgZGlzYWJsZSBzcHJpbmcgb3B0aW9uIHRvIGBpbmVydGlhYC5cclxuICAgICAgICAgICAgICogV2UgY291bGQgZG8gc29tZXRoaW5nIGhlcmUgd2hlcmUgd2UgYWZmZWN0IHRoZSBgYm91bmNlU3RpZmZuZXNzYCBhbmQgYGJvdW5jZURhbXBpbmdgXHJcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZHJhZ0VsYXN0aWNgLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMTAwMDAwMDtcclxuICAgICAgICAgICAgdmFyIGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMTAwMDAwMDA7XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25Db250cm9scyA9IF9kcmFnVHJhbnNpdGlvbkNvbnRyb2xzIHx8IF90aGlzLmNvbnRyb2xzO1xyXG4gICAgICAgICAgICB2YXIgaW5lcnRpYSA9IF9fYXNzaWduKF9fYXNzaWduKHsgdHlwZTogXCJpbmVydGlhXCIsIHZlbG9jaXR5OiBkcmFnTW9tZW50dW0gPyB2ZWxvY2l0eVtheGlzXSA6IDAsIGJvdW5jZVN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLFxyXG4gICAgICAgICAgICAgICAgYm91bmNlRGFtcGluZzogYm91bmNlRGFtcGluZywgdGltZUNvbnN0YW50OiA3NTAsIHJlc3REZWx0YTogMSB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxBeGlzTW90aW9uVmFsdWUgPSBheGlzID09PSBcInhcIiA/IF9kcmFnVmFsdWVYIDogX2RyYWdWYWx1ZVk7XHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBhbmltYXRpbmcgb24gYW4gZXh0ZXJuYWxseS1wcm92aWRlZCBgTW90aW9uVmFsdWVgIHdlIGNhbiB1c2UgdGhlXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCdzIGFuaW1hdGlvbiBjb250cm9scyB3aGljaCB3aWxsIGhhbmRsZSBpbnRlcmFjdGlvbnMgd2l0aCB3aGlsZUhvdmVyIChldGMpLFxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCBoYXZlIHRvIGFuaW1hdGUgdGhlIGBNb3Rpb25WYWx1ZWAgaXRzZWxmLlxyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWxBeGlzTW90aW9uVmFsdWVcclxuICAgICAgICAgICAgICAgID8gc3RhcnRBbmltYXRpb24oYXhpcywgZXh0ZXJuYWxBeGlzTW90aW9uVmFsdWUsIDAsIGluZXJ0aWEpXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkNvbnRyb2xzLnN0YXJ0KChfYSA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIF9hW2F4aXNdID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBfYS50cmFuc2l0aW9uID0gaW5lcnRpYSxcclxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFJ1biBhbGwgYW5pbWF0aW9ucyBhbmQgdGhlbiByZXNvbHZlIHRoZSBuZXcgZHJhZyBjb25zdHJhaW50cy5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobW9tZW50dW1BbmltYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVjb3JkQm94SW5mbyhfdGhpcy5jb25zdHJhaW50cyk7XHJcbiAgICAgICAgICAgIF90aGlzLnNjYWxlUG9pbnQoKTtcclxuICAgICAgICAgICAgdmFyIG9uRHJhZ1RyYW5zaXRpb25FbmQgPSBfdGhpcy5wcm9wcy5vbkRyYWdUcmFuc2l0aW9uRW5kO1xyXG4gICAgICAgICAgICBvbkRyYWdUcmFuc2l0aW9uRW5kICYmIG9uRHJhZ1RyYW5zaXRpb25FbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDb21wb25lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNjYWxlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIHRyYW5zZm9ybVBhZ2VQb2ludCA9IF9hLnRyYW5zZm9ybVBhZ2VQb2ludDtcclxuICAgICAgICBpZiAoIWlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgY29uc3RyYWludHNCb3ggPSBnZXRCb3VuZGluZ0JveChkcmFnQ29uc3RyYWludHMsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XHJcbiAgICAgICAgdmFyIGRyYWdnYWJsZUJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMucmVmLCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xyXG4gICAgICAgIC8vIFNjYWxlIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHRyYW5zZm9ybWF0aW9uIG9mIGEgY29uc3RyYWludHMtcHJvdmlkaW5nIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIHNjYWxlQXhpc1BvaW50ID0gZnVuY3Rpb24gKGF4aXMsIGRpbWVuc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRUb1NjYWxlID0gX3RoaXMucG9pbnRbYXhpc107XHJcbiAgICAgICAgICAgIGlmICghcG9pbnRUb1NjYWxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAvLyBTdG9wIGFueSBjdXJyZW50IGFuaW1hdGlvbnMgYXMgdGhleSBidWcgb3V0IGlmIHlvdSByZXNpemUgZHVyaW5nIG9uZVxyXG4gICAgICAgICAgICBpZiAocG9pbnRUb1NjYWxlLmlzQW5pbWF0aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50VG9TY2FsZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNvcmRCb3hJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGRpbWVuc2lvbiB3YXMgYDBgIChkZWZhdWx0KSwgc2V0IGBzY2FsZWAgdG8gYDFgIHRvIHByZXZlbnRcclxuICAgICAgICAgICAgLy8gZGl2aWRlIGJ5IHplcm8gZXJyb3JzLlxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBfdGhpcy5wcmV2Q29uc3RyYWludHNCb3hbZGltZW5zaW9uXVxyXG4gICAgICAgICAgICAgICAgPyAoY29uc3RyYWludHNCb3hbZGltZW5zaW9uXSAtIGRyYWdnYWJsZUJveFtkaW1lbnNpb25dKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJldkNvbnN0cmFpbnRzQm94W2RpbWVuc2lvbl1cclxuICAgICAgICAgICAgICAgIDogMTtcclxuICAgICAgICAgICAgcG9pbnRUb1NjYWxlLnNldChfdGhpcy5wcmV2Q29uc3RyYWludHNCb3hbYXhpc10gKiBzY2FsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzY2FsZUF4aXNQb2ludChcInhcIiwgXCJ3aWR0aFwiKTtcclxuICAgICAgICBzY2FsZUF4aXNQb2ludChcInlcIiwgXCJoZWlnaHRcIik7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZHJhZyA9IF9hLmRyYWcsIF9iID0gX2EuZHJhZ0xpc3RlbmVyLCBkcmFnTGlzdGVuZXIgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xyXG4gICAgICAgICAgICBkcmFnICYmIGRyYWdMaXN0ZW5lciAmJiBfdGhpcy5zdGFydChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2NhbGVQb2ludCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzTmVlZFJlc29sdXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZHJhZ0NvbnN0cmFpbnRzID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYS50cmFuc2Zvcm1QYWdlUG9pbnQ7XHJcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IGNhbGN1bGF0ZUNvbnN0cmFpbnRzRnJvbURvbShkcmFnQ29uc3RyYWludHMsIHRoaXMucmVmLCB0aGlzLnBvaW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29uc3RyYWludHNUb1BvaW50KGNvbnN0cmFpbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRCb3hJbmZvKGNvbnN0cmFpbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLmNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDb25zdHJhaW50c1RvUG9pbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3RvcFBvaW50ZXJMaXN0ZW5lciAmJiBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIHN0b3BSZXNpemVMaXN0ZW5lciAmJiBzdG9wUmVzaXplTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2FuY2VsRHJhZygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudERyYWdDb250cm9scztcclxufSgpKTtcclxuLy8gQ2FsbCBhIGhhbmRsZXIgb25jZSBmb3IgZWFjaCBheGlzXHJcbmZ1bmN0aW9uIGJvdGhBeGlzKGhhbmRsZXIpIHtcclxuICAgIHJldHVybiBbaGFuZGxlcihcInhcIiksIGhhbmRsZXIoXCJ5XCIpXTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0UGFuVG9EcmFnKGluZm8sIHBvaW50KSB7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IHBvaW50OiB7XHJcbiAgICAgICAgICAgIHg6IHBvaW50LnggPyBwb2ludC54LmdldCgpIDogMCxcclxuICAgICAgICAgICAgeTogcG9pbnQueSA/IHBvaW50LnkuZ2V0KCkgOiAwLFxyXG4gICAgICAgIH0gfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29uc3RyYWludHMoYXhpcywgX2EpIHtcclxuICAgIHZhciB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbSwgbGVmdCA9IF9hLmxlZnQ7XHJcbiAgICBpZiAoYXhpcyA9PT0gXCJ4XCIpIHtcclxuICAgICAgICByZXR1cm4geyBtaW46IGxlZnQsIG1heDogcmlnaHQgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IG1pbjogdG9wLCBtYXg6IGJvdHRvbSB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNob3VsZERyYWcoZGlyZWN0aW9uLCBkcmFnLCBjdXJyZW50RGlyZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gKChkcmFnID09PSB0cnVlIHx8IGRyYWcgPT09IGRpcmVjdGlvbikgJiZcclxuICAgICAgICAoY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RGlyZWN0aW9uID09PSBkaXJlY3Rpb24pKTtcclxufVxyXG4vKipcclxuICogQmFzZWQgb24gYW4geC95IG9mZnNldCBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgZHJhZyBkaXJlY3Rpb24uIElmIGJvdGggYXhpcycgb2Zmc2V0cyBhcmUgbG93ZXJcclxuICogdGhhbiB0aGUgcHJvdmlkZWQgdGhyZXNob2xkLCByZXR1cm4gYG51bGxgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHgveSBvZmZzZXQgZnJvbSBvcmlnaW4uXHJcbiAqIEBwYXJhbSBsb2NrVGhyZXNob2xkIC0gKE9wdGlvbmFsKSAtIHRoZSBtaW5pbXVtIGFic29sdXRlIG9mZnNldCBiZWZvcmUgd2UgY2FuIGRldGVybWluZSBhIGRyYWcgZGlyZWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQsIGxvY2tUaHJlc2hvbGQpIHtcclxuICAgIGlmIChsb2NrVGhyZXNob2xkID09PSB2b2lkIDApIHsgbG9ja1RocmVzaG9sZCA9IDEwOyB9XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gbnVsbDtcclxuICAgIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ5XCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPiBsb2NrVGhyZXNob2xkKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ4XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyZWN0aW9uO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhIHBhcmVudCBFbGVtZW50IGFuZCBhIGRyYWdnYWJsZSBFbGVtZW50IGFuZCByZXR1cm5zIHBpeGVsLWJhc2VkIGRyYWcgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb25zdHJhaW50c1JlZlxyXG4gKiBAcGFyYW0gZHJhZ2dhYmxlUmVmXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVDb25zdHJhaW50c0Zyb21Eb20oY29uc3RyYWludHNSZWYsIGRyYWdnYWJsZVJlZiwgcG9pbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xyXG4gICAgaW52YXJpYW50KGNvbnN0cmFpbnRzUmVmLmN1cnJlbnQgIT09IG51bGwgJiYgZHJhZ2dhYmxlUmVmLmN1cnJlbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xyXG4gICAgdmFyIHBhcmVudEJvdW5kaW5nQm94ID0gZ2V0Qm91bmRpbmdCb3goY29uc3RyYWludHNSZWYsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XHJcbiAgICB2YXIgZHJhZ2dhYmxlQm91bmRpbmdCb3ggPSBnZXRCb3VuZGluZ0JveChkcmFnZ2FibGVSZWYsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XHJcbiAgICB2YXIgbGVmdCA9IHBhcmVudEJvdW5kaW5nQm94LmxlZnQgLVxyXG4gICAgICAgIGRyYWdnYWJsZUJvdW5kaW5nQm94LmxlZnQgK1xyXG4gICAgICAgIGdldEN1cnJlbnRPZmZzZXQocG9pbnQueCk7XHJcbiAgICB2YXIgdG9wID0gcGFyZW50Qm91bmRpbmdCb3gudG9wIC1cclxuICAgICAgICBkcmFnZ2FibGVCb3VuZGluZ0JveC50b3AgK1xyXG4gICAgICAgIGdldEN1cnJlbnRPZmZzZXQocG9pbnQueSk7XHJcbiAgICB2YXIgcmlnaHQgPSBwYXJlbnRCb3VuZGluZ0JveC53aWR0aCAtIGRyYWdnYWJsZUJvdW5kaW5nQm94LndpZHRoICsgbGVmdDtcclxuICAgIHZhciBib3R0b20gPSBwYXJlbnRCb3VuZGluZ0JveC5oZWlnaHQgLSBkcmFnZ2FibGVCb3VuZGluZ0JveC5oZWlnaHQgKyB0b3A7XHJcbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0LCBib3R0b206IGJvdHRvbSB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHJlZiwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XHJcbiAgICB2YXIgcmVjdCA9IHJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIF9hID0gdHJhbnNmb3JtUGFnZVBvaW50KHtcclxuICAgICAgICB4OiByZWN0LmxlZnQsXHJcbiAgICAgICAgeTogcmVjdC50b3AsXHJcbiAgICB9KSwgbGVmdCA9IF9hLngsIHRvcCA9IF9hLnk7XHJcbiAgICB2YXIgX2IgPSB0cmFuc2Zvcm1QYWdlUG9pbnQoe1xyXG4gICAgICAgIHg6IHJlY3Qud2lkdGgsXHJcbiAgICAgICAgeTogcmVjdC5oZWlnaHQsXHJcbiAgICB9KSwgd2lkdGggPSBfYi54LCBoZWlnaHQgPSBfYi55O1xyXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T2Zmc2V0KHBvaW50KSB7XHJcbiAgICByZXR1cm4gcG9pbnQgPyBwb2ludC5nZXQoKSA6IDA7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhheGlzLCB2YWx1ZSwgY29uc3RyYWludHMsIGRyYWdFbGFzdGljKSB7XHJcbiAgICB2YXIgY29uc3RyYWluZWRWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgTW90aW9uVmFsdWUgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xyXG4gICAgaWYgKCFjb25zdHJhaW50cykge1xyXG4gICAgICAgIHJldHVybiBjb25zdHJhaW5lZFZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gZ2V0Q29uc3RyYWludHMoYXhpcywgY29uc3RyYWludHMpLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heDtcclxuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBjb25zdHJhaW5lZFZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgY29uc3RyYWluZWRWYWx1ZSA9IGRyYWdFbGFzdGljXHJcbiAgICAgICAgICAgID8gYXBwbHlPdmVyZHJhZyhtaW4sIGNvbnN0cmFpbmVkVmFsdWUsIGRyYWdFbGFzdGljKVxyXG4gICAgICAgICAgICA6IE1hdGgubWF4KG1pbiwgY29uc3RyYWluZWRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBjb25zdHJhaW5lZFZhbHVlID4gbWF4KSB7XHJcbiAgICAgICAgY29uc3RyYWluZWRWYWx1ZSA9IGRyYWdFbGFzdGljXHJcbiAgICAgICAgICAgID8gYXBwbHlPdmVyZHJhZyhtYXgsIGNvbnN0cmFpbmVkVmFsdWUsIGRyYWdFbGFzdGljKVxyXG4gICAgICAgICAgICA6IE1hdGgubWluKG1heCwgY29uc3RyYWluZWRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNb3Rpb25WYWx1ZSkge1xyXG4gICAgICAgIHZhbHVlLnNldChjb25zdHJhaW5lZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25zdHJhaW5lZFZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5T3ZlcmRyYWcob3JpZ2luLCBjdXJyZW50LCBkcmFnRWxhc3RpYykge1xyXG4gICAgdmFyIGRyYWdGYWN0b3IgPSB0eXBlb2YgZHJhZ0VsYXN0aWMgPT09IFwibnVtYmVyXCIgPyBkcmFnRWxhc3RpYyA6IDAuMzU7XHJcbiAgICByZXR1cm4gbWl4KG9yaWdpbiwgY3VycmVudCwgZHJhZ0ZhY3Rvcik7XHJcbn1cblxuLyoqXHJcbiAqIEEgaG9vayB0aGF0IGFsbG93cyBhbiBlbGVtZW50IHRvIGJlIGRyYWdnZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJhbVxyXG4gKiBAcGFyYW0gcmVmXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHBhcmFtIGNvbnRyb2xzXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlRHJhZyhwcm9wcywgcmVmLCB2YWx1ZXMsIGNvbnRyb2xzKSB7XHJcbiAgICB2YXIgZ3JvdXBEcmFnQ29udHJvbHMgPSBwcm9wcy5kcmFnQ29udHJvbHM7XHJcbiAgICB2YXIgdHJhbnNmb3JtUGFnZVBvaW50ID0gdXNlQ29udGV4dChNb3Rpb25QbHVnaW5Db250ZXh0KS50cmFuc2Zvcm1QYWdlUG9pbnQ7XHJcbiAgICB2YXIgZHJhZ0NvbnRyb2xzID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENvbXBvbmVudERyYWdDb250cm9scyh7IHJlZjogcmVmLCB2YWx1ZXM6IHZhbHVlcywgY29udHJvbHM6IGNvbnRyb2xzIH0pOyB9KTtcclxuICAgIGRyYWdDb250cm9scy51cGRhdGVQcm9wcyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB7IHRyYW5zZm9ybVBhZ2VQb2ludDogdHJhbnNmb3JtUGFnZVBvaW50IH0pKTtcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBncm91cERyYWdDb250cm9scyAmJiBncm91cERyYWdDb250cm9scy5zdWJzY3JpYmUoZHJhZ0NvbnRyb2xzKTsgfSwgW2RyYWdDb250cm9sc10pO1xyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRyYWdDb250cm9scy5tb3VudChyZWYuY3VycmVudCk7IH0sIFtdKTtcclxufVxuXG52YXIgRHJhZyA9IHtcclxuICAgIGtleTogXCJkcmFnXCIsXHJcbiAgICBzaG91bGRSZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gISFwcm9wcy5kcmFnOyB9LFxyXG4gICAgQ29tcG9uZW50OiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaW5uZXJSZWYgPSBfYS5pbm5lclJlZiwgdmFsdWVzID0gX2EudmFsdWVzLCBjb250cm9scyA9IF9hLmNvbnRyb2xzLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiaW5uZXJSZWZcIiwgXCJ2YWx1ZXNcIiwgXCJjb250cm9sc1wiXSk7XHJcbiAgICAgICAgcmV0dXJuIHVzZURyYWcocHJvcHMsIGlubmVyUmVmLCB2YWx1ZXMsIGNvbnRyb2xzKTtcclxuICAgIH0pLFxyXG59O1xuXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoXCJ2YXIoLS1cIik7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIEZyYW1lcidzIHNwZWNpYWwgQ1NTIHZhcmlhYmxlIGZvcm1hdCBpbnRvIGEgQ1NTIHRva2VuIGFuZCBhIGZhbGxiYWNrLlxyXG4gKlxyXG4gKiBgYGBcclxuICogYHZhcigtLWZvbywgI2ZmZilgID0+IFtgLS1mb29gLCAnI2ZmZiddXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gY3VycmVudFxyXG4gKi9cclxudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcclxuZnVuY3Rpb24gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBjc3NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XHJcbiAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgIHJldHVybiBbLF07XHJcbiAgICB2YXIgdG9rZW4gPSBtYXRjaFsxXSwgZmFsbGJhY2sgPSBtYXRjaFsyXTtcclxuICAgIHJldHVybiBbdG9rZW4sIGZhbGxiYWNrXTtcclxufVxyXG52YXIgbWF4RGVwdGggPSA0O1xyXG5mdW5jdGlvbiBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQsIGRlcHRoKSB7XHJcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDE7IH1cclxuICAgIGludmFyaWFudChkZXB0aCA8PSBtYXhEZXB0aCwgXCJNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFxcXCJcIiArIGN1cnJlbnQgKyBcIlxcXCIuIFRoaXMgbWF5IGluZGljYXRlIGEgY2lyY3VsYXIgZmFsbGJhY2sgZGVwZW5kZW5jeS5cIik7XHJcbiAgICB2YXIgX2EgPSBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpLCB0b2tlbiA9IF9hWzBdLCBmYWxsYmFjayA9IF9hWzFdO1xyXG4gICAgLy8gTm8gQ1NTIHZhcmlhYmxlIGRldGVjdGVkXHJcbiAgICBpZiAoIXRva2VuKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIEF0dGVtcHQgdG8gcmVhZCB0aGlzIENTUyB2YXJpYWJsZSBvZmYgdGhlIGVsZW1lbnRcclxuICAgIHZhciByZXNvbHZlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xyXG4gICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNDU1NWYXJpYWJsZShmYWxsYmFjaykpIHtcclxuICAgICAgICAvLyBUaGUgZmFsbGJhY2sgbWlnaHQgaXRzZWxmIGJlIGEgQ1NTIHZhcmlhYmxlLCBpbiB3aGljaCBjYXNlIHdlIGF0dGVtcHQgdG8gcmVzb2x2ZSBpdCB0b28uXHJcbiAgICAgICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgQ1NTIHZhcmlhYmxlcyBmcm9tXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2YWx1ZXMsIHJlZiwgX2EsIHRyYW5zaXRpb25FbmQpIHtcclxuICAgIHZhciB0YXJnZXQgPSBfX3Jlc3QoX2EsIFtdKTtcclxuICAgIHZhciBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxyXG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XHJcbiAgICAvLyBJZiBgdHJhbnNpdGlvbkVuZGAgaXNuJ3QgYHVuZGVmaW5lZGAsIGNsb25lIGl0LiBXZSBjb3VsZCBjbG9uZSBgdGFyZ2V0YCBhbmQgYHRyYW5zaXRpb25FbmRgXHJcbiAgICAvLyBvbmx5IGlmIHRoZXkgY2hhbmdlIGJ1dCBJIHRoaW5rIHRoaXMgcmVhZHMgY2xlYXJlciBhbmQgdGhpcyBpc24ndCBhIHBlcmZvcm1hbmNlLWNyaXRpY2FsIHBhdGguXHJcbiAgICBpZiAodHJhbnNpdGlvbkVuZCkge1xyXG4gICAgICAgIHRyYW5zaXRpb25FbmQgPSBfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBHbyB0aHJvdWdoIGV4aXN0aW5nIGBNb3Rpb25WYWx1ZWBzIGFuZCBlbnN1cmUgYW55IGV4aXN0aW5nIENTUyB2YXJpYWJsZXMgYXJlIHJlc29sdmVkXHJcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHZhbHVlLmdldCgpO1xyXG4gICAgICAgIGlmICghaXNDU1NWYXJpYWJsZShjdXJyZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVkKVxyXG4gICAgICAgICAgICB2YWx1ZS5zZXQocmVzb2x2ZWQpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGV2ZXJ5IHRhcmdldCBwcm9wZXJ0eSBhbmQgcmVzb2x2ZSBDU1MgdmFyaWFibGVzLiBDdXJyZW50bHlcclxuICAgIC8vIHdlIG9ubHkgcmVhZCBzaW5nbGUtdmFyIHByb3BlcnRpZXMgbGlrZSBgdmFyKC0tZm9vKWAsIG5vdCBgY2FsYyh2YXIoLS1mb28pICsgMjBweClgXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoIWlzQ1NTVmFyaWFibGUoY3VycmVudCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgLy8gQ2xvbmUgdGFyZ2V0IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cclxuICAgICAgICB0YXJnZXRba2V5XSA9IHJlc29sdmVkO1xyXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBhbHJlYWR5IHNldCB0aGlzIGtleSBvbiBgdHJhbnNpdGlvbkVuZGAsIHNldCBpdCB0byB0aGUgdW5yZXNvbHZlZFxyXG4gICAgICAgIC8vIENTUyB2YXJpYWJsZS4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIHRoZSBhbmltYXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHJlZmxlY3RcclxuICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgQ1NTIHZhcmlhYmxlLlxyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uRW5kICYmIHRyYW5zaXRpb25FbmRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcclxufVxuXG52YXIgcG9zaXRpb25hbEtleXMgPSBuZXcgU2V0KFtcclxuICAgIFwid2lkdGhcIixcclxuICAgIFwiaGVpZ2h0XCIsXHJcbiAgICBcInRvcFwiLFxyXG4gICAgXCJsZWZ0XCIsXHJcbiAgICBcInJpZ2h0XCIsXHJcbiAgICBcImJvdHRvbVwiLFxyXG4gICAgXCJ4XCIsXHJcbiAgICBcInlcIixcclxuXSk7XHJcbnZhciBpc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwb3NpdGlvbmFsS2V5cy5oYXMoa2V5KTsgfTtcclxudmFyIGhhc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5zb21lKGlzUG9zaXRpb25hbEtleSk7XHJcbn07XHJcbnZhciBzZXRBbmRSZXNldFZlbG9jaXR5ID0gZnVuY3Rpb24gKHZhbHVlLCB0bykge1xyXG4gICAgLy8gTG9va3Mgb2RkIGJ1dCBzZXR0aW5nIGl0IHR3aWNlIGRvZXNuJ3QgcmVuZGVyLCBpdCdsbCBqdXN0XHJcbiAgICAvLyBzZXQgYm90aCBwcmV2IGFuZCBjdXJyZW50IHRvIHRoZSBsYXRlc3QgdmFsdWVcclxuICAgIHZhbHVlLnNldCh0bywgZmFsc2UpO1xyXG4gICAgdmFsdWUuc2V0KHRvKTtcclxufTtcclxudmFyIGlzTnVtT3JQeFR5cGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcclxufTtcclxudmFyIEJvdW5kaW5nQm94RGltZW5zaW9uO1xyXG4oZnVuY3Rpb24gKEJvdW5kaW5nQm94RGltZW5zaW9uKSB7XHJcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcIndpZHRoXCJdID0gXCJ3aWR0aFwiO1xyXG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJoZWlnaHRcIl0gPSBcImhlaWdodFwiO1xyXG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XHJcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xyXG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJ0b3BcIl0gPSBcInRvcFwiO1xyXG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJib3R0b21cIl0gPSBcImJvdHRvbVwiO1xyXG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xyXG52YXIgZ2V0UG9zRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgsIHBvcykge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XHJcbn07XHJcbnZhciBnZXRUcmFuc2xhdGVGcm9tTWF0cml4ID0gZnVuY3Rpb24gKHBvczIsIHBvczMpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm07XHJcbiAgICBpZiAodHJhbnNmb3JtID09PSBcIm5vbmVcIiB8fCAhdHJhbnNmb3JtKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC8pO1xyXG4gICAgaWYgKG1hdHJpeDNkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XHJcbiAgICAgICAgaWYgKG1hdHJpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeChtYXRyaXhbMV0sIHBvczIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyB9O1xyXG52YXIgdHJhbnNmb3JtS2V5cyA9IG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcclxudmFyIG5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzID0gdHJhbnNmb3JtUHJvcHMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICF0cmFuc2Zvcm1LZXlzLmhhcyhrZXkpOyB9KTtcclxuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2YWx1ZXMsIGVsZW1lbnRTdHlsZXIpIHtcclxuICAgIHZhciByZW1vdmVkVHJhbnNmb3JtcyA9IFtdO1xyXG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzLmdldChrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZWRUcmFuc2Zvcm1zLnB1c2goW2tleSwgdmFsdWUuZ2V0KCldKTtcclxuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIGVsZW1lbnQgYmVmb3JlIG1lYXN1cmVtZW50XHJcbiAgICBpZiAocmVtb3ZlZFRyYW5zZm9ybXMubGVuZ3RoKVxyXG4gICAgICAgIGVsZW1lbnRTdHlsZXIucmVuZGVyKCk7XHJcbiAgICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XHJcbn1cclxudmFyIHBvc2l0aW9uYWxWYWx1ZXMgPSB7XHJcbiAgICAvLyBEaW1lbnNpb25zXHJcbiAgICB3aWR0aDogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfSxcclxuICAgIGhlaWdodDogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xyXG4gICAgfSxcclxuICAgIHRvcDogZnVuY3Rpb24gKF9iYm94LCBfYSkge1xyXG4gICAgICAgIHZhciB0b3AgPSBfYS50b3A7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG9wKTtcclxuICAgIH0sXHJcbiAgICBsZWZ0OiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBfYS5sZWZ0O1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpO1xyXG4gICAgfSxcclxuICAgIGJvdHRvbTogZnVuY3Rpb24gKF9hLCBfYikge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRvcCA9IF9iLnRvcDtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3ApICsgaGVpZ2h0O1xyXG4gICAgfSxcclxuICAgIHJpZ2h0OiBmdW5jdGlvbiAoX2EsIF9iKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBfYi5sZWZ0O1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpICsgd2lkdGg7XHJcbiAgICB9LFxyXG4gICAgLy8gVHJhbnNmb3JtXHJcbiAgICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcclxuICAgIHk6IGdldFRyYW5zbGF0ZUZyb21NYXRyaXgoNSwgMTQpLFxyXG59O1xyXG52YXIgY29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWVzLCBlbGVtZW50LCBlbGVtZW50U3R5bGVyLCBjaGFuZ2VkS2V5cykge1xyXG4gICAgdmFyIG9yaWdpbkJib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIGVsZW1lbnRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgIHZhciBkaXNwbGF5ID0gZWxlbWVudENvbXB1dGVkU3R5bGUuZGlzcGxheSwgdG9wID0gZWxlbWVudENvbXB1dGVkU3R5bGUudG9wLCBsZWZ0ID0gZWxlbWVudENvbXB1dGVkU3R5bGUubGVmdCwgYm90dG9tID0gZWxlbWVudENvbXB1dGVkU3R5bGUuYm90dG9tLCByaWdodCA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLnJpZ2h0LCB0cmFuc2Zvcm0gPSBlbGVtZW50Q29tcHV0ZWRTdHlsZS50cmFuc2Zvcm07XHJcbiAgICB2YXIgb3JpZ2luQ29tcHV0ZWRTdHlsZSA9IHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIGJvdHRvbTogYm90dG9tLCByaWdodDogcmlnaHQsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH07XHJcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgc2V0IHRvIGRpc3BsYXk6IFwibm9uZVwiLCBtYWtlIGl0IHZpc2libGUgYmVmb3JlXHJcbiAgICAvLyBtZWFzdXJpbmcgdGhlIHRhcmdldCBib3VuZGluZyBib3hcclxuICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgIGVsZW1lbnRTdHlsZXIuc2V0KFwiZGlzcGxheVwiLCB0YXJnZXQuZGlzcGxheSB8fCBcImJsb2NrXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gQXBwbHkgdGhlIGxhdGVzdCB2YWx1ZXMgKGFzIHNldCBpbiBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcylcclxuICAgIGVsZW1lbnRTdHlsZXIucmVuZGVyKCk7XHJcbiAgICB2YXIgdGFyZ2V0QmJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjaGFuZ2VkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAvLyBSZXN0b3JlIHN0eWxlcyB0byB0aGVpciAqKmNhbGN1bGF0ZWQgY29tcHV0ZWQgc3R5bGUqKiwgbm90IHRoZWlyIGFjdHVhbFxyXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgc2V0IHN0eWxlLiBUaGlzIGFsbG93cyB1cyB0byBhbmltYXRlIGJldHdlZW4gZXF1aXZhbGVudCBwaXhlbCB1bml0cy5cclxuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMuZ2V0KGtleSk7XHJcbiAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgcG9zaXRpb25hbFZhbHVlc1trZXldKG9yaWdpbkJib3gsIG9yaWdpbkNvbXB1dGVkU3R5bGUpKTtcclxuICAgICAgICB0YXJnZXRba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XSh0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcbnZhciBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHJlZiwgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kKSB7XHJcbiAgICBpZiAodHJhbnNpdGlvbkVuZCA9PT0gdm9pZCAwKSB7IHRyYW5zaXRpb25FbmQgPSB7fTsgfVxyXG4gICAgdGFyZ2V0ID0gX19hc3NpZ24oe30sIHRhcmdldCk7XHJcbiAgICB0cmFuc2l0aW9uRW5kID0gX19hc3NpZ24oe30sIHRyYW5zaXRpb25FbmQpO1xyXG4gICAgdmFyIGVsZW1lbnQgPSByZWYuY3VycmVudDtcclxuICAgIHZhciBlbGVtZW50U3R5bGVyID0gc3R5bGVyKGVsZW1lbnQpO1xyXG4gICAgdmFyIHRhcmdldFBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIoaXNQb3NpdGlvbmFsS2V5KTtcclxuICAgIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIGFueSB0cmFuc2Zvcm0gdmFsdWVzIHRoYXQgY291bGQgYWZmZWN0IHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94IGJlZm9yZVxyXG4gICAgLy8gaXQncyBtZWFzdXJlZC4gV2UnbGwgcmVhcHBseSB0aGVzZSBsYXRlci5cclxuICAgIHZhciByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gW107XHJcbiAgICB2YXIgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSBmYWxzZTtcclxuICAgIHZhciBjaGFuZ2VkVmFsdWVUeXBlS2V5cyA9IHRhcmdldFBvc2l0aW9uYWxLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB2YXIgZnJvbSA9IHZhbHVlLmdldCgpO1xyXG4gICAgICAgIHZhciB0byA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIHZhciBmcm9tVHlwZSA9IGdldERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcclxuICAgICAgICB2YXIgdG9UeXBlO1xyXG4gICAgICAgIC8vIFRPRE86IFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgYmFzaWNhbGx5IHRocm93cyBhbiBlcnJvclxyXG4gICAgICAgIC8vIGlmIHlvdSB0cnkgYW5kIGRvIHZhbHVlIGNvbnZlcnNpb24gdmlhIGtleWZyYW1lcy4gVGhlcmUncyBwcm9iYWJseVxyXG4gICAgICAgIC8vIGEgd2F5IG9mIGRvaW5nIHRoaXMgYnV0IHRoZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMgd291bGQgbmVlZCBncmVhdGVyIHNjcnV0aW55LFxyXG4gICAgICAgIC8vIGFzIGl0J2QgYmUgZG9pbmcgbXVsdGlwbGUgcmVzaXplLXJlbWVhc3VyZSBvcGVyYXRpb25zLlxyXG4gICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcclxuICAgICAgICAgICAgdmFyIG51bUtleWZyYW1lcyA9IHRvLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7IGkgPCBudW1LZXlmcmFtZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0b1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b1R5cGUgPSBnZXREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGludmFyaWFudCh0b1R5cGUgPT09IGZyb21UeXBlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc051bU9yUHhUeXBlKGZyb21UeXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSwgXCJLZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYXMgdGhlIGN1cnJlbnQgdmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZhcmlhbnQoZ2V0RGltZW5zaW9uVmFsdWVUeXBlKHRvW2ldKSA9PT0gdG9UeXBlLCBcIkFsbCBrZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b1R5cGUgPSBnZXREaW1lbnNpb25WYWx1ZVR5cGUodG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVR5cGUgIT09IHRvVHlwZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGJvdGgganVzdCBudW1iZXIgb3IgcHgsIGNvbnZlcnQgdGhlbSBib3RoIHRvIG51bWJlcnMgcmF0aGVyIHRoYW5cclxuICAgICAgICAgICAgLy8gcmVseWluZyBvbiByZXNpemUvcmVtZWFzdXJlIHRvIGNvbnZlcnQgKHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoaXMgc2l0dWF0aW9uKVxyXG4gICAgICAgICAgICBpZiAoaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHZhbHVlLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KHBhcnNlRmxvYXQoY3VycmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcGFyc2VGbG9hdCh0byk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRvKSAmJiB0b1R5cGUgPT09IHB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB0by5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byBkbyB2YWx1ZSBjb252ZXJzaW9uIHZpYSBET00gbWVhc3VyZW1lbnRzLCB3ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbm9uLXBvc2l0aW9uYWwgdHJhbnNmb3JtIHZhbHVlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgYmJveCBtZWFzdXJlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9IHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmFsdWVzLCBlbGVtZW50U3R5bGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY2MucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkVuZFtrZXldID1cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25FbmRba2V5XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgdG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBpZiAoY2hhbmdlZFZhbHVlVHlwZUtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGNvbnZlcnRlZFRhcmdldCA9IGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyh0YXJnZXQsIHZhbHVlcywgZWxlbWVudCwgZWxlbWVudFN0eWxlciwgY2hhbmdlZFZhbHVlVHlwZUtleXMpO1xyXG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgdHJhbnNmb3JtIHZhbHVlcywgcmVhcHBseSB0aGVtIGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcclxuICAgICAgICBpZiAocmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLmdldChrZXkpLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZWFwcGx5IG9yaWdpbmFsIHZhbHVlc1xyXG4gICAgICAgIGVsZW1lbnRTdHlsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiBjb252ZXJ0ZWRUYXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDb252ZXJ0IHZhbHVlIHR5cGVzIGZvciB4L3kvd2lkdGgvaGVpZ2h0L3RvcC9sZWZ0L2JvdHRvbS9yaWdodFxyXG4gKlxyXG4gKiBBbGxvd3MgYW5pbWF0aW9uIGJldHdlZW4gYCdhdXRvJ2AgLT4gYCcxMDAlJ2Agb3IgYDBgIC0+IGAnY2FsYyg1MCUgLSAxMHZ3KSdgXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHBhcmFtIHJlZlxyXG4gKiBAcGFyYW0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB0cmFuc2l0aW9uRW5kXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdW5pdENvbnZlcnNpb24odmFsdWVzLCByZWYsIHRhcmdldCwgdHJhbnNpdGlvbkVuZCkge1xyXG4gICAgcmV0dXJuIGhhc1Bvc2l0aW9uYWxLZXkodGFyZ2V0KVxyXG4gICAgICAgID8gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModmFsdWVzLCByZWYsIHRhcmdldCwgdHJhbnNpdGlvbkVuZClcclxuICAgICAgICA6IHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcclxufVxuXG52YXIgcGFyc2VEb21WYXJpYW50ID0gZnVuY3Rpb24gKHZhbHVlcywgcmVmKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdHJhbnNpdGlvbkVuZCkge1xyXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVDU1NWYXJpYWJsZXModmFsdWVzLCByZWYsIHRhcmdldCwgdHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgICAgdGFyZ2V0ID0gcmVzb2x2ZWQudGFyZ2V0O1xyXG4gICAgICAgIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kO1xyXG4gICAgICAgIHJldHVybiB1bml0Q29udmVyc2lvbih2YWx1ZXMsIHJlZiwgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kKTtcclxuICAgIH07XHJcbn07XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xyXG4gICAgdmFyIF9hID0gdXNlU3RhdGUoMCksIGZvcmNlZFJlbmRlckNvdW50ID0gX2FbMF0sIHNldEZvcmNlZFJlbmRlckNvdW50ID0gX2FbMV07XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0Rm9yY2VkUmVuZGVyQ291bnQoZm9yY2VkUmVuZGVyQ291bnQgKyAxKTsgfSwgW1xyXG4gICAgICAgIGZvcmNlZFJlbmRlckNvdW50LFxyXG4gICAgXSk7XHJcbn1cblxudmFyIFN5bmNMYXlvdXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuLyoqXHJcbiAqIFdoZW4gbGF5b3V0IGNoYW5nZXMgaGFwcGVuIGFzeW5jaHJvbm91c2x5IHRvIHRoZWlyIGluc3RpZ2F0aW5nIHJlbmRlciAoaWUgd2hlbiBleGl0aW5nXHJcbiAqIGNoaWxkcmVuIG9mIGBBbmltYXRlUHJlc2VuY2VgIGFyZSByZW1vdmVkKSwgYFN5bmNMYXlvdXRgIGNhbiB3cmFwIHBhcmVudCBhbmQgc2libGluZ1xyXG4gKiBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBhbmltYXRlIGFzIGEgcmVzdWx0IG9mIHRoaXMgbGF5b3V0IGNoYW5nZS5cclxuICpcclxuICogQG1vdGlvblxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogY29uc3QgTXlDb21wb25lbnQgPSAoeyBpc1Zpc2libGUgfSkgPT4ge1xyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8U3luY0xheW91dD5cclxuICogICAgICAgPEFuaW1hdGVQcmVzZW5jZT5cclxuICogICAgICAgICB7aXNWaXNpYmxlICYmIChcclxuICogICAgICAgICAgIDxtb3Rpb24uZGl2IGV4aXQ9e3sgb3BhY2l0eTogMCB9fSAvPlxyXG4gKiAgICAgICAgICl9XHJcbiAqICAgICAgIDwvQW5pbWF0ZVByZXNlbmNlPlxyXG4gKiAgICAgICA8bW90aW9uLmRpdiBwb3NpdGlvblRyYW5zaXRpb24gLz5cclxuICogICAgIDwvU3luY0xheW91dD5cclxuICogICApXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBpbnRlcm5hbHJlbWFya3NcclxuICpcclxuICogVGhlIHdheSB0aGlzIGNvbXBvbmVudCB3b3JrcyBpcyBieSBtZW1vaXNpbmcgYSBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBkb3duIHZpYSBjb250ZXh0LlxyXG4gKiBUaGUgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB1cGRhdGVzIHRoZSBsb2NhbCBzdGF0ZSwgd2hpY2ggaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZVxyXG4gKiBtZW1vaXNhdGlvbiBjYWNoZS4gQSBuZXcgZnVuY3Rpb24gaXMgY2FsbGVkLCBwZXJmb3JtaW5nIGEgc3luY2VkIHJlLXJlbmRlciBvZiBjb21wb25lbnRzXHJcbiAqIHRoYXQgYXJlIHVzaW5nIHRoZSBTeW5jTGF5b3V0Q29udGV4dC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgVW5zdGFibGVTeW5jTGF5b3V0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcclxuICAgIHZhciBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoU3luY0xheW91dENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGZvcmNlVXBkYXRlIH0sIGNoaWxkcmVuKSk7XHJcbn07XG5cbnZhciBfYTtcclxudmFyIFN0ZXBOYW1lO1xyXG4oZnVuY3Rpb24gKFN0ZXBOYW1lKSB7XHJcbiAgICBTdGVwTmFtZVtcIlByZXBhcmVcIl0gPSBcInByZXBhcmVcIjtcclxuICAgIFN0ZXBOYW1lW1wiUmVhZFwiXSA9IFwicmVhZFwiO1xyXG4gICAgU3RlcE5hbWVbXCJSZW5kZXJcIl0gPSBcInJlbmRlclwiO1xyXG59KShTdGVwTmFtZSB8fCAoU3RlcE5hbWUgPSB7fSkpO1xyXG52YXIgc3RlcE9yZGVyID0gW1N0ZXBOYW1lLlByZXBhcmUsIFN0ZXBOYW1lLlJlYWQsIFN0ZXBOYW1lLlJlbmRlcl07XHJcbnZhciBqb2JzID0gc3RlcE9yZGVyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcclxuICAgIGFjY1trZXldID0gW107XHJcbiAgICByZXR1cm4gYWNjO1xyXG59LCB7fSk7XHJcbnZhciBqb2JzTmVlZFByb2Nlc3NpbmcgPSBmYWxzZTtcclxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja0xpc3QobGlzdCkge1xyXG4gICAgdmFyIG51bUpvYnMgPSBsaXN0Lmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSm9iczsgaSsrKSB7XHJcbiAgICAgICAgbGlzdFtpXSgpO1xyXG4gICAgfVxyXG4gICAgbGlzdC5sZW5ndGggPSAwO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoQWxsSm9icygpIHtcclxuICAgIGlmICgham9ic05lZWRQcm9jZXNzaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGZsdXNoQ2FsbGJhY2tMaXN0KGpvYnMucHJlcGFyZSk7XHJcbiAgICBmbHVzaENhbGxiYWNrTGlzdChqb2JzLnJlYWQpO1xyXG4gICAgZmx1c2hDYWxsYmFja0xpc3Qoam9icy5yZW5kZXIpO1xyXG4gICAgam9ic05lZWRQcm9jZXNzaW5nID0gZmFsc2U7XHJcbn1cclxuLy8gTm90ZTogVGhlIGFwcHJvYWNoIG9mIHNjaGVkdWxuZyBqb2JzIGR1cmluZyB0aGUgcmVuZGVyIHN0ZXAgaXMgaW5jb21wYXRpYmxlIHdpdGggY29uY3VycmVudCBtb2RlXHJcbi8vIHdoZXJlIG11bHRpcGxlIHJlbmRlcnMgbWlnaHQgaGFwcGVuIHdpdGhvdXQgYSBET00gdXBkYXRlLiBUaGlzIHdvdWxkIHJlc3VsdCBpbiB1bm5lY2Nlc3NhcnkgYmF0Y2hlZFxyXG4vLyBqb2JzLiBCdXQgdGhpcyB3YXMgYWxyZWFkeSBhIHByb2JsZW0gd2l0aCBvdXIgcHJldmlvdXMgYXBwcm9hY2ggdG8gcG9zaXRpb25UcmFuc2l0aW9uLlxyXG4vLyBIb3BlZnVsbHkgdGhlIFJlYWN0IHRlYW0gb2ZmZXIgYSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS1lc3F1ZSBob29rIGFuZCB3ZSBjYW4gbW92ZSB0byB0aGF0LlxyXG52YXIgY3JlYXRlVXNlU3luY0VmZmVjdCA9IGZ1bmN0aW9uIChzdGVwTmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGpvYnNOZWVkUHJvY2Vzc2luZyA9IHRydWU7XHJcbiAgICBqb2JzW3N0ZXBOYW1lXS5wdXNoKGNhbGxiYWNrKTtcclxufTsgfTtcclxudmFyIGxheW91dFN5bmMgPSAoX2EgPSB7fSxcclxuICAgIF9hW1N0ZXBOYW1lLlByZXBhcmVdID0gY3JlYXRlVXNlU3luY0VmZmVjdChTdGVwTmFtZS5QcmVwYXJlKSxcclxuICAgIF9hW1N0ZXBOYW1lLlJlYWRdID0gY3JlYXRlVXNlU3luY0VmZmVjdChTdGVwTmFtZS5SZWFkKSxcclxuICAgIF9hW1N0ZXBOYW1lLlJlbmRlcl0gPSBjcmVhdGVVc2VTeW5jRWZmZWN0KFN0ZXBOYW1lLlJlbmRlciksXHJcbiAgICBfYS5mbHVzaCA9IGZsdXNoQWxsSm9icyxcclxuICAgIF9hKTtcblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xyXG59XG5cbnZhciBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcclxuICAgIGR1cmF0aW9uOiAwLjgsXHJcbiAgICBlYXNlOiBbMC40NSwgMC4wNSwgMC4xOSwgMS4wXSxcclxufTtcclxudmFyIGRlZmF1bHRQb3NpdGlvblRyYW5zaXRpb24gPSB1bmRlckRhbXBlZFNwcmluZygpO1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0TGF5b3V0VHJhbnNpdGlvbihpc1Bvc2l0aW9uT25seSkge1xyXG4gICAgcmV0dXJuIGlzUG9zaXRpb25Pbmx5ID8gZGVmYXVsdFBvc2l0aW9uVHJhbnNpdGlvbiA6IGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVzb2x2ZXIodHJhbnNpdGlvbikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0cmFuc2l0aW9uID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxudmFyIGF4aXNMYWJlbHMgPSB7XHJcbiAgICB4OiB7XHJcbiAgICAgICAgaWQ6IFwieFwiLFxyXG4gICAgICAgIHNpemU6IFwid2lkdGhcIixcclxuICAgICAgICBtaW46IFwibGVmdFwiLFxyXG4gICAgICAgIG1heDogXCJyaWdodFwiLFxyXG4gICAgICAgIG9yaWdpbjogXCJvcmlnaW5YXCIsXHJcbiAgICB9LFxyXG4gICAgeToge1xyXG4gICAgICAgIGlkOiBcInlcIixcclxuICAgICAgICBzaXplOiBcImhlaWdodFwiLFxyXG4gICAgICAgIG1pbjogXCJ0b3BcIixcclxuICAgICAgICBtYXg6IFwiYm90dG9tXCIsXHJcbiAgICAgICAgb3JpZ2luOiBcIm9yaWdpbllcIixcclxuICAgIH0sXHJcbn07XHJcbmZ1bmN0aW9uIGNlbnRlck9mKG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gKG1pbiArIG1heCkgLyAyO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGNBeGlzRGVsdGEocHJldiwgbmV4dCwgbmFtZXMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBzaXplRGVsdGEgPSBwcmV2W25hbWVzLnNpemVdIC0gbmV4dFtuYW1lcy5zaXplXTtcclxuICAgIHZhciBvcmlnaW4gPSAwLjU7XHJcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgY2hhbmdlZCBzaXplIHdlIHdhbnQgdG8gY2hlY2sgd2hldGhlciBlaXRoZXIgc2lkZSBpcyBpblxyXG4gICAgLy8gdGhlIHNhbWUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoZSBsYXlvdXQgdHJhbnNpdGlvbi4gSWYgc28sIHdlIGNhbiBhbmNob3JcclxuICAgIC8vIHRoZSBlbGVtZW50IHRvIHRoYXQgcG9zaXRpb24gYW5kIG9ubHkgYW5pbWF0ZSBpdHMgc2l6ZS5cclxuICAgIGlmIChzaXplRGVsdGEpIHtcclxuICAgICAgICBpZiAocHJldltuYW1lcy5taW5dID09PSBuZXh0W25hbWVzLm1pbl0pIHtcclxuICAgICAgICAgICAgb3JpZ2luID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJldltuYW1lcy5tYXhdID09PSBuZXh0W25hbWVzLm1heF0pIHtcclxuICAgICAgICAgICAgb3JpZ2luID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgZGVsdGEgPSAoX2EgPSB7fSxcclxuICAgICAgICBfYVtuYW1lcy5zaXplXSA9IHNpemVEZWx0YSxcclxuICAgICAgICBfYVtuYW1lcy5vcmlnaW5dID0gb3JpZ2luLFxyXG4gICAgICAgIF9hW25hbWVzLmlkXSA9IFxyXG4gICAgICAgIC8vIE9ubHkgbWVhc3VyZSBhIHBvc2l0aW9uIGRlbHRhIGlmIHdlIGhhdmVuJ3QgYW5jaG9yZWQgdG8gb25lIHNpZGVcclxuICAgICAgICBvcmlnaW4gPT09IDAuNVxyXG4gICAgICAgICAgICA/IGNlbnRlck9mKHByZXZbbmFtZXMubWluXSwgcHJldltuYW1lcy5tYXhdKSAtXHJcbiAgICAgICAgICAgICAgICBjZW50ZXJPZihuZXh0W25hbWVzLm1pbl0sIG5leHRbbmFtZXMubWF4XSlcclxuICAgICAgICAgICAgOiAwLFxyXG4gICAgICAgIF9hKTtcclxuICAgIHJldHVybiBkZWx0YTtcclxufVxyXG5mdW5jdGlvbiBjYWxjRGVsdGEocHJldiwgbmV4dCkge1xyXG4gICAgdmFyIGRlbHRhID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhbGNBeGlzRGVsdGEocHJldiwgbmV4dCwgYXhpc0xhYmVscy54KSksIGNhbGNBeGlzRGVsdGEocHJldiwgbmV4dCwgYXhpc0xhYmVscy55KSk7XHJcbiAgICByZXR1cm4gZGVsdGE7XHJcbn1cclxudmFyIG9mZnNldCA9IHtcclxuICAgIGdldExheW91dDogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IF9hLm9mZnNldDtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfSxcclxuICAgIG1lYXN1cmU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQsIG9mZnNldFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wLCBvZmZzZXRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXHJcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICBib3R0b206IG9mZnNldFRvcCArIG9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG9mZnNldEhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxudmFyIGJvdW5kaW5nQm94ID0ge1xyXG4gICAgZ2V0TGF5b3V0OiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBfYS5ib3VuZGluZ0JveDtcclxuICAgICAgICByZXR1cm4gYm91bmRpbmdCb3g7XHJcbiAgICB9LFxyXG4gICAgbWVhc3VyZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX2EgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcclxuICAgICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcmlnaHQ6IHJpZ2h0LCBib3R0b206IGJvdHRvbSB9O1xyXG4gICAgfSxcclxufTtcclxuZnVuY3Rpb24gcmVhZFBvc2l0aW9uU3R5bGUoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGdldExheW91dFR5cGUocHJldiwgbmV4dCwgaXNQb3NpdGlvbk9ubHkpIHtcclxuICAgIHJldHVybiBpc1Bvc2l0aW9uT25seSAmJiBwcmV2ID09PSBuZXh0ID8gb2Zmc2V0IDogYm91bmRpbmdCb3g7XHJcbn1cclxuZnVuY3Rpb24gaXNTaXplS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleSA9PT0gXCJ3aWR0aFwiIHx8IGtleSA9PT0gXCJoZWlnaHRcIjtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uKF9hKSB7XHJcbiAgICB2YXIgbGF5b3V0VHJhbnNpdGlvbiA9IF9hLmxheW91dFRyYW5zaXRpb24sIHBvc2l0aW9uVHJhbnNpdGlvbiA9IF9hLnBvc2l0aW9uVHJhbnNpdGlvbjtcclxuICAgIHJldHVybiBsYXlvdXRUcmFuc2l0aW9uIHx8IHBvc2l0aW9uVHJhbnNpdGlvbjtcclxufVxyXG52YXIgTGF5b3V0QW5pbWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExheW91dEFuaW1hdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExheW91dEFuaW1hdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBNZWFzdXJlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBET00gYmVmb3JlIGl0J3MgdXBkYXRlZCwgYW5kIHNjaGVkdWxlIGNoZWNrcyB0byBzZWVcclxuICAgIC8vIGlmIGl0J3MgY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiBhIFJlYWN0IHJlbmRlci5cclxuICAgIExheW91dEFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaW5uZXJSZWYgPSBfYS5pbm5lclJlZiwgcG9zaXRpb25UcmFuc2l0aW9uID0gX2EucG9zaXRpb25UcmFuc2l0aW9uLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIGNvbnRyb2xzID0gX2EuY29udHJvbHM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBpbm5lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBsYXlvdXRUcmFuc2l0aW9uID0gZ2V0VHJhbnNpdGlvbih0aGlzLnByb3BzKTtcclxuICAgICAgICB2YXIgaXNQb3NpdGlvbk9ubHkgPSAhIXBvc2l0aW9uVHJhbnNpdGlvbjtcclxuICAgICAgICB2YXIgcG9zaXRpb25TdHlsZSA9IHJlYWRQb3NpdGlvblN0eWxlKGVsZW1lbnQpO1xyXG4gICAgICAgIHZhciBwcmV2ID0ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldC5tZWFzdXJlKGVsZW1lbnQpLFxyXG4gICAgICAgICAgICBib3VuZGluZ0JveDogYm91bmRpbmdCb3gubWVhc3VyZShlbGVtZW50KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIG5leHQ7XHJcbiAgICAgICAgdmFyIGNvbXBhcmU7XHJcbiAgICAgICAgLy8gV2Ugc3BsaXQgdGhlIHVuc2V0dGluZywgcmVhZCBhbmQgcmVhcHBsaWNhdGlvbiBvZiB0aGUgYHRyYW5zZm9ybWAgc3R5bGUgcHJvcCBpbnRvXHJcbiAgICAgICAgLy8gZGlmZmVyZW50IHN0ZXBzIHZpYSB1c2VTeW5jRWZmZWN0LiBNdWx0aXBsZSBjb21wb25lbnRzIG1pZ2h0IGFsbCBiZSBkb2luZyB0aGUgc2FtZVxyXG4gICAgICAgIC8vIHRoaW5nIGFuZCBieSBzcGxpdHRpbmcgdGhlc2Ugam9icyBhbmQgZmx1c2hpbmcgdGhlbSBpbiBiYXRjaGVzIHdlIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cclxuICAgICAgICBsYXlvdXRTeW5jLnByZXBhcmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBVbnNldCB0aGUgdHJhbnNmb3JtIG9mIGFsbCBsYXlvdXRUcmFuc2l0aW9uIGNvbXBvbmVudHMgc28gd2UgY2FuIGFjY3VyYXRlbHkgbWVhc3VyZVxyXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxheW91dFN5bmMucmVhZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHRhcmdldCBWaXN1YWxJbmZvIG9mIGFsbCBsYXlvdXRUcmFuc2l0aW9uIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgbmV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0Lm1lYXN1cmUoZWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveDogYm91bmRpbmdCb3gubWVhc3VyZShlbGVtZW50KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG5leHRQb3NpdGlvbiA9IHJlYWRQb3NpdGlvblN0eWxlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb21wYXJlID0gZ2V0TGF5b3V0VHlwZShwb3NpdGlvblN0eWxlLCBuZXh0UG9zaXRpb24sIGlzUG9zaXRpb25Pbmx5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsYXlvdXRTeW5jLnJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIGxheW91dCBkZWx0YSBvZiBhbGwgbmV3bHkgbGFpZC1vdXQgbGF5b3V0VHJhbnNpdGlvbiBjb21wb25lbnRzIGludG8gdGhlaXJcclxuICAgICAgICAgICAgLy8gcHJldiB2aXN1YWwgc3RhdGUgYW5kIHRoZW4gYW5pbWF0ZSB0aGVtIGludG8gdGhlaXIgbmV3IG9uZSB1c2luZyB0cmFuc2Zvcm1zLlxyXG4gICAgICAgICAgICB2YXIgcHJldkxheW91dCA9IGNvbXBhcmUuZ2V0TGF5b3V0KHByZXYpO1xyXG4gICAgICAgICAgICB2YXIgbmV4dExheW91dCA9IGNvbXBhcmUuZ2V0TGF5b3V0KG5leHQpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjYWxjRGVsdGEocHJldkxheW91dCwgbmV4dExheW91dCk7XHJcbiAgICAgICAgICAgIHZhciBoYXNBbnlDaGFuZ2VkID0gZGVsdGEueCB8fCBkZWx0YS55IHx8IGRlbHRhLndpZHRoIHx8IGRlbHRhLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKCFoYXNBbnlDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBsYXlvdXQgaGFzbid0IGNoYW5nZWQsIHJlYXBwbHkgdGhlIHRyYW5zZm9ybSBhbmQgZ2V0IG91dCBvZiBoZXJlLlxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIChlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGVyKGVsZW1lbnQpLnNldCh7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiBkZWx0YS5vcmlnaW5YLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogZGVsdGEub3JpZ2luWSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN5bmNSZW5kZXJTZXNzaW9uLm9wZW4oKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkRlZmluaXRpb24gPSBpc1Jlc29sdmVyKGxheW91dFRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgICAgICA/IGxheW91dFRyYW5zaXRpb24oeyBkZWx0YTogZGVsdGEgfSlcclxuICAgICAgICAgICAgICAgIDogbGF5b3V0VHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgZnVuY3Rpb24gbWFrZVRyYW5zaXRpb24obGF5b3V0S2V5LCB0cmFuc2Zvcm1LZXksIHRhcmdldFZhbHVlLCB2aXN1YWxPcmlnaW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZGltZW5zaW9uIGhhc24ndCBjaGFuZ2VkLCBlYXJseSByZXR1cm5cclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUtleSA9IGlzU2l6ZUtleShsYXlvdXRLZXkpID8gbGF5b3V0S2V5IDogdHJhbnNmb3JtS2V5O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YVtkZWx0YUtleV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VUcmFuc2l0aW9uID0gdHlwZW9mIHRyYW5zaXRpb25EZWZpbml0aW9uID09PSBcImJvb2xlYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgID8gX19hc3NpZ24oe30sIGdldERlZmF1bHRMYXlvdXRUcmFuc2l0aW9uKGlzUG9zaXRpb25Pbmx5KSkgOiB0cmFuc2l0aW9uRGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcy5nZXQodHJhbnNmb3JtS2V5LCB0YXJnZXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSB2YWx1ZS5nZXRWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblt0cmFuc2Zvcm1LZXldID0gYmFzZVRyYW5zaXRpb25bdHJhbnNmb3JtS2V5XVxyXG4gICAgICAgICAgICAgICAgICAgID8gX19hc3NpZ24oe30sIGJhc2VUcmFuc2l0aW9uW3RyYW5zZm9ybUtleV0pIDogX19hc3NpZ24oe30sIGJhc2VUcmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uW3RyYW5zZm9ybUtleV0udmVsb2NpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25bdHJhbnNmb3JtS2V5XS52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IHZhbHVlIG9mIGFsbCB0cmFuc2Zvcm1zIGlzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoYXQgcHJvcCAoaWUgeCA9IDAsIHNjYWxlWCA9IDEpXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UncmUgaW52ZXJ0aW5nIHRoZSBsYXlvdXQgY2hhbmdlIHdpdGggYHRyYW5zZm9ybWAgYW5kIHRoZW4gYW5pbWF0aW5nIHRvIGB0cmFuc2Zvcm06IG5vbmVgXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbdHJhbnNmb3JtS2V5XSA9IHRhcmdldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFRvQXBwbHkgPSAhaXNTaXplS2V5KGxheW91dEtleSkgJiYgY29tcGFyZSA9PT0gb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS5nZXQoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnNldCh2aXN1YWxPcmlnaW4gKyBvZmZzZXRUb0FwcGx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYWtlVHJhbnNpdGlvbihcImxlZnRcIiwgXCJ4XCIsIDAsIGRlbHRhLngpO1xyXG4gICAgICAgICAgICBtYWtlVHJhbnNpdGlvbihcInRvcFwiLCBcInlcIiwgMCwgZGVsdGEueSk7XHJcbiAgICAgICAgICAgIGlmICghaXNQb3NpdGlvbk9ubHkpIHtcclxuICAgICAgICAgICAgICAgIG1ha2VUcmFuc2l0aW9uKFwid2lkdGhcIiwgXCJzY2FsZVhcIiwgMSwgcHJldi5ib3VuZGluZ0JveC53aWR0aCAvIG5leHQuYm91bmRpbmdCb3gud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgbWFrZVRyYW5zaXRpb24oXCJoZWlnaHRcIiwgXCJzY2FsZVlcIiwgMSwgcHJldi5ib3VuZGluZ0JveC5oZWlnaHQgLyBuZXh0LmJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IHRoZSB0cmFuc2l0aW9uIGlmIGB0cmFuc2l0aW9uRGVmaW5pdGlvbmAgaXNuJ3QgYGZhbHNlYC4gT3RoZXJ3aXNlIHdlIHdhbnRcclxuICAgICAgICAgICAgLy8gdG8gbGVhdmUgdGhlIHZhbHVlcyBpbiB0aGVpciBuZXdseS1pbnZlcnRlZCBzdGF0ZSBhbmQgbGV0IHRoZSB1c2VyIGNvcGUgd2l0aCB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdHJhbnNpdGlvbkRlZmluaXRpb24gJiYgY29udHJvbHMuc3RhcnQodGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gRm9yY2UgYSByZW5kZXIgdG8gZW5zdXJlIHRoZXJlJ3Mgbm8gdmlzdWFsIGZsaWNrZXJpbmdcclxuICAgICAgICAgICAgc3luY1JlbmRlclNlc3Npb24uZmx1c2goKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBMYXlvdXRBbmltYXRpb24ucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsYXlvdXRTeW5jLmZsdXNoKCk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0QW5pbWF0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0QW5pbWF0aW9uLmNvbnRleHRUeXBlID0gU3luY0xheW91dENvbnRleHQ7XHJcbiAgICByZXR1cm4gTGF5b3V0QW5pbWF0aW9uO1xyXG59KENvbXBvbmVudCkpO1xyXG52YXIgTGF5b3V0ID0ge1xyXG4gICAga2V5OiBcImxheW91dFwiLFxyXG4gICAgc2hvdWxkUmVuZGVyOiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25UcmFuc2l0aW9uID0gX2EucG9zaXRpb25UcmFuc2l0aW9uLCBsYXlvdXRUcmFuc2l0aW9uID0gX2EubGF5b3V0VHJhbnNpdGlvbjtcclxuICAgICAgICBpbnZhcmlhbnQoIShwb3NpdGlvblRyYW5zaXRpb24gJiYgbGF5b3V0VHJhbnNpdGlvbiksIFwiRG9uJ3Qgc2V0IGJvdGggcG9zaXRpb25UcmFuc2l0aW9uIGFuZCBsYXlvdXRUcmFuc2l0aW9uIG9uIHRoZSBzYW1lIGNvbXBvbmVudFwiKTtcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgISEocG9zaXRpb25UcmFuc2l0aW9uIHx8IGxheW91dFRyYW5zaXRpb24pKTtcclxuICAgIH0sXHJcbiAgICBDb21wb25lbnQ6IExheW91dEFuaW1hdGlvbixcclxufTtcblxuLyoqXHJcbiAqIEEgbGlzdCBvZiBhbGwgdmFsaWQgTW90aW9uUHJvcHNcclxuICpcclxuICogQGludGVybmFscmVtYXJrc1xyXG4gKiBUaGlzIGRvZXNuJ3QgdGhyb3cgaWYgYSBgTW90aW9uUHJvcGAgbmFtZSBpcyBtaXNzaW5nIC0gaXQgc2hvdWxkLlxyXG4gKi9cclxudmFyIHZhbGlkTW90aW9uUHJvcHMgPSBuZXcgU2V0KFtcclxuICAgIFwiaW5pdGlhbFwiLFxyXG4gICAgXCJhbmltYXRlXCIsXHJcbiAgICBcImV4aXRcIixcclxuICAgIFwic3R5bGVcIixcclxuICAgIFwidmFyaWFudHNcIixcclxuICAgIFwidHJhbnNpdGlvblwiLFxyXG4gICAgXCJ0cmFuc2Zvcm1UZW1wbGF0ZVwiLFxyXG4gICAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcclxuICAgIFwiY3VzdG9tXCIsXHJcbiAgICBcImluaGVyaXRcIixcclxuICAgIFwic3RhdGljXCIsXHJcbiAgICBcInBvc2l0aW9uVHJhbnNpdGlvblwiLFxyXG4gICAgXCJsYXlvdXRUcmFuc2l0aW9uXCIsXHJcbiAgICBcIm9uQW5pbWF0aW9uU3RhcnRcIixcclxuICAgIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxyXG4gICAgXCJvblVwZGF0ZVwiLFxyXG4gICAgXCJvbkRyYWdTdGFydFwiLFxyXG4gICAgXCJvbkRyYWdcIixcclxuICAgIFwib25EcmFnRW5kXCIsXHJcbiAgICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxyXG4gICAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXHJcbiAgICBcImRyYWdcIixcclxuICAgIFwiZHJhZ0NvbnRyb2xzXCIsXHJcbiAgICBcImRyYWdMaXN0ZW5lclwiLFxyXG4gICAgXCJkcmFnQ29uc3RyYWludHNcIixcclxuICAgIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcclxuICAgIFwiZHJhZ0VsYXN0aWNcIixcclxuICAgIFwiZHJhZ01vbWVudHVtXCIsXHJcbiAgICBcImRyYWdQcm9wYWdhdGlvblwiLFxyXG4gICAgXCJkcmFnVHJhbnNpdGlvblwiLFxyXG4gICAgXCJfZHJhZ1ZhbHVlWFwiLFxyXG4gICAgXCJfZHJhZ1ZhbHVlWVwiLFxyXG4gICAgXCJfZHJhZ1RyYW5zaXRpb25Db250cm9sc1wiLFxyXG4gICAgXCJkcmFnT3JpZ2luWFwiLFxyXG4gICAgXCJkcmFnT3JpZ2luWVwiLFxyXG4gICAgXCJvblBhblwiLFxyXG4gICAgXCJvblBhblN0YXJ0XCIsXHJcbiAgICBcIm9uUGFuRW5kXCIsXHJcbiAgICBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsXHJcbiAgICBcIm9uVGFwXCIsXHJcbiAgICBcIm9uVGFwU3RhcnRcIixcclxuICAgIFwib25UYXBDYW5jZWxcIixcclxuICAgIFwid2hpbGVIb3ZlclwiLFxyXG4gICAgXCJ3aGlsZVRhcFwiLFxyXG4gICAgXCJvbkhvdmVyRW5kXCIsXHJcbiAgICBcIm9uSG92ZXJTdGFydFwiLFxyXG5dKTtcclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgYSBwcm9wIG5hbWUgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2tcclxuICogQHJldHVybnMgYHRydWVgIGlzIGtleSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB7XHJcbiAgICByZXR1cm4gdmFsaWRNb3Rpb25Qcm9wcy5oYXMoa2V5KTtcclxufVxuXG52YXIgQW5pbWF0ZVByb3BUeXBlO1xyXG4oZnVuY3Rpb24gKEFuaW1hdGVQcm9wVHlwZSkge1xyXG4gICAgQW5pbWF0ZVByb3BUeXBlW1wiVGFyZ2V0XCJdID0gXCJUYXJnZXRcIjtcclxuICAgIEFuaW1hdGVQcm9wVHlwZVtcIlZhcmlhbnRMYWJlbFwiXSA9IFwiVmFyaWFudExhYmVsXCI7XHJcbiAgICBBbmltYXRlUHJvcFR5cGVbXCJBbmltYXRpb25TdWJzY3JpcHRpb25cIl0gPSBcIkFuaW1hdGlvblN1YnNjcmlwdGlvblwiO1xyXG59KShBbmltYXRlUHJvcFR5cGUgfHwgKEFuaW1hdGVQcm9wVHlwZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcclxuICAgIGlmIChwcmV2ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcmV2TGVuZ3RoID0gcHJldi5sZW5ndGg7XHJcbiAgICBpZiAocHJldkxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2TGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJldltpXSAhPT0gbmV4dFtpXSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxudmFyIGhhc1VwZGF0ZWQgPSBmdW5jdGlvbiAocHJldiwgbmV4dCkge1xyXG4gICAgcmV0dXJuIChuZXh0ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAoQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpXHJcbiAgICAgICAgICAgID8gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpXHJcbiAgICAgICAgICAgIDogcHJldiAhPT0gbmV4dCkpO1xyXG59O1xyXG5mdW5jdGlvbiB0YXJnZXRXaXRob3V0VHJhbnNpdGlvbihfYSwgbWVyZ2VUcmFuc2l0aW9uRW5kKSB7XHJcbiAgICBpZiAobWVyZ2VUcmFuc2l0aW9uRW5kID09PSB2b2lkIDApIHsgbWVyZ2VUcmFuc2l0aW9uRW5kID0gZmFsc2U7IH1cclxuICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCA9IF9hLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xyXG4gICAgcmV0dXJuIG1lcmdlVHJhbnNpdGlvbkVuZFxyXG4gICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhcmdldCksIHRyYW5zaXRpb25FbmQpXHJcbiAgICAgICAgOiB0YXJnZXQ7XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZSB0aGUgYGFuaW1hdGVgIHByb3Agd2hlbiBpdHMgYW4gb2JqZWN0IG9mIHZhbHVlcywgaWU6XHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiA8bW90aW9uLmRpdiBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX0gLz5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBpbnRlcm5hbHJlbWFya3NcclxuICogSXQgbWlnaHQgYmUgd29ydGggY29uc29saWRhdGluZyB0aGlzIHdpdGggYHVzZS12YXJpYW50c2BcclxuICpcclxuICogYGBganN4XHJcbiAqIDxtb3Rpb24uZGl2IGFuaW1hdGU9XCJ2aXNpYmxlXCIgLz5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB0YXJnZXRcclxuICogQHBhcmFtIGNvbnRyb2xzXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHBhcmFtIHRyYW5zaXRpb25cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VBbmltYXRlUHJvcCh0YXJnZXRBbmRUcmFuc2l0aW9uLCBjb250cm9scywgdmFsdWVzLCBkZWZhdWx0VHJhbnNpdGlvbikge1xyXG4gICAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IHVzZVJlZih0cnVlKTtcclxuICAgIHZhciBwcmV2VmFsdWVzID0gdXNlUmVmKG51bGwpO1xyXG4gICAgaWYgKCFwcmV2VmFsdWVzLmN1cnJlbnQpIHtcclxuICAgICAgICBwcmV2VmFsdWVzLmN1cnJlbnQgPSB0YXJnZXRXaXRob3V0VHJhbnNpdGlvbih0YXJnZXRBbmRUcmFuc2l0aW9uLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldFRvQW5pbWF0ZSA9IHt9O1xyXG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgdmFsdWVzIHdlJ3JlIGFjdHVhbGx5IGFuaW1hdGluZ1xyXG4gICAgICAgIHZhciBhbmltYXRpbmdUYXJnZXQgPSB0YXJnZXRXaXRob3V0VHJhbnNpdGlvbih0YXJnZXRBbmRUcmFuc2l0aW9uKTtcclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSB0YXJnZXQgYXMgaXQnbGwgYmUgb25jZSB0cmFuc2l0aW9uRW5kIHZhbHVlcyBhcmUgYXBwbGllZFxyXG4gICAgICAgIHZhciBmaW5hbFRhcmdldCA9IHRhcmdldFdpdGhvdXRUcmFuc2l0aW9uKHRhcmdldEFuZFRyYW5zaXRpb24sIHRydWUpO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGljaCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkIGJldHdlZW4gcmVuZGVyc1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhbmltYXRpbmdUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB2YWx1ZSBzaG91bGQgYW5pbWF0ZSBvbiBtb3VudCBpZiB0aGlzIHZhbHVlIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCAod2Fzbid0XHJcbiAgICAgICAgICAgIC8vIGRlZmluZWQgaW4gYHN0eWxlYCBvciBgaW5pdGlhbGApIG9yIGlmIGl0IGRvZXMgZXhpc3QgYW5kIGl0J3MgYWxyZWFkeSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICB2YXIgc2hvdWxkQW5pbWF0ZU9uTW91bnQgPSBpc0luaXRpYWxSZW5kZXIuY3VycmVudCAmJlxyXG4gICAgICAgICAgICAgICAgKCF2YWx1ZXMuaGFzKGtleSkgfHxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZ2V0KGtleSkuZ2V0KCkgIT09IGZpbmFsVGFyZ2V0W2tleV0pO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHZhbHVlIGhhcyB1cGRhdGVkIGJldHdlZW4gcmVuZGVycyBvciBpdCdzIHdlJ3JlIGFuaW1hdGluZyB0aGlzIHZhbHVlIG9uIG1vdW50LFxyXG4gICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGFuaW1hdGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZFZhbHVlID0gZmluYWxUYXJnZXRba2V5XSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHZhbHVlSGFzVXBkYXRlZCA9IGhhc1VwZGF0ZWQocHJldlZhbHVlcy5jdXJyZW50W2tleV0sIGZpbmFsVGFyZ2V0W2tleV0pO1xyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZFZhbHVlICYmICh2YWx1ZUhhc1VwZGF0ZWQgfHwgc2hvdWxkQW5pbWF0ZU9uTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRUb0FuaW1hdGVba2V5XSA9IGFuaW1hdGluZ1RhcmdldFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgcHJldlZhbHVlcy5jdXJyZW50ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZWYWx1ZXMuY3VycmVudCksIGZpbmFsVGFyZ2V0KTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGFyZ2V0VG9BbmltYXRlKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29udHJvbHMuc3RhcnQoX19hc3NpZ24oX19hc3NpZ24oe30sIHRhcmdldFRvQW5pbWF0ZSksIHsgdHJhbnNpdGlvbjogdGFyZ2V0QW5kVHJhbnNpdGlvbi50cmFuc2l0aW9uIHx8IGRlZmF1bHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kOiB0YXJnZXRBbmRUcmFuc2l0aW9uLnRyYW5zaXRpb25FbmQgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXRBbmRUcmFuc2l0aW9uXSk7XHJcbn1cblxudmFyIGxhYmVsc1RvQXJyYXkgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgIGlmICghbGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2xhYmVsXTtcclxufTtcclxudmFyIHJlc29sdmVWYXJpYW50TGFiZWxzID0gZnVuY3Rpb24gKHZhcmlhbnQpIHtcclxuICAgIHZhciB1bnJlc29sdmVkVmFyaWFudCA9IHZhcmlhbnQgaW5zdGFuY2VvZiBNb3Rpb25WYWx1ZSA/IHZhcmlhbnQuZ2V0KCkgOiB2YXJpYW50O1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsYWJlbHNUb0FycmF5KHVucmVzb2x2ZWRWYXJpYW50KSkpO1xyXG59O1xyXG4vKipcclxuICogSG9va3MgaW4gUmVhY3Qgc29tZXRpbWVzIGFjY2VwdCBhIGRlcGVuZGVuY3kgYXJyYXkgYXMgdGhlaXIgZmluYWwgYXJndW1lbnQuIChpZSB1c2VFZmZlY3QvdXNlTWVtbylcclxuICogV2hlbiB2YWx1ZXMgaW4gdGhpcyBhcnJheSBjaGFuZ2UsIFJlYWN0IHJlLXJ1bnMgdGhlIGRlcGVuZGVuY3kuIEhvd2V2ZXIgaWYgdGhlIGFycmF5XHJcbiAqIGNvbnRhaW5zIGEgdmFyaWFibGUgbnVtYmVyIG9mIGl0ZW1zLCBSZWFjdCB0aHJvd3MgYW4gZXJyb3IuXHJcbiAqL1xyXG52YXIgYXNEZXBlbmRlbmN5TGlzdCA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBbXHJcbiAgICBsaXN0LmpvaW4oXCIsXCIpLFxyXG5dOyB9O1xuXG52YXIgaGFzVmFyaWFudENoYW5nZWQgPSBmdW5jdGlvbiAob2xkVmFyaWFudCwgbmV3VmFyaWFudCkge1xyXG4gICAgcmV0dXJuIG9sZFZhcmlhbnQuam9pbihcIixcIikgIT09IG5ld1ZhcmlhbnQuam9pbihcIixcIik7XHJcbn07XHJcbi8qKlxyXG4gKiBIYW5kbGUgdmFyaWFudHMgYW5kIHRoZSBgYW5pbWF0ZWAgcHJvcCB3aGVuIGl0cyBzZXQgYXMgdmFyaWFudCBsYWJlbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbml0aWFsIC0gSW5pdGlhbCB2YXJpYW50KHMpXHJcbiAqIEBwYXJhbSBhbmltYXRlIC0gVmFyaWFudChzKSB0byBhbmltYXRlIHRvXHJcbiAqIEBwYXJhbSBpbmhlcml0IC0gYHRydWVgIGlzIGluaGVyaXRpbmcgYW5pbWF0aW9ucyBmcm9tIHBhcmVudFxyXG4gKiBAcGFyYW0gY29udHJvbHMgLSBBbmltYXRpb24gY29udHJvbHNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VWYXJpYW50cyhpbml0aWFsLCBhbmltYXRlLCBpbmhlcml0LCBjb250cm9scykge1xyXG4gICAgdmFyIHRhcmdldFZhcmlhbnRzID0gcmVzb2x2ZVZhcmlhbnRMYWJlbHMoYW5pbWF0ZSk7XHJcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XHJcbiAgICB2YXIgcGFyZW50QWxyZWFkeU1vdW50ZWQgPSBjb250ZXh0Lmhhc01vdW50ZWQgJiYgY29udGV4dC5oYXNNb3VudGVkLmN1cnJlbnQ7XHJcbiAgICB2YXIgaGFzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaG91bGRBbmltYXRlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW5oZXJpdGluZyB2YXJpYW50IGNoYW5nZXMgYW5kIHRoZSBwYXJlbnQgaGFzIGFscmVhZHlcclxuICAgICAgICAgICAgLy8gbW91bnRlZCB3aGVuIHRoaXMgY29tcG9uZW50IGxvYWRzLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBhbmltYXRpb24uXHJcbiAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSAhIXBhcmVudEFscmVhZHlNb3VudGVkO1xyXG4gICAgICAgICAgICB0YXJnZXRWYXJpYW50cyA9IHJlc29sdmVWYXJpYW50TGFiZWxzKGNvbnRleHQuYW5pbWF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzaG91bGRBbmltYXRlID1cclxuICAgICAgICAgICAgICAgIGhhc01vdW50ZWQuY3VycmVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc1ZhcmlhbnRDaGFuZ2VkKHJlc29sdmVWYXJpYW50TGFiZWxzKGluaXRpYWwpLCB0YXJnZXRWYXJpYW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNob3VsZEFuaW1hdGUgJiYgY29udHJvbHMuc3RhcnQodGFyZ2V0VmFyaWFudHMpO1xyXG4gICAgICAgIGhhc01vdW50ZWQuY3VycmVudCA9IHRydWU7XHJcbiAgICB9LCBhc0RlcGVuZGVuY3lMaXN0KHRhcmdldFZhcmlhbnRzKSk7XHJcbn1cblxuLyoqXHJcbiAqIGB1c2VBbmltYXRpb25Hcm91cFN1YnNjcmlwdGlvbmAgYWxsb3dzIGEgY29tcG9uZW50IHRvIHN1YnNjcmliZSB0byBhblxyXG4gKiBleHRlcm5hbGx5LWNyZWF0ZWQgYEFuaW1hdGlvbkNvbnRyb2xzYCwgY3JlYXRlZCBieSB0aGUgYHVzZUFuaW1hdGlvbmAgaG9vay5cclxuICpcclxuICogQHBhcmFtIGFuaW1hdGlvblxyXG4gKiBAcGFyYW0gY29udHJvbHNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VBbmltYXRpb25Hcm91cFN1YnNjcmlwdGlvbihhbmltYXRpb24sIGNvbnRyb2xzKSB7XHJcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGlvbi5zdWJzY3JpYmUoY29udHJvbHMpOyB9LCBbXHJcbiAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgXSk7XHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XHJcbiAgICB9OyB9LCBbdW5zdWJzY3JpYmVdKTtcclxufVxuXG52YXIgX2EkMSwgX2I7XHJcbnZhciBBbmltYXRlUHJvcENvbXBvbmVudHMgPSAoX2EkMSA9IHt9LFxyXG4gICAgX2EkMVtBbmltYXRlUHJvcFR5cGUuVGFyZ2V0XSA9IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBhbmltYXRlID0gX2EuYW5pbWF0ZSwgY29udHJvbHMgPSBfYS5jb250cm9scywgdmFsdWVzID0gX2EudmFsdWVzLCB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbjtcclxuICAgICAgICByZXR1cm4gdXNlQW5pbWF0ZVByb3AoYW5pbWF0ZSwgY29udHJvbHMsIHZhbHVlcywgdHJhbnNpdGlvbik7XHJcbiAgICB9KSxcclxuICAgIF9hJDFbQW5pbWF0ZVByb3BUeXBlLlZhcmlhbnRMYWJlbF0gPSBtYWtlUmVuZGVybGVzc0NvbXBvbmVudChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgYW5pbWF0ZSA9IF9hLmFuaW1hdGUsIF9iID0gX2EuaW5oZXJpdCwgaW5oZXJpdCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIGNvbnRyb2xzID0gX2EuY29udHJvbHMsIGluaXRpYWwgPSBfYS5pbml0aWFsO1xyXG4gICAgICAgIHJldHVybiB1c2VWYXJpYW50cyhpbml0aWFsLCBhbmltYXRlLCBpbmhlcml0LCBjb250cm9scyk7XHJcbiAgICB9KSxcclxuICAgIF9hJDFbQW5pbWF0ZVByb3BUeXBlLkFuaW1hdGlvblN1YnNjcmlwdGlvbl0gPSBtYWtlUmVuZGVybGVzc0NvbXBvbmVudChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgYW5pbWF0ZSA9IF9hLmFuaW1hdGUsIGNvbnRyb2xzID0gX2EuY29udHJvbHM7XHJcbiAgICAgICAgcmV0dXJuIHVzZUFuaW1hdGlvbkdyb3VwU3Vic2NyaXB0aW9uKGFuaW1hdGUsIGNvbnRyb2xzKTtcclxuICAgIH0pLFxyXG4gICAgX2EkMSk7XHJcbnZhciBpc1ZhcmlhbnRMYWJlbCQxID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiO1xyXG59O1xyXG52YXIgaXNBbmltYXRpb25TdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBhbmltYXRlID0gX2EuYW5pbWF0ZTtcclxuICAgIHJldHVybiBhbmltYXRlIGluc3RhbmNlb2YgQW5pbWF0aW9uQ29udHJvbHM7XHJcbn07XHJcbnZhciBhbmltYXRpb25Qcm9wcyA9IFtcImluaXRpYWxcIiwgXCJhbmltYXRlXCIsIFwid2hpbGVUYXBcIiwgXCJ3aGlsZUhvdmVyXCJdO1xyXG52YXIgYW5pbWF0ZVByb3BUeXBlVGVzdHMgPSAoX2IgPSB7fSxcclxuICAgIF9iW0FuaW1hdGVQcm9wVHlwZS5UYXJnZXRdID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcm9wcy5hbmltYXRlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgIWlzVmFyaWFudExhYmVsJDEocHJvcHMuYW5pbWF0ZSkgJiZcclxuICAgICAgICAgICAgIWlzQW5pbWF0aW9uU3Vic2NyaXB0aW9uKHByb3BzKSk7XHJcbiAgICB9LFxyXG4gICAgX2JbQW5pbWF0ZVByb3BUeXBlLlZhcmlhbnRMYWJlbF0gPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gKHByb3BzLnZhcmlhbnRzICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgYW5pbWF0aW9uUHJvcHMuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0eXBlb2YgcHJvcHNba2V5XSA9PT0gXCJzdHJpbmdcIjsgfSkpO1xyXG4gICAgfSxcclxuICAgIF9iW0FuaW1hdGVQcm9wVHlwZS5BbmltYXRpb25TdWJzY3JpcHRpb25dID0gaXNBbmltYXRpb25TdWJzY3JpcHRpb24sXHJcbiAgICBfYik7XHJcbnZhciBnZXRBbmltYXRpb25Db21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBhbmltYXRlUHJvcFR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gQW5pbWF0ZVByb3BUeXBlKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGVQcm9wVHlwZVRlc3RzW2tleV0ocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGVQcm9wVHlwZSA9IGtleTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0ZVByb3BUeXBlID8gQW5pbWF0ZVByb3BDb21wb25lbnRzW2FuaW1hdGVQcm9wVHlwZV0gOiB1bmRlZmluZWQ7XHJcbn07XG5cbi8qKlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIHRoZSBjaGlsZCBvZiBgQW5pbWF0ZVByZXNlbmNlYCwgaXQgY2FuIHVzZSBgdXNlUHJlc2VuY2VgXHJcbiAqIHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIGl0J3Mgc3RpbGwgcHJlc2VudCBpbiB0aGUgUmVhY3QgdHJlZS5cclxuICpcclxuICogYGBganN4XHJcbiAqIGltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpXHJcbiAqXHJcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICogICAgICFpc1ByZXNlbnQgc2V0VGltZW91dChzYWZlVG9SZW1vdmUsIDEwMDApXHJcbiAqICAgfSwgW2lzUHJlc2VudF0pXHJcbiAqXHJcbiAqICAgcmV0dXJuIDxkaXYgLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogSWYgYGlzUHJlc2VudGAgaXMgYGZhbHNlYCwgaXQgbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiByZW1vdmVkIHRoZSB0cmVlLCBidXRcclxuICogYEFuaW1hdGVQcmVzZW5jZWAgd29uJ3QgcmVhbGx5IHJlbW92ZSBpdCB1bnRpbCBgc2FmZVRvUmVtb3ZlYCBoYXMgYmVlbiBjYWxsZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVzZVByZXNlbmNlKCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XHJcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gW3RydWVdO1xyXG4gICAgdmFyIGlzUHJlc2VudCA9IGNvbnRleHQuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IGNvbnRleHQub25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyID0gY29udGV4dC5yZWdpc3RlcjtcclxuICAgIHVzZUVmZmVjdChyZWdpc3RlciwgW10pO1xyXG4gICAgcmV0dXJuICFpc1ByZXNlbnQgJiYgb25FeGl0Q29tcGxldGUgPyBbZmFsc2UsIG9uRXhpdENvbXBsZXRlXSA6IFt0cnVlXTtcclxufVxuXG52YXIgRXhpdCA9IHtcclxuICAgIGtleTogXCJleGl0XCIsXHJcbiAgICBzaG91bGRSZW5kZXI6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gISFwcm9wcy5leGl0ICYmICFjaGVja1Nob3VsZEluaGVyaXRWYXJpYW50KHByb3BzKTsgfSxcclxuICAgIENvbXBvbmVudDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBhbmltYXRlID0gcHJvcHMuYW5pbWF0ZSwgY29udHJvbHMgPSBwcm9wcy5jb250cm9scywgZXhpdCA9IHByb3BzLmV4aXQ7XHJcbiAgICAgICAgdmFyIF9iID0gdXNlUHJlc2VuY2UoKSwgaXNQcmVzZW50ID0gX2JbMF0sIG9uRXhpdENvbXBsZXRlID0gX2JbMV07XHJcbiAgICAgICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcclxuICAgICAgICB2YXIgaXNQbGF5aW5nRXhpdEFuaW1hdGlvbiA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICAgICAgdmFyIGN1c3RvbSA9ICgoX2EgPSBwcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b20pICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBwcmVzZW5jZUNvbnRleHQuY3VzdG9tXHJcbiAgICAgICAgICAgIDogcHJvcHMuY3VzdG9tO1xyXG4gICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGxheWluZ0V4aXRBbmltYXRpb24uY3VycmVudCAmJiBleGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuc2V0UHJvcHMoX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgeyBjdXN0b206IGN1c3RvbSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuc3RhcnQoZXhpdCkudGhlbihvbkV4aXRDb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc1BsYXlpbmdFeGl0QW5pbWF0aW9uLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUGxheWluZ0V4aXRBbmltYXRpb24uY3VycmVudCAmJlxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgIShhbmltYXRlIGluc3RhbmNlb2YgQW5pbWF0aW9uQ29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9scy5zdGFydChhbmltYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpc1BsYXlpbmdFeGl0QW5pbWF0aW9uLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtpc1ByZXNlbnRdKTtcclxuICAgIH0pLFxyXG59O1xuXG52YXIgaXNQcm9wVmFsaWQgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KTsgfTtcclxuLyoqXHJcbiAqIEVtb3Rpb24gYW5kIFN0eWxlZCBDb21wb25lbnRzIGJvdGggYWxsb3cgdXNlcnMgdG8gcGFzcyB0aHJvdWdoIGFyYml0cmFyeSBwcm9wcyB0byB0aGVpciBjb21wb25lbnRzXHJcbiAqIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlIENTUy4gVGhleSBib3RoIHVzZSB0aGUgYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgIHBhY2thZ2UgdG8gZGV0ZXJtaW5lIHdoaWNoXHJcbiAqIG9mIHRoZXNlIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXHJcbiAqXHJcbiAqIEhvd2V2ZXIsIHdoZW4gc3R5bGluZyBhIE1vdGlvbiBjb21wb25lbnQgYHN0eWxlZChtb3Rpb24uZGl2KWAsIGJvdGggcGFja2FnZXMgcGFzcyB0aHJvdWdoICphbGwqIHByb3BzXHJcbiAqIGFzIGl0J3Mgc2VlbiBhcyBhbiBhcmJpdHJhcnkgY29tcG9uZW50IHJhdGhlciB0aGFuIGEgRE9NIG5vZGUuIE1vdGlvbiBvbmx5IGFsbG93cyBhcmJpdHJhcnkgcHJvcHNcclxuICogcGFzc2VkIHRocm91Z2ggdGhlIGBjdXN0b21gIHByb3Agc28gaXQgZG9lc24ndCAqbmVlZCogdGhlIHBheWxvYWQgb3IgY29tcHV0YXRpb25hbCBvdmVyaGVhZCBvZlxyXG4gKiBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAsIGhvd2V2ZXIgdG8gZml4IHRoaXMgcHJvYmxlbSB3ZSBuZWVkIHRvIHVzZSBpdC5cclxuICpcclxuICogQnkgbWFraW5nIGl0IGFuIG9wdGlvbmFsRGVwZW5kZW5jeSB3ZSBjYW4gb2ZmZXIgdGhpcyBmdW5jdGlvbmFsaXR5IG9ubHkgaW4gdGhlIHNpdHVhdGlvbnMgd2hlcmUgaXQnc1xyXG4gKiBhY3R1YWxseSByZXF1aXJlZC5cclxuICovXHJcbnRyeSB7XHJcbiAgICB2YXIgZW1vdGlvbklzUHJvcFZhbGlkXzEgPSByZXF1aXJlKFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiKS5kZWZhdWx0O1xyXG4gICAgaXNQcm9wVmFsaWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGV2ZW50cyBleHBsaWNpdGx5IGFzIEVtb3Rpb24gdmFsaWRhdGVzIHRoZW0gYWxsIGFzIHRydWVcclxuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJvblwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1vdGlvbklzUHJvcFZhbGlkXzEoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmNhdGNoIChfYSkge1xyXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBhY3R1YWxseSBkbyBhbnl0aGluZyBoZXJlIC0gdGhlIGZhbGxiYWNrIGlzIHRoZSBleGlzdGluZyBgaXNQcm9wVmFsaWRgLlxyXG59XHJcbmZ1bmN0aW9uIGZpbHRlclZhbGlkUHJvcHMocHJvcHMpIHtcclxuICAgIHZhciBkb21Qcm9wcyA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKGlzUHJvcFZhbGlkKGtleSkpIHtcclxuICAgICAgICAgICAgZG9tUHJvcHNba2V5XSA9IHByb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbVByb3BzO1xyXG59XHJcbnZhciBidWlsZEhUTUxQcm9wcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0eWxlLCBpc1N0YXRpYywgaXNEcmFnKSB7XHJcbiAgICAvLyBUaGUgYGFueWAgaXNuJ3QgaWRlYWwgYnV0IGl0IGlzIHRoZSB0eXBlIG9mIGNyZWF0ZUVsZW1lbnQgcHJvcHMgYXJndW1lbnRcclxuICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICBzdHlsZTogYnVpbGRTdHlsZUF0dHIodmFsdWVzLCBzdHlsZSwgaXNTdGF0aWMpLFxyXG4gICAgfTtcclxuICAgIGlmIChpc0RyYWcpIHtcclxuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXHJcbiAgICAgICAgcHJvcHMuc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xyXG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcclxuICAgICAgICBwcm9wcy5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufTtcclxudmFyIGJ1aWxkU1ZHUHJvcHMgPSBmdW5jdGlvbiAodmFsdWVzLCBzdHlsZSkge1xyXG4gICAgdmFyIG1vdGlvblZhbHVlU3R5bGVzID0gcmVzb2x2ZUN1cnJlbnQodmFsdWVzKTtcclxuICAgIHZhciBwcm9wcyA9IGJ1aWxkU1ZHQXR0cnMobW90aW9uVmFsdWVTdHlsZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgcHJvcHMuc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGUpLCBwcm9wcy5zdHlsZSk7XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn07XHJcbnZhciBmdW5jdGlvbmFsaXR5Q29tcG9uZW50cyA9IFtMYXlvdXQsIERyYWcsIEdlc3R1cmVzLCBFeGl0XTtcclxudmFyIG51bUZ1bmN0aW9uYWxpdHlDb21wb25lbnRzID0gZnVuY3Rpb25hbGl0eUNvbXBvbmVudHMubGVuZ3RoO1xyXG4vKipcclxuICogQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBmb3IgYG1vdGlvbmAgY29tcG9uZW50cyB0aGF0IHByb3ZpZGVzIERPTS1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQpIHtcclxuICAgIHZhciBpc0RPTSA9IHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCI7XHJcbiAgICB2YXIgaXNTVkcgPSBpc0RPTSAmJiBzdmdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgIT09IC0xO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW5kZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChyZWYsIHN0eWxlLCB2YWx1ZXMsIHByb3BzLCBpc1N0YXRpYykge1xyXG4gICAgICAgICAgICB2YXIgZm9yd2FyZGVkUHJvcHMgPSBpc0RPTSA/IGZpbHRlclZhbGlkUHJvcHMocHJvcHMpIDogcHJvcHM7XHJcbiAgICAgICAgICAgIHZhciBzdGF0aWNWaXN1YWxTdHlsZXMgPSBpc1NWR1xyXG4gICAgICAgICAgICAgICAgPyBidWlsZFNWR1Byb3BzKHZhbHVlcywgc3R5bGUpXHJcbiAgICAgICAgICAgICAgICA6IGJ1aWxkSFRNTFByb3BzKHZhbHVlcywgc3R5bGUsIGlzU3RhdGljLCAhIXByb3BzLmRyYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3J3YXJkZWRQcm9wcyksIHsgcmVmOiByZWYgfSksIHN0YXRpY1Zpc3VhbFN0eWxlcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbG9hZEZ1bmN0aW9uYWxpdHlDb21wb25lbnRzIGdldHMgdXNlZCBieSB0aGUgYG1vdGlvbmAgY29tcG9uZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBFYWNoIGZ1bmN0aW9uYWxpdHkgY29tcG9uZW50IGdldHMgcHJvdmlkZWQgdGhlIGByZWZgLCBhbmltYXRpb24gY29udHJvbHMgYW5kIHRoZSBgTW90aW9uVmFsdWVzTWFwYFxyXG4gICAgICAgICAqIGdlbmVyYXRlZCBmb3IgdGhhdCBjb21wb25lbnQsIGFzIHdlbGwgYXMgYWxsIHRoZSBgcHJvcHNgIHBhc3NlZCB0byBpdCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBwYXR0ZXJuIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gbG9hZCBhbmQgdXNlIGVhY2ggcGllY2Ugb2YgZnVuY3Rpb25hbGl0eSBpc1xyXG4gICAgICAgICAqIGNvbnNpc3RlbnQgKHNob3VsZCByZW5kZXI/IFRoZW4gcHVzaCBjb21wb25lbnQpIGFuZCBjb3VsZCBiZSB1c2VkIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZXhwb3NpbmcgYSBtdXRhYmxlIHBpZWNlIG9mIG1lbW9yeSB2aWEgYW4gQVBJIGxpa2UgYGV4dGVuZE1vdGlvbkNvbXBvbmVudGAgd2UgY291bGRcclxuICAgICAgICAgKiBhbGxvdyB1c2VycyB0byBhZGQgYEZ1bmN0aW9uYWxDb21wb25lbnREZWZpbml0aW9uYHMuIFRoaXMgd291bGQgYWxsb3cgdXMgdG8gb2ZmZXIgZmlsZSBzaXplXHJcbiAgICAgICAgICogcmVkdWN0aW9ucyBieSBzaGlwcGluZyBhbiBlbnRyeSBwb2ludCB0aGF0IGRvZXNuJ3QgbG9hZCBnZXN0dXJlIGFuZCBkcmFnIGZ1bmN0aW9uYWxpdHksIGFuZFxyXG4gICAgICAgICAqIGFsc28gb2ZmZXIgYSB3YXkgZm9yIHVzZXJzIHRvIGRldmVsb3AgcGx1Z2lucy9vdGhlciBmdW5jdGlvbmFsaXR5LiBCZWNhdXNlIHRoZXNlIGZ1bmN0aW9uYWxpdGllc1xyXG4gICAgICAgICAqIGFyZSBsb2FkZWQgYXMgY29tcG9uZW50cywgd2UgY2FuIGxvb2sgaW50byB1c2luZyBTdXNwZW5zZSBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRm9yIHVzZXItZGVmaW5lZCBmdW5jdGlvbmFsaXR5IHdlJ2QgbmVlZCB0byBhbGxvd1xyXG4gICAgICAgICAqICAxKSBVc2VyLWRlZmluZWQgcHJvcCB0eXBpbmcgKGV4dGVuZGluZyBgUGApXHJcbiAgICAgICAgICogIDIpIFVzZXItZGVmaW5lZCBcImNsZWFuIHByb3BzXCIgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZWlyIHBsdWdpbidzIHByb3BzIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gdGhlIERPTS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsb2FkRnVuY3Rpb25hbGl0eUNvbXBvbmVudHM6IGZ1bmN0aW9uIChyZWYsIHZhbHVlcywgcHJvcHMsIGNvbnRleHQsIGNvbnRyb2xzLCBpbmhlcml0KSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RpdmVDb21wb25lbnRzID0gW107XHJcbiAgICAgICAgICAgIC8vIFRPRE86IENvbnNvbGlkYXRlIEFuaW1hdGlvbiBmdW5jdGlvbmFsaXR5IGxvYWRpbmcgc3RyYXRlZ3kgd2l0aCBvdGhlciBmdW5jdGlvbmFsaXR5IGNvbXBvbmVudHNcclxuICAgICAgICAgICAgdmFyIEFuaW1hdGlvbiA9IGdldEFuaW1hdGlvbkNvbXBvbmVudChwcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChBbmltYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUNvbXBvbmVudHMucHVzaChjcmVhdGVFbGVtZW50KEFuaW1hdGlvbiwgeyBrZXk6IFwiYW5pbWF0aW9uXCIsIGluaXRpYWw6IHByb3BzLmluaXRpYWwsIGFuaW1hdGU6IHByb3BzLmFuaW1hdGUsIHZhcmlhbnRzOiBwcm9wcy52YXJpYW50cywgdHJhbnNpdGlvbjogcHJvcHMudHJhbnNpdGlvbiwgY29udHJvbHM6IGNvbnRyb2xzLCBpbmhlcml0OiBpbmhlcml0LCB2YWx1ZXM6IHZhbHVlcyB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GdW5jdGlvbmFsaXR5Q29tcG9uZW50czsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBmdW5jdGlvbmFsaXR5Q29tcG9uZW50c1tpXSwgc2hvdWxkUmVuZGVyID0gX2Euc2hvdWxkUmVuZGVyLCBrZXkgPSBfYS5rZXksIENvbXBvbmVudF8xID0gX2EuQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbmRlcihwcm9wcywgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDb21wb25lbnRzLnB1c2goY3JlYXRlRWxlbWVudChDb21wb25lbnRfMSwgX19hc3NpZ24oeyBrZXk6IGtleSB9LCBwcm9wcywgeyBwYXJlbnRDb250ZXh0OiBjb250ZXh0LCB2YWx1ZXM6IHZhbHVlcywgY29udHJvbHM6IGNvbnRyb2xzLCBpbm5lclJlZjogcmVmIH0pKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUNvbXBvbmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRWYWx1ZUNvbnRyb2xzQ29uZmlnOiBmdW5jdGlvbiAocmVmLCB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgcmVhZFZhbHVlRnJvbVNvdXJjZTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXIocmVmLmN1cnJlbnQpLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYSBnb29kIHNlY29uZCBzb3VyY2Ugb2YgcGx1Z2lucy4gVGhpcyBmdW5jdGlvbiBjb250YWlucyB0aGUgQ1NTIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdW5pdCBjb252ZXJzaW9uIHN1cHBvcnQuIFRoZXNlIGZ1bmN0aW9ucyBzaGFyZSBhIGNvbW1vbiBzaWduYXR1cmUuIFdlIGNvdWxkIG1ha2UgYW5vdGhlclxyXG4gICAgICAgICAgICAgICAgLy8gQVBJIGZvciBhZGRpbmcgdGhlc2UuXHJcbiAgICAgICAgICAgICAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogcGFyc2VEb21WYXJpYW50KHZhbHVlcywgcmVmKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG52YXIgaHRtbE1vdGlvbkNvbXBvbmVudHMgPSBodG1sRWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIENvbXBvbmVudCkge1xyXG4gICAgdmFyIGNvbmZpZyA9IGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQpO1xyXG4gICAgLy8gU3VwcHJlc3MgXCJFeHByZXNzaW9uIHByb2R1Y2VzIGEgdW5pb24gdHlwZSB0aGF0IGlzIHRvbyBjb21wbGV4IHRvIHJlcHJlc2VudFwiIGVycm9yXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBhY2NbQ29tcG9uZW50XSA9IGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjb25maWcpO1xyXG4gICAgcmV0dXJuIGFjYztcclxufSwge30pO1xyXG52YXIgc3ZnTW90aW9uQ29tcG9uZW50cyA9IHN2Z0VsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBDb21wb25lbnQpIHtcclxuICAgIC8vIFN1cHByZXNzIFwiRXhwcmVzc2lvbiBwcm9kdWNlcyBhIHVuaW9uIHR5cGUgdGhhdCBpcyB0b28gY29tcGxleCB0byByZXByZXNlbnRcIiBlcnJvclxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgYWNjW0NvbXBvbmVudF0gPSBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCkpO1xyXG4gICAgcmV0dXJuIGFjYztcclxufSwge30pO1xyXG4vKipcclxuICogSFRNTCAmIFNWRyBjb21wb25lbnRzLCBvcHRpbWlzZWQgZm9yIHVzZSB3aXRoIGdlc3R1cmVzIGFuZCBhbmltYXRpb24uIFRoZXNlIGNhbiBiZSB1c2VkIGFzXHJcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnRzIGZvciBhbnkgSFRNTCAmIFNWRyBjb21wb25lbnQsIGFsbCBDU1MgJiBTVkcgcHJvcGVydGllcyBhcmUgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxyZW1hcmtzXHJcbiAqXHJcbiAqIEknZCBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgZm9yIHRoZXNlIHRvIGJlIGxvYWRlZCBcIm9uIGRlbWFuZFwiIC0gdG8gcmVkdWNlIGJ1bmRsZSBzaXplIGJ5IG9ubHlcclxuICogaW5jbHVkaW5nIEhUTUwvU1ZHIHN0eWxlcnMsIGFuaW1hdGlvbiBhbmQvb3IgZ2VzdHVyZSBzdXBwb3J0IHdoZW4gbmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogPG1vdGlvbi5kaXYgYW5pbWF0ZT17eyB4OiAxMDAgfX0gLz5cclxuICpcclxuICogPG1vdGlvbi5wIGFuaW1hdGU9e3sgaGVpZ2h0OiAyMDAgfX0gLz5cclxuICpcclxuICogPHN2Zz48bW90aW9uLmNpcmNsZSByPXsxMH0gYW5pbWF0ZT17eyByOiAyMCB9fSAvPjwvc3ZnPlxyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIG1vdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHsgXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYSBjdXN0b20gUmVhY3QgY29tcG9uZW50IGludG8gYSBgbW90aW9uYCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nLCB0byBjcmVhdGUgW2N1c3RvbSBET00gZWxlbWVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1VzaW5nX2N1c3RvbV9lbGVtZW50cykuXHJcbiAgICAgKlxyXG4gICAgICogYGBganN4XHJcbiAgICAgKiBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wczogUHJvcHMsIHJlZikgPT4ge1xyXG4gICAgICogICByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz5cclxuICAgICAqIH0pXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgTW90aW9uQ29tcG9uZW50ID0gbW90aW9uLmN1c3RvbTxQcm9wcz4oQ29tcG9uZW50KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIENvbXBvbmVudCAtXHJcbiAgICAgKi9cclxuICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKENvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCkpO1xyXG4gICAgfSB9LCBodG1sTW90aW9uQ29tcG9uZW50cyksIHN2Z01vdGlvbkNvbXBvbmVudHMpO1xuXG4vKipcclxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdG8gdHJhY2sgdGhlIHN0YXRlIGFuZCB2ZWxvY2l0eSBvZiBhIHZhbHVlLlxyXG4gKlxyXG4gKiBVc3VhbGx5LCB0aGVzZSBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5LiBGb3IgYWR2YW5jZWQgdXNlLWNhc2VzLCBsaWtlIHVzZSB3aXRoIGB1c2VUcmFuc2Zvcm1gLCB5b3UgY2FuIGNyZWF0ZSBgTW90aW9uVmFsdWVgcyBleHRlcm5hbGx5IGFuZCBwYXNzIHRoZW0gaW50byB0aGUgYW5pbWF0ZWQgY29tcG9uZW50IHZpYSB0aGUgYHN0eWxlYCBwcm9wLlxyXG4gKlxyXG4gKiBAbGlicmFyeVxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xyXG4gKiAgIGNvbnN0IHNjYWxlID0gdXNlTW90aW9uVmFsdWUoMSlcclxuICpcclxuICogICByZXR1cm4gPEZyYW1lIHNjYWxlPXtzY2FsZX0gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQG1vdGlvblxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHNjYWxlID0gdXNlTW90aW9uVmFsdWUoMSlcclxuICpcclxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGUgfX0gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGluaXRpYWwgLSBUaGUgaW5pdGlhbCBzdGF0ZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlTW90aW9uVmFsdWUoaW5pdGlhbCkge1xyXG4gICAgcmV0dXJuIHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblZhbHVlKGluaXRpYWwpOyB9KTtcclxufVxuXG4vKipcclxuICogSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgTW90aW9uVmFsdWUsIHRoaXMgcmV0dXJucyB0aGUgYWN0dWFsIHZhbHVlLCBvdGhlcndpc2UganVzdCB0aGUgdmFsdWUgaXRzZWxmXHJcbiAqXHJcbiAqIFRPRE86IFJlbW92ZSBhbmQgbW92ZSB0byBsaWJyYXJ5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdW53cmFwTW90aW9uVmFsdWUodmFsdWUpIHtcclxuICAgIHZhciB1bndyYXBwZWRWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgTW90aW9uVmFsdWUgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xyXG4gICAgcmV0dXJuIGlzQ3VzdG9tVmFsdWUodW53cmFwcGVkVmFsdWUpXHJcbiAgICAgICAgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKClcclxuICAgICAgICA6IHVud3JhcHBlZFZhbHVlO1xyXG59XG5cbnZhciBpc0N1c3RvbVZhbHVlVHlwZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXg7XHJcbn07XHJcbnZhciBnZXRNaXhlciA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAoaXNDdXN0b21WYWx1ZVR5cGUodikgPyB2Lm1peCA6IHVuZGVmaW5lZCk7IH07XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybSgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciB1c2VJbW1lZGlhdGUgPSAhQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcclxuICAgIHZhciBhcmdPZmZzZXQgPSB1c2VJbW1lZGlhdGUgPyAwIDogLTE7XHJcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IGFyZ3NbMCArIGFyZ09mZnNldF07XHJcbiAgICB2YXIgaW5wdXRSYW5nZSA9IGFyZ3NbMSArIGFyZ09mZnNldF07XHJcbiAgICB2YXIgb3V0cHV0UmFuZ2UgPSBhcmdzWzIgKyBhcmdPZmZzZXRdO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzMgKyBhcmdPZmZzZXRdO1xyXG4gICAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRlKGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBfX2Fzc2lnbih7IG1peGVyOiBnZXRNaXhlcihvdXRwdXRSYW5nZVswXSkgfSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIHVzZUltbWVkaWF0ZSA/IGludGVycG9sYXRvcihpbnB1dFZhbHVlKSA6IGludGVycG9sYXRvcjtcclxufVxuXG52YXIgaXNUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcclxufTtcclxudmFyIG5vb3AkMSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9O1xyXG5mdW5jdGlvbiB1c2VUcmFuc2Zvcm0ocGFyZW50LCBjdXN0b21UcmFuc2Zvcm0sIHRvLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB1c2VSZWYobnVsbCk7XHJcbiAgICB2YXIgY29tcGFyaXRvciA9IFtwYXJlbnRdO1xyXG4gICAgdmFyIHRyYW5zZm9ybWVyID0gbm9vcCQxO1xyXG4gICAgaWYgKGlzVHJhbnNmb3JtZXIoY3VzdG9tVHJhbnNmb3JtKSkge1xyXG4gICAgICAgIHRyYW5zZm9ybWVyID0gY3VzdG9tVHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0bykpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IGN1c3RvbVRyYW5zZm9ybTtcclxuICAgICAgICB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybShmcm9tLCB0bywgb3B0aW9ucyk7XHJcbiAgICAgICAgY29tcGFyaXRvciA9IFtwYXJlbnQsIGZyb20uam9pbihcIixcIiksIHRvLmpvaW4oXCIsXCIpXTtcclxuICAgIH1cclxuICAgIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodmFsdWUuY3VycmVudClcclxuICAgICAgICAgICAgdmFsdWUuY3VycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgdmFsdWUuY3VycmVudCA9IHBhcmVudC5hZGRDaGlsZCh7IHRyYW5zZm9ybWVyOiB0cmFuc2Zvcm1lciB9KTtcclxuICAgICAgICByZXR1cm4gdmFsdWUuY3VycmVudDtcclxuICAgIH0sIGNvbXBhcml0b3IpO1xyXG59XG5cbi8vIEtlZXAgdGhpbmdzIHJlYXNvbmFibGUgYW5kIGF2b2lkIHNjYWxlOiBJbmZpbml0eS4gSW4gcHJhY3Rpc2Ugd2UgbWlnaHQgbmVlZFxyXG4vLyB0byBhZGQgYW5vdGhlciB2YWx1ZSwgb3BhY2l0eSwgdGhhdCBjb3VsZCBpbnRlcnBvbGF0ZSBzY2FsZVgvWSBbMCwwLjAxXSA9PiBbMCwxXVxyXG4vLyB0byBzaW1wbHkgaGlkZSBjb250ZW50IGF0IHVucmVhc29uYWJsZSBzY2FsZXMuXHJcbnZhciBtYXhTY2FsZSA9IDEwMDAwMDtcclxudmFyIGludmVydFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7IHJldHVybiAoc2NhbGUgPiAwLjAwMSA/IDEgLyBzY2FsZSA6IG1heFNjYWxlKTsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBgTW90aW9uVmFsdWVgIGVhY2ggZm9yIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCB0aGF0IHVwZGF0ZSB3aXRoIHRoZSBpbnZlcnNlXHJcbiAqIG9mIHRoZWlyIHJlc3BlY3RpdmUgcGFyZW50IHNjYWxlcy5cclxuICpcclxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHVuZG9pbmcgdGhlIGRpc3RvcnRpb24gb2YgY29udGVudCB3aGVuIHNjYWxpbmcgYSBwYXJlbnQgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBgdXNlSW52ZXJ0ZWRTY2FsZWAgd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCBmcm9tIHRoZSBuZWFyZXN0IHBhcmVudC5cclxuICogQnkgcGFzc2luZyBvdGhlciBgTW90aW9uVmFsdWVgcyBpbiBhcyBgdXNlSW52ZXJ0ZWRTY2FsZSh7IHNjYWxlWCwgc2NhbGVZIH0pYCwgaXQgd2lsbCBpbnZlcnQgdGhlIG91dHB1dFxyXG4gKiBvZiB0aG9zZSBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAbW90aW9uXHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcclxuICogICBjb25zdCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB1c2VJbnZlcnRlZFNjYWxlKClcclxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGVYLCBzY2FsZVkgfX0gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGxpYnJhcnlcclxuICpcclxuICogYGBganN4XHJcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xyXG4gKiAgIGNvbnN0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHVzZUludmVydGVkU2NhbGUoKVxyXG4gKiAgIHJldHVybiA8RnJhbWUgc2NhbGVYPXtzY2FsZVh9IHNjYWxlWT17c2NhbGVZfSAvPlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VJbnZlcnRlZFNjYWxlKHNjYWxlKSB7XHJcbiAgICB2YXIgcGFyZW50U2NhbGVYID0gdXNlTW90aW9uVmFsdWUoMSk7XHJcbiAgICB2YXIgcGFyZW50U2NhbGVZID0gdXNlTW90aW9uVmFsdWUoMSk7XHJcbiAgICB2YXIgdmFsdWVzID0gdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KS52YWx1ZXM7XHJcbiAgICBpbnZhcmlhbnQoISEoc2NhbGUgfHwgdmFsdWVzKSwgXCJJZiBubyBzY2FsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCB1c2VJbnZlcnRlZFNjYWxlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZCBvZiBhbm90aGVyIG1vdGlvbiBjb21wb25lbnQuXCIpO1xyXG4gICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgICAgcGFyZW50U2NhbGVYID0gc2NhbGUuc2NhbGVYIHx8IHBhcmVudFNjYWxlWDtcclxuICAgICAgICBwYXJlbnRTY2FsZVkgPSBzY2FsZS5zY2FsZVkgfHwgcGFyZW50U2NhbGVZO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgcGFyZW50U2NhbGVYID0gdmFsdWVzLmdldChcInNjYWxlWFwiLCAxKTtcclxuICAgICAgICBwYXJlbnRTY2FsZVkgPSB2YWx1ZXMuZ2V0KFwic2NhbGVZXCIsIDEpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNjYWxlWCA9IHVzZVRyYW5zZm9ybShwYXJlbnRTY2FsZVgsIGludmVydFNjYWxlKTtcclxuICAgIHZhciBzY2FsZVkgPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVZLCBpbnZlcnRTY2FsZSk7XHJcbiAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcclxufVxuXG5mdW5jdGlvbiB1c2VPbkNoYW5nZSh2YWx1ZSwgY2FsbGJhY2spIHtcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiAoaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5vbkNoYW5nZShjYWxsYmFjaykgOiB1bmRlZmluZWQpOyB9LCBbdmFsdWVdKTtcclxufVxuXG4vKipcclxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCwgd2hlbiBgc2V0YCwgd2lsbCB1c2UgYSBzcHJpbmcgYW5pbWF0aW9uIHRvIGFuaW1hdGUgdG8gaXRzIG5ldyBzdGF0ZS5cclxuICpcclxuICogSXQgY2FuIGVpdGhlciB3b3JrIGFzIGEgc3RhbmQtYWxvbmUgYE1vdGlvblZhbHVlYCBieSBpbml0aWFsaXNpbmcgaXQgd2l0aCBhIHZhbHVlLCBvciBhcyBhIHN1YnNjcmliZXJcclxuICogdG8gYW5vdGhlciBgTW90aW9uVmFsdWVgLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogY29uc3QgeCA9IHVzZVNwcmluZygwLCB7IHN0aWZmbmVzczogMzAwIH0pXHJcbiAqIGNvbnN0IHkgPSB1c2VTcHJpbmcoeCwgeyBkYW1waW5nOiAxMCB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGlucHV0VmFsdWUgLSBgTW90aW9uVmFsdWVgIG9yIG51bWJlci4gSWYgcHJvdmlkZWQgYSBgTW90aW9uVmFsdWVgLCB3aGVuIHRoZSBpbnB1dCBgTW90aW9uVmFsdWVgIGNoYW5nZXMsIHRoZSBjcmVhdGVkIGBNb3Rpb25WYWx1ZWAgd2lsbCBzcHJpbmcgdG93YXJkcyB0aGF0IHZhbHVlLlxyXG4gKiBAcGFyYW0gc3ByaW5nQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc3ByaW5nLlxyXG4gKiBAcmV0dXJucyBgTW90aW9uVmFsdWVgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVzZVNwcmluZyhzb3VyY2UsIGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XHJcbiAgICB2YXIgYWN0aXZlU3ByaW5nQW5pbWF0aW9uID0gdXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHZhbHVlID0gdXNlTW90aW9uVmFsdWUoaXNNb3Rpb25WYWx1ZShzb3VyY2UpID8gc291cmNlLmdldCgpIDogc291cmNlKTtcclxuICAgIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5hdHRhY2goZnVuY3Rpb24gKHYsIHNldCkge1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50LnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudCA9IHNwcmluZyhfX2Fzc2lnbih7IGZyb206IHZhbHVlLmdldCgpLCB0bzogdiwgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCkgfSwgY29uZmlnKSkuc3RhcnQoc2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgT2JqZWN0LnZhbHVlcyhjb25maWcpKTtcclxuICAgIHVzZU9uQ2hhbmdlKHNvdXJjZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlLnNldChwYXJzZUZsb2F0KHYpKTsgfSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY3JvbGxYOiBtb3Rpb25WYWx1ZSgwKSxcclxuICAgICAgICBzY3JvbGxZOiBtb3Rpb25WYWx1ZSgwKSxcclxuICAgICAgICBzY3JvbGxYUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApLFxyXG4gICAgICAgIHNjcm9sbFlQcm9ncmVzczogbW90aW9uVmFsdWUoMCksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNldFByb2dyZXNzKG9mZnNldCwgbWF4T2Zmc2V0LCB2YWx1ZSkge1xyXG4gICAgdmFsdWUuc2V0KCFvZmZzZXQgfHwgIW1heE9mZnNldCA/IDAgOiBvZmZzZXQgLyBtYXhPZmZzZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbFVwZGF0ZXIodmFsdWVzLCBnZXRPZmZzZXRzKSB7XHJcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IGdldE9mZnNldHMoKSwgeE9mZnNldCA9IF9hLnhPZmZzZXQsIHlPZmZzZXQgPSBfYS55T2Zmc2V0LCB4TWF4T2Zmc2V0ID0gX2EueE1heE9mZnNldCwgeU1heE9mZnNldCA9IF9hLnlNYXhPZmZzZXQ7XHJcbiAgICAgICAgLy8gU2V0IGFic29sdXRlIHBvc2l0aW9uc1xyXG4gICAgICAgIHZhbHVlcy5zY3JvbGxYLnNldCh4T2Zmc2V0KTtcclxuICAgICAgICB2YWx1ZXMuc2Nyb2xsWS5zZXQoeU9mZnNldCk7XHJcbiAgICAgICAgLy8gU2V0IDAtMSBwcm9ncmVzc1xyXG4gICAgICAgIHNldFByb2dyZXNzKHhPZmZzZXQsIHhNYXhPZmZzZXQsIHZhbHVlcy5zY3JvbGxYUHJvZ3Jlc3MpO1xyXG4gICAgICAgIHNldFByb2dyZXNzKHlPZmZzZXQsIHlNYXhPZmZzZXQsIHZhbHVlcy5zY3JvbGxZUHJvZ3Jlc3MpO1xyXG4gICAgfTtcclxuICAgIHVwZGF0ZSgpO1xyXG4gICAgcmV0dXJuIHVwZGF0ZTtcclxufVxuXG52YXIgZ2V0RWxlbWVudFNjcm9sbE9mZnNldHMgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4T2Zmc2V0OiBlbGVtZW50LnNjcm9sbExlZnQsXHJcbiAgICAgICAgeU9mZnNldDogZWxlbWVudC5zY3JvbGxUb3AsXHJcbiAgICAgICAgeE1heE9mZnNldDogZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgeU1heE9mZnNldDogZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBlbGVtZW50Lm9mZnNldEhlaWdodCxcclxuICAgIH07XHJcbn07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIE1vdGlvblZhbHVlcyB0aGF0IHVwZGF0ZSB3aGVuIHRoZSBwcm92aWRlZCBlbGVtZW50IHNjcm9sbHM6XHJcbiAqXHJcbiAqIC0gYHNjcm9sbFhgIOKAlCBIb3Jpem9udGFsIHNjcm9sbCBkaXN0YW5jZSBpbiBwaXhlbHMuXHJcbiAqIC0gYHNjcm9sbFlgIOKAlCBWZXJ0aWNhbCBzY3JvbGwgZGlzdGFuY2UgaW4gcGl4ZWxzLlxyXG4gKiAtIGBzY3JvbGxYUHJvZ3Jlc3NgIOKAlCBIb3Jpem9udGFsIHNjcm9sbCBwcm9ncmVzcyBiZXR3ZWVuIGAwYCBhbmQgYDFgLlxyXG4gKiAtIGBzY3JvbGxZUHJvZ3Jlc3NgIOKAlCBWZXJ0aWNhbCBzY3JvbGwgcHJvZ3Jlc3MgYmV0d2VlbiBgMGAgYW5kIGAxYC5cclxuICpcclxuICogQGxpYnJhcnlcclxuICpcclxuICogYGBganN4XHJcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcbiAqIGltcG9ydCB7XHJcbiAqICAgRnJhbWUsXHJcbiAqICAgdXNlRWxlbWVudFNjcm9sbCxcclxuICogICB1c2VUcmFuc2Zvcm1cclxuICogfSBmcm9tIFwiZnJhbWVyXCJcclxuICpcclxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xyXG4gKiAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZigpXHJcbiAqICAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZUVsZW1lbnRTY3JvbGwocmVmKVxyXG4gKlxyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8RnJhbWUgcmVmPXtyZWZ9PlxyXG4gKiAgICAgICA8RnJhbWUgc2NhbGVYPXtzY3JvbGxZUHJvZ3Jlc3N9IC8+XHJcbiAqICAgICA8L0ZyYW1lPlxyXG4gKiAgIClcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQG1vdGlvblxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHJlZiA9IHVzZVJlZigpXHJcbiAqICAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZUVsZW1lbnRTY3JvbGwocmVmKVxyXG4gKlxyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8ZGl2IHJlZj17cmVmfT5cclxuICogICAgICAgPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGVYOiBzY3JvbGxZUHJvZ3Jlc3MgfX0gLz5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIClcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlRWxlbWVudFNjcm9sbChyZWYpIHtcclxuICAgIHZhciB2YWx1ZXMgPSB1c2VDb25zdGFudChjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMpO1xyXG4gICAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xyXG4gICAgICAgIGludmFyaWFudCghIWVsZW1lbnQsIFwicmVmIHByb3ZpZGVkIHRvIHVzZVNjcm9sbCBtdXN0IGJlIHBhc3NlZCBpbnRvIGEgSFRNTCBlbGVtZW50LlwiKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdXBkYXRlU2Nyb2xsVmFsdWVzID0gY3JlYXRlU2Nyb2xsVXBkYXRlcih2YWx1ZXMsIGdldEVsZW1lbnRTY3JvbGxPZmZzZXRzKGVsZW1lbnQpKTtcclxuICAgICAgICB2YXIgc2Nyb2xsTGlzdGVuZXIgPSBhZGREb21FdmVudChlbGVtZW50LCBcInNjcm9sbFwiLCB1cGRhdGVTY3JvbGxWYWx1ZXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICB2YXIgcmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudChlbGVtZW50LCBcInJlc2l6ZVwiLCB1cGRhdGVTY3JvbGxWYWx1ZXMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbExpc3RlbmVyICYmIHNjcm9sbExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIHJlc2l6ZUxpc3RlbmVyICYmIHJlc2l6ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cblxudmFyIHZpZXdwb3J0U2Nyb2xsVmFsdWVzID0gY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKCk7XHJcbmZ1bmN0aW9uIGdldFZpZXdwb3J0U2Nyb2xsT2Zmc2V0cygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeE9mZnNldDogd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgICAgIHlPZmZzZXQ6IHdpbmRvdy5wYWdlWU9mZnNldCxcclxuICAgICAgICB4TWF4T2Zmc2V0OiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC0gd2luZG93LmlubmVyV2lkdGgsXHJcbiAgICAgICAgeU1heE9mZnNldDogZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQsXHJcbiAgICB9O1xyXG59XHJcbnZhciBoYXNMaXN0ZW5lcnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICBoYXNMaXN0ZW5lcnMgPSB0cnVlO1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHVwZGF0ZVNjcm9sbFZhbHVlcyA9IGNyZWF0ZVNjcm9sbFVwZGF0ZXIodmlld3BvcnRTY3JvbGxWYWx1ZXMsIGdldFZpZXdwb3J0U2Nyb2xsT2Zmc2V0cyk7XHJcbiAgICBhZGREb21FdmVudCh3aW5kb3csIFwic2Nyb2xsXCIsIHVwZGF0ZVNjcm9sbFZhbHVlcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgYWRkRG9tRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB1cGRhdGVTY3JvbGxWYWx1ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIE1vdGlvblZhbHVlcyB0aGF0IHVwZGF0ZSB3aGVuIHRoZSB2aWV3cG9ydCBzY3JvbGxzOlxyXG4gKlxyXG4gKiAtIGBzY3JvbGxYYCDigJQgSG9yaXpvbnRhbCBzY3JvbGwgZGlzdGFuY2UgaW4gcGl4ZWxzLlxyXG4gKiAtIGBzY3JvbGxZYCDigJQgVmVydGljYWwgc2Nyb2xsIGRpc3RhbmNlIGluIHBpeGVscy5cclxuICogLSBgc2Nyb2xsWFByb2dyZXNzYCDigJQgSG9yaXpvbnRhbCBzY3JvbGwgcHJvZ3Jlc3MgYmV0d2VlbiBgMGAgYW5kIGAxYC5cclxuICogLSBgc2Nyb2xsWVByb2dyZXNzYCDigJQgVmVydGljYWwgc2Nyb2xsIHByb2dyZXNzIGJldHdlZW4gYDBgIGFuZCBgMWAuXHJcbiAqXHJcbiAqIEBsaWJyYXJ5XHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxyXG4gKiBpbXBvcnQge1xyXG4gKiAgIEZyYW1lLFxyXG4gKiAgIHVzZVZpZXdwb3J0U2Nyb2xsLFxyXG4gKiAgIHVzZVRyYW5zZm9ybVxyXG4gKiB9IGZyb20gXCJmcmFtZXJcIlxyXG4gKlxyXG4gKiBleHBvcnQgZnVuY3Rpb24gTXlDb21wb25lbnQoKSB7XHJcbiAqICAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZVZpZXdwb3J0U2Nyb2xsKClcclxuICogICByZXR1cm4gPEZyYW1lIHNjYWxlWD17c2Nyb2xsWVByb2dyZXNzfSAvPlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAbW90aW9uXHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAqICAgY29uc3QgeyBzY3JvbGxZUHJvZ3Jlc3MgfSA9IHVzZVZpZXdwb3J0U2Nyb2xsKClcclxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGVYOiBzY3JvbGxZUHJvZ3Jlc3MgfX0gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlVmlld3BvcnRTY3JvbGwoKSB7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICFoYXNMaXN0ZW5lcnMgJiYgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB2aWV3cG9ydFNjcm9sbFZhbHVlcztcclxufVxuXG4vKipcclxuICogQ3JlYXRlcyBgQW5pbWF0aW9uQ29udHJvbHNgLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtYW51YWxseSBzdGFydCwgc3RvcFxyXG4gKiBhbmQgc2VxdWVuY2UgYW5pbWF0aW9ucyBvbiBvbmUgb3IgbW9yZSBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgYEFuaW1hdGlvbkNvbnRyb2xzYCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBgYW5pbWF0ZWAgcHJvcGVydHlcclxuICogb2YgdGhlIGNvbXBvbmVudHMgeW91IHdhbnQgdG8gYW5pbWF0ZS5cclxuICpcclxuICogVGhlc2UgY29tcG9uZW50cyBjYW4gdGhlbiBiZSBhbmltYXRlZCB3aXRoIHRoZSBgc3RhcnRgIG1ldGhvZC5cclxuICpcclxuICogQGxpYnJhcnlcclxuICpcclxuICogYGBganN4XHJcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xyXG4gKiBpbXBvcnQgeyBGcmFtZSwgdXNlQW5pbWF0aW9uIH0gZnJvbSAnZnJhbWVyJ1xyXG4gKlxyXG4gKiBleHBvcnQgZnVuY3Rpb24gTXlDb21wb25lbnQocHJvcHMpIHtcclxuICogICAgY29uc3QgY29udHJvbHMgPSB1c2VBbmltYXRpb24oKVxyXG4gKlxyXG4gKiAgICBjb250cm9scy5zdGFydCh7XHJcbiAqICAgICAgICB4OiAxMDAsXHJcbiAqICAgICAgICB0cmFuc2l0aW9uOiB7IGR1cmF0aW9uOiAwLjUgfSxcclxuICogICAgfSlcclxuICpcclxuICogICAgcmV0dXJuIDxGcmFtZSBhbmltYXRlPXtjb250cm9sc30gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQG1vdGlvblxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQW5pbWF0aW9uIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcclxuICpcclxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KHByb3BzKSB7XHJcbiAqICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlQW5pbWF0aW9uKClcclxuICpcclxuICogICAgY29udHJvbHMuc3RhcnQoe1xyXG4gKiAgICAgICAgeDogMTAwLFxyXG4gKiAgICAgICAgdHJhbnNpdGlvbjogeyBkdXJhdGlvbjogMC41IH0sXHJcbiAqICAgIH0pXHJcbiAqXHJcbiAqICAgIHJldHVybiA8bW90aW9uLmRpdiBhbmltYXRlPXtjb250cm9sc30gLz5cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHJldHVybnMgQW5pbWF0aW9uIGNvbnRyb2xsZXIgd2l0aCBgc3RhcnRgIGFuZCBgc3RvcGAgbWV0aG9kc1xyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VBbmltYXRpb24oKSB7XHJcbiAgICB2YXIgYW5pbWF0aW9uQ29udHJvbHMgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQW5pbWF0aW9uQ29udHJvbHMoKTsgfSk7XHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFuaW1hdGlvbkNvbnRyb2xzLm1vdW50KCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGlvbkNvbnRyb2xzLnVubW91bnQoKTsgfTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiBhbmltYXRpb25Db250cm9scztcclxufVxuXG4vKipcclxuICogRXhwZXJpbWVudGFsIEFQSS5cclxuICpcclxuICogTWFrZXMgYW4gYW5pbWF0ZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKlxyXG4gKiBXaGVuIHRoZSByZXR1cm5lZCBzdGF0ZSBzZXR0ZXIgaXMgY2FsbGVkLCB2YWx1ZXMgd2lsbCBiZSBhbmltYXRlZCB0byB0aGVpciBuZXcgdGFyZ2V0LlxyXG4gKlxyXG4gKiBUaGlzIGFsbG93cyB0aGUgYW5pbWF0aW9uIG9mIGFyYml0cmFyeSBSZWFjdCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogV2hlbiBhbmltYXRpbmcgRE9NIGNvbXBvbmVudHMsIGl0J3MgYWx3YXlzIHByZWZlcmFibGUgdG8gdXNlIHRoZSBgYW5pbWF0ZWAgcHJvcCwgYXMgRnJhbWVyXHJcbiAqIHdpbGwgYnlwYXNzIFJlYWN0J3MgcmVuZGVyaW5nIGN5Y2xlIHdpdGggb25lIG9wdGltaXNlZCBmb3IgNjBmcHMgbW90aW9uLiBUaGlzIEhvb2sgaXMgc3BlY2lmaWNhbGx5XHJcbiAqIGZvciBhbmltYXRpbmcgcHJvcHMgb24gYXJiaXRyYXJ5IFJlYWN0IGNvbXBvbmVudHMsIG9yIGZvciBhbmltYXRpbmcgdGV4dCBjb250ZW50LlxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VBbmltYXRlZFN0YXRlKHsgcGVyY2VudGFnZTogMCB9KVxyXG4gKlxyXG4gKiByZXR1cm4gKFxyXG4gKiAgIDxHcmFwaFxyXG4gKiAgICAgcGVyY2VudGFnZT17c3RhdGUucGVyY2VudGFnZX1cclxuICogICAgIG9uVGFwPXsoKSA9PiBzZXRTdGF0ZSh7IHBlcmNlbnRhZ2U6IDUwIH0pfVxyXG4gKiAgIC8+XHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBpbnRlcm5hbHJlbWFya3NcclxuICpcclxuICogVE9ETzpcclxuICogLSBNYWtlIGhvb2sgYWNjZXB0IGEgdHlwZWQgdmVyc2lvbiBvZiBUYXJnZXQgdGhhdCBhY2NlcHRzIGFueSB2YWx1ZSAobm90IGp1c3QgRE9NIHZhbHVlcylcclxuICogLSBBbGxvdyBob29rIHRvIGFjY2VwdCBzaW5nbGUgdmFsdWVzLiBpZSB1c2VBbmltYXRlZFN0YXRlKDApXHJcbiAqIC0gQWxsb3cgcHJvdmlkaW5nIE1vdGlvblZhbHVlcyB2aWEgaW5pdGlhbFN0YXRlLlxyXG4gKlxyXG4gKiBAYmV0YVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQW5pbWF0ZWRTdGF0ZShpbml0aWFsU3RhdGUpIHtcclxuICAgIHZhciBfYSA9IHVzZVN0YXRlKGluaXRpYWxTdGF0ZSksIGFuaW1hdGlvblN0YXRlID0gX2FbMF0sIG9uVXBkYXRlID0gX2FbMV07XHJcbiAgICB2YXIgY29uZmlnID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgb25VcGRhdGU6IG9uVXBkYXRlIH0pOyB9KTtcclxuICAgIHZhciB2YWx1ZXMgPSB1c2VNb3Rpb25WYWx1ZXMoY29uZmlnKTtcclxuICAgIHZhciBjb250cm9scyA9IHVzZVZhbHVlQW5pbWF0aW9uQ29udHJvbHMoe1xyXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgIHJlYWRWYWx1ZUZyb21Tb3VyY2U6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFuaW1hdGlvblN0YXRlW2tleV07IH0sXHJcbiAgICB9LCB7fSwgZmFsc2UpO1xyXG4gICAgdmFyIHN0YXJ0QW5pbWF0aW9uID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY29udHJvbHMuc3RhcnQoYW5pbWF0aW9uRGVmaW5pdGlvbik7XHJcbiAgICB9OyB9KTtcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFsdWVzLm1vdW50KCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlcy51bm1vdW50KCk7IH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gW2FuaW1hdGlvblN0YXRlLCBzdGFydEFuaW1hdGlvbl07XHJcbn1cblxuLyoqXHJcbiAqIEN5Y2xlcyB0aHJvdWdoIGEgc2VyaWVzIG9mIHZpc3VhbCBwcm9wZXJ0aWVzLiBDYW4gYmUgdXNlZCB0byB0b2dnbGUgYmV0d2VlbiBvciBjeWNsZSB0aHJvdWdoIGFuaW1hdGlvbnMuIEl0IHdvcmtzIHNpbWlsYXIgdG8gYHVzZVN0YXRlYCBpbiBSZWFjdC4gSXQgaXMgcHJvdmlkZWQgYW4gaW5pdGlhbCBhcnJheSBvZiBwb3NzaWJsZSBzdGF0ZXMsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHR3byBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBsaWJyYXJ5XHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxyXG4gKiBpbXBvcnQgeyBGcmFtZSwgdXNlQ3ljbGUgfSBmcm9tIFwiZnJhbWVyXCJcclxuICpcclxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xyXG4gKiAgIGNvbnN0IFt4LCBjeWNsZVhdID0gdXNlQ3ljbGUoMCwgNTAsIDEwMClcclxuICpcclxuICogICByZXR1cm4gKFxyXG4gKiAgICAgPEZyYW1lXHJcbiAqICAgICAgIGFuaW1hdGU9e3sgeDogeCB9fVxyXG4gKiAgICAgICBvblRhcD17KCkgPT4gY3ljbGVYKCl9XHJcbiAqICAgICAgLz5cclxuICogICAgKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAbW90aW9uXHJcbiAqXHJcbiAqIEFuIGluZGV4IHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGBjeWNsZWAgZnVuY3Rpb24gdG8gY3ljbGUgdG8gYSBzcGVjaWZpYyBpbmRleC5cclxuICpcclxuICogYGBganN4XHJcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQ3ljbGUgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcclxuICogICBjb25zdCBbeCwgY3ljbGVYXSA9IHVzZUN5Y2xlKDAsIDUwLCAxMDApXHJcbiAqXHJcbiAqICAgcmV0dXJuIChcclxuICogICAgIDxtb3Rpb24uZGl2XHJcbiAqICAgICAgIGFuaW1hdGU9e3sgeDogeCB9fVxyXG4gKiAgICAgICBvblRhcD17KCkgPT4gY3ljbGVYKCl9XHJcbiAqICAgICAgLz5cclxuICogICAgKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gaXRlbXMgLSBpdGVtcyB0byBjeWNsZSB0aHJvdWdoXHJcbiAqIEByZXR1cm5zIFtjdXJyZW50U3RhdGUsIGN5Y2xlU3RhdGVdXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHVzZUN5Y2xlKCkge1xyXG4gICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBBZnRlciBGcmFtZXIgWCBiZXRhLCByZW1vdmUgdGhpcyB3YXJuaW5nXHJcbiAgICB3YXJuaW5nKGl0ZW1zLmxlbmd0aCA+IDEsIFwidXNlQ3ljbGUgc3ludGF4IGhhcyBjaGFuZ2VkLiBgdXNlQ3ljbGUoWzAsIDEsIDJdKWAgYmVjb21lcyBgdXNlQ3ljbGUoMCwgMSwgMilgXCIpO1xyXG4gICAgdmFyIGluZGV4ID0gdXNlUmVmKDApO1xyXG4gICAgdmFyIF9hID0gdXNlU3RhdGUoaXRlbXNbaW5kZXguY3VycmVudF0pLCBpdGVtID0gX2FbMF0sIHNldEl0ZW0gPSBfYVsxXTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaXRlbSxcclxuICAgICAgICBmdW5jdGlvbiAobmV4dCkge1xyXG4gICAgICAgICAgICBpbmRleC5jdXJyZW50ID1cclxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXh0ICE9PSBcIm51bWJlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyB3cmFwKDAsIGl0ZW1zLmxlbmd0aCwgaW5kZXguY3VycmVudCArIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXh0O1xyXG4gICAgICAgICAgICBzZXRJdGVtKGl0ZW1zW2luZGV4LmN1cnJlbnRdKTtcclxuICAgICAgICB9LFxyXG4gICAgXTtcclxufVxuXG4vKipcclxuICogQ2FuIG1hbnVhbGx5IHRyaWdnZXIgYSBkcmFnIGdlc3R1cmUgb24gb25lIG9yIG1vcmUgYGRyYWdgLWVuYWJsZWQgYG1vdGlvbmAgY29tcG9uZW50cy5cclxuICpcclxuICogQGxpYnJhcnlcclxuICpcclxuICogYGBganN4XHJcbiAqIGNvbnN0IGRyYWdDb250cm9scyA9IHVzZURyYWdDb250cm9scygpXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xyXG4gKiAgIGRyYWdDb250cm9scy5zdGFydChldmVudCwgeyBzbmFwVG9DdXJzb3I6IHRydWUgfSlcclxuICogfVxyXG4gKlxyXG4gKiByZXR1cm4gKFxyXG4gKiAgIDw+XHJcbiAqICAgICA8RnJhbWUgb25UYXBTdGFydD17c3RhcnREcmFnfSAvPlxyXG4gKiAgICAgPEZyYW1lIGRyYWc9XCJ4XCIgZHJhZ0NvbnRyb2xzPXtkcmFnQ29udHJvbHN9IC8+XHJcbiAqICAgPC8+XHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBtb3Rpb25cclxuICpcclxuICogYGBganN4XHJcbiAqIGNvbnN0IGRyYWdDb250cm9scyA9IHVzZURyYWdDb250cm9scygpXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xyXG4gKiAgIGRyYWdDb250cm9scy5zdGFydChldmVudCwgeyBzbmFwVG9DdXJzb3I6IHRydWUgfSlcclxuICogfVxyXG4gKlxyXG4gKiByZXR1cm4gKFxyXG4gKiAgIDw+XHJcbiAqICAgICA8ZGl2IG9uTW91c2VEb3duPXtzdGFydERyYWd9IC8+XHJcbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxyXG4gKiAgIDwvPlxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgRHJhZ0NvbnRyb2xzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRHJhZ0NvbnRyb2xzKCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBhIGNvbXBvbmVudCdzIGludGVybmFsIGBDb21wb25lbnREcmFnQ29udHJvbHNgIHRvIHRoZSB1c2VyLWZhY2luZyBBUEkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIERyYWdDb250cm9scy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNvbnRyb2xzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzLmFkZChjb250cm9scyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbXBvbmVudENvbnRyb2xzLmRlbGV0ZShjb250cm9scyk7IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhIGRyYWcgZ2VzdHVyZSBvbiBldmVyeSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBoYXMgdGhpcyBzZXQgb2YgZHJhZyBjb250cm9sc1xyXG4gICAgICogcGFzc2VkIGludG8gaXQgdmlhIHRoZSBgZHJhZ0NvbnRyb2xzYCBwcm9wLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzeFxyXG4gICAgICogZHJhZ0NvbnRyb2xzLnN0YXJ0KGUsIHtcclxuICAgICAqICAgc25hcFRvQ3Vyc29yOiB0cnVlXHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQSBtb3VzZS90b3VjaC9wb2ludGVyIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBEcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9scykge1xyXG4gICAgICAgICAgICBjb250cm9scy5zdGFydChldmVudC5uYXRpdmVFdmVudCB8fCBldmVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYWdDb250cm9scztcclxufSgpKTtcclxudmFyIGNyZWF0ZURyYWdDb250cm9scyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEcmFnQ29udHJvbHMoKTsgfTtcclxuLyoqXHJcbiAqIFVzdWFsbHksIGRyYWdnaW5nIGlzIGluaXRpYXRlZCBieSBwcmVzc2luZyBkb3duIG9uIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGggYSBgZHJhZ2AgcHJvcFxyXG4gKiBhbmQgbW92aW5nIGl0LiBGb3Igc29tZSB1c2UtY2FzZXMsIGZvciBpbnN0YW5jZSBjbGlja2luZyBhdCBhbiBhcmJpdHJhcnkgcG9pbnQgb24gYSB2aWRlbyBzY3J1YmJlciwgd2VcclxuICogbWlnaHQgd2FudCB0byBpbml0aWF0ZSB0aGF0IGRyYWdnaW5nIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IHRoYW4gdGhlIGRyYWdnYWJsZSBvbmUuXHJcbiAqXHJcbiAqIEJ5IGNyZWF0aW5nIGEgYGRyYWdDb250cm9sc2AgdXNpbmcgdGhlIGB1c2VEcmFnQ29udHJvbHNgIGhvb2ssIHdlIGNhbiBwYXNzIHRoaXMgaW50b1xyXG4gKiB0aGUgZHJhZ2dhYmxlIGNvbXBvbmVudCdzIGBkcmFnQ29udHJvbHNgIHByb3AuIEl0IGV4cG9zZXMgYSBgc3RhcnRgIG1ldGhvZFxyXG4gKiB0aGF0IGNhbiBzdGFydCBkcmFnZ2luZyBmcm9tIHBvaW50ZXIgZXZlbnRzIG9uIG90aGVyIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBsaWJyYXJ5XHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxyXG4gKlxyXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcclxuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXHJcbiAqIH1cclxuICpcclxuICogcmV0dXJuIChcclxuICogICA8PlxyXG4gKiAgICAgPEZyYW1lIG9uVGFwU3RhcnQ9e3N0YXJ0RHJhZ30gLz5cclxuICogICAgIDxGcmFtZSBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxyXG4gKiAgIDwvPlxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAbW90aW9uXHJcbiAqXHJcbiAqIGBgYGpzeFxyXG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxyXG4gKlxyXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcclxuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXHJcbiAqIH1cclxuICpcclxuICogcmV0dXJuIChcclxuICogICA8PlxyXG4gKiAgICAgPGRpdiBvbk1vdXNlRG93bj17c3RhcnREcmFnfSAvPlxyXG4gKiAgICAgPG1vdGlvbi5kaXYgZHJhZz1cInhcIiBkcmFnQ29udHJvbHM9e2RyYWdDb250cm9sc30gLz5cclxuICogICA8Lz5cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlRHJhZ0NvbnRyb2xzKCkge1xyXG4gICAgcmV0dXJuIHVzZUNvbnN0YW50KGNyZWF0ZURyYWdDb250cm9scyk7XHJcbn1cblxudmFyIFByZXNlbmNlQ2hpbGQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpbml0aWFsID0gX2EuaW5pdGlhbCwgaXNQcmVzZW50ID0gX2EuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IF9hLm9uRXhpdENvbXBsZXRlLCBjdXN0b20gPSBfYS5jdXN0b207XHJcbiAgICB2YXIgbnVtUHJlc2VuY2VDaGlsZHJlbiA9IHVzZVJlZigwKTtcclxuICAgIHZhciBudW1FeGl0Q29tcGxldGUgPSB1c2VSZWYoMCk7XHJcbiAgICB2YXIgY29udGV4dCA9IHtcclxuICAgICAgICBpbml0aWFsOiBpbml0aWFsLFxyXG4gICAgICAgIGlzUHJlc2VudDogaXNQcmVzZW50LFxyXG4gICAgICAgIGN1c3RvbTogY3VzdG9tLFxyXG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG51bUV4aXRDb21wbGV0ZS5jdXJyZW50Kys7XHJcbiAgICAgICAgICAgIHZhciBhbGxDb21wbGV0ZSA9IG51bUV4aXRDb21wbGV0ZS5jdXJyZW50ID49IG51bVByZXNlbmNlQ2hpbGRyZW4uY3VycmVudDtcclxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgYWxsQ29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHZhciByZWdpc3RlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG51bUV4aXRDb21wbGV0ZS5jdXJyZW50ID0gMDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBudW1QcmVzZW5jZUNoaWxkcmVuLmN1cnJlbnQrKztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bVByZXNlbmNlQ2hpbGRyZW4uY3VycmVudC0tOyB9O1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbaXNQcmVzZW50XSk7XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHsgcmVnaXN0ZXI6IHJlZ2lzdGVyIH0pIH0sIGNoaWxkcmVuKSk7XHJcbn07XG5cbmZ1bmN0aW9uIGdldENoaWxkS2V5KGNoaWxkKSB7XHJcbiAgICByZXR1cm4gY2hpbGQua2V5IHx8IFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRMb29rdXAoY2hpbGRyZW4sIGFsbENoaWxkcmVuKSB7XHJcbiAgICB2YXIgc2VlbkNoaWxkcmVuID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gbmV3IFNldCgpIDogbnVsbDtcclxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGdldENoaWxkS2V5KGNoaWxkKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHNlZW5DaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoc2VlbkNoaWxkcmVuLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDaGlsZHJlbiBvZiBBbmltYXRlUHJlc2VuY2UgcmVxdWlyZSB1bmlxdWUga2V5cy4gXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgZHVwbGljYXRlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWVuQ2hpbGRyZW4uYWRkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFsbENoaWxkcmVuLnNldChrZXksIGNoaWxkKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG9ubHlFbGVtZW50cyhjaGlsZHJlbikge1xyXG4gICAgdmFyIGZpbHRlcmVkID0gW107XHJcbiAgICAvLyBXZSB1c2UgZm9yRWFjaCBoZXJlIGluc3RlYWQgb2YgbWFwIGFzIG1hcCBtdXRhdGVzIHRoZSBjb21wb25lbnQga2V5IGJ5IHByZXByZW5kaW5nIGAuJGBcclxuICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpXHJcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goY2hpbGQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbn1cclxuLyoqXHJcbiAqIGBBbmltYXRlUHJlc2VuY2VgIGVuYWJsZXMgdGhlIGFuaW1hdGlvbiBvZiBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS5cclxuICpcclxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxyXG4gKlxyXG4gKiBAbGlicmFyeVxyXG4gKlxyXG4gKiBBbnkgYEZyYW1lYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXHJcbiAqIHRoZSB0cmVlLlxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogaW1wb3J0IHsgRnJhbWUsIEFuaW1hdGVQcmVzZW5jZSB9IGZyb20gJ2ZyYW1lcidcclxuICpcclxuICogLy8gQXMgaXRlbXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gYGl0ZW1zYFxyXG4gKiBleHBvcnQgZnVuY3Rpb24gSXRlbXMoeyBpdGVtcyB9KSB7XHJcbiAqICAgcmV0dXJuIChcclxuICogICAgIDxBbmltYXRlUHJlc2VuY2U+XHJcbiAqICAgICAgIHtpdGVtcy5tYXAoaXRlbSA9PiAoXHJcbiAqICAgICAgICAgPEZyYW1lXHJcbiAqICAgICAgICAgICBrZXk9e2l0ZW0uaWR9XHJcbiAqICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cclxuICogICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxyXG4gKiAgICAgICAgICAgZXhpdD17eyBvcGFjaXR5OiAwIH19XHJcbiAqICAgICAgICAgLz5cclxuICogICAgICAgKSl9XHJcbiAqICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cclxuICogICApXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFlvdSBjYW4gc2VxdWVuY2UgZXhpdCBhbmltYXRpb25zIHRocm91Z2hvdXQgYSB0cmVlIHVzaW5nIHZhcmlhbnRzLlxyXG4gKlxyXG4gKiBAbW90aW9uXHJcbiAqXHJcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXHJcbiAqIHRoZSB0cmVlLlxyXG4gKlxyXG4gKiBgYGBqc3hcclxuICogaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tICdmcmFtZXItbW90aW9uJ1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXHJcbiAqICAgPEFuaW1hdGVQcmVzZW5jZT5cclxuICogICAgIHtpdGVtcy5tYXAoaXRlbSA9PiAoXHJcbiAqICAgICAgIDxtb3Rpb24uZGl2XHJcbiAqICAgICAgICAga2V5PXtpdGVtLmlkfVxyXG4gKiAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCB9fVxyXG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxyXG4gKiAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxyXG4gKiAgICAgICAvPlxyXG4gKiAgICAgKSl9XHJcbiAqICAgPC9BbmltYXRlUHJlc2VuY2U+XHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIFlvdSBjYW4gc2VxdWVuY2UgZXhpdCBhbmltYXRpb25zIHRocm91Z2hvdXQgYSB0cmVlIHVzaW5nIHZhcmlhbnRzLlxyXG4gKlxyXG4gKiBJZiBhIGNoaWxkIGNvbnRhaW5zIG11bHRpcGxlIGBtb3Rpb25gIGNvbXBvbmVudHMgd2l0aCBgZXhpdGAgcHJvcHMsIGl0IHdpbGwgb25seSB1bm1vdW50IHRoZSBjaGlsZFxyXG4gKiBvbmNlIGFsbCBgbW90aW9uYCBjb21wb25lbnRzIGhhdmUgZmluaXNoZWQgYW5pbWF0aW5nIG91dC4gTGlrZXdpc2UsIGFueSBjb21wb25lbnRzIHVzaW5nXHJcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIEFuaW1hdGVQcmVzZW5jZSA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGN1c3RvbSA9IF9hLmN1c3RvbSwgX2IgPSBfYS5pbml0aWFsLCBpbml0aWFsID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgb25FeGl0Q29tcGxldGUgPSBfYS5vbkV4aXRDb21wbGV0ZSwgZXhpdEJlZm9yZUVudGVyID0gX2EuZXhpdEJlZm9yZUVudGVyO1xyXG4gICAgLy8gV2Ugd2FudCB0byBmb3JjZSBhIHJlLXJlbmRlciBvbmNlIGFsbCBleGl0aW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZC4gV2VcclxuICAgIC8vIGVpdGhlciB1c2UgYSBsb2NhbCBmb3JjZVVwZGF0ZSBmdW5jdGlvbiwgb3Igb25lIGZyb20gYSBwYXJlbnQgY29udGV4dCBpZiBpdCBleGlzdHMuXHJcbiAgICB2YXIgbG9jYWxGb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XHJcbiAgICB2YXIgY29udGV4dEZvcmNlVXBkYXRlID0gdXNlQ29udGV4dChTeW5jTGF5b3V0Q29udGV4dCk7XHJcbiAgICB2YXIgZm9yY2VVcGRhdGUgPSBjb250ZXh0Rm9yY2VVcGRhdGUgfHwgbG9jYWxGb3JjZVVwZGF0ZTtcclxuICAgIHZhciBpc0luaXRpYWxSZW5kZXIgPSB1c2VSZWYodHJ1ZSk7XHJcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBjaGlsZHJlbiB0aGF0IGFyZW4ndCBSZWFjdEVsZW1lbnRzLiBXZSBjYW4gb25seSB0cmFjayBSZWFjdEVsZW1lbnRzIHdpdGggYSBwcm9wcy5rZXlcclxuICAgIHZhciBmaWx0ZXJlZENoaWxkcmVuID0gb25seUVsZW1lbnRzKGNoaWxkcmVuKTtcclxuICAgIC8vIEtlZXAgYSBsaXZpbmcgcmVjb3JkIG9mIHRoZSBjaGlsZHJlbiB3ZSdyZSBhY3R1YWxseSByZW5kZXJpbmcgc28gd2VcclxuICAgIC8vIGNhbiBkaWZmIHRvIGZpZ3VyZSBvdXQgd2hpY2ggYXJlIGVudGVyaW5nIGFuZCBleGl0aW5nXHJcbiAgICB2YXIgcHJlc2VudENoaWxkcmVuID0gdXNlUmVmKGZpbHRlcmVkQ2hpbGRyZW4pO1xyXG4gICAgLy8gQSBsb29rdXAgdGFibGUgdG8gcXVpY2tseSByZWZlcmVuY2UgY29tcG9uZW50cyBieSBrZXlcclxuICAgIHZhciBhbGxDaGlsZHJlbiA9IHVzZVJlZihuZXcgTWFwKCkpXHJcbiAgICAgICAgLmN1cnJlbnQ7XHJcbiAgICAvLyBBIGxpdmluZyByZWNvcmQgb2YgYWxsIGN1cnJlbnRseSBleGl0aW5nIGNvbXBvbmVudHMuXHJcbiAgICB2YXIgZXhpdGluZyA9IHVzZVJlZihuZXcgU2V0KCkpLmN1cnJlbnQ7XHJcbiAgICB1cGRhdGVDaGlsZExvb2t1cChmaWx0ZXJlZENoaWxkcmVuLCBhbGxDaGlsZHJlbik7XHJcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBpbml0aWFsIGNvbXBvbmVudCByZW5kZXIsIGp1c3QgZGVhbCB3aXRoIGxvZ2ljIHN1cnJvdW5kaW5nIHdoZXRoZXJcclxuICAgIC8vIHdlIHBsYXkgb25Nb3VudCBhbmltYXRpb25zIG9yIG5vdC5cclxuICAgIGlmIChpc0luaXRpYWxSZW5kZXIuY3VycmVudCkge1xyXG4gICAgICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBmaWx0ZXJlZENoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFByZXNlbmNlQ2hpbGQsIHsga2V5OiBnZXRDaGlsZEtleShjaGlsZCksIGlzUHJlc2VudDogdHJ1ZSwgaW5pdGlhbDogaW5pdGlhbCA/IHVuZGVmaW5lZCA6IGZhbHNlIH0sIGNoaWxkKSk7IH0pKSk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGlzIGlzIGEgc3Vic2VxdWVudCByZW5kZXIsIGRlYWwgd2l0aCBlbnRlcmluZyBhbmQgZXhpdGluZyBjaGlsZHJlblxyXG4gICAgdmFyIGNoaWxkcmVuVG9SZW5kZXIgPSBfX3NwcmVhZEFycmF5cyhmaWx0ZXJlZENoaWxkcmVuKTtcclxuICAgIC8vIERpZmYgdGhlIGtleXMgb2YgdGhlIGN1cnJlbnRseS1wcmVzZW50IGFuZCB0YXJnZXQgY2hpbGRyZW4gdG8gdXBkYXRlIG91clxyXG4gICAgLy8gZXhpdGluZyBsaXN0LlxyXG4gICAgdmFyIHByZXNlbnRLZXlzID0gcHJlc2VudENoaWxkcmVuLmN1cnJlbnQubWFwKGdldENoaWxkS2V5KTtcclxuICAgIHZhciB0YXJnZXRLZXlzID0gZmlsdGVyZWRDaGlsZHJlbi5tYXAoZ2V0Q2hpbGRLZXkpO1xyXG4gICAgLy8gRGlmZiB0aGUgcHJlc2VudCBjaGlsZHJlbiB3aXRoIG91ciB0YXJnZXQgY2hpbGRyZW4gYW5kIG1hcmsgdGhvc2UgdGhhdCBhcmUgZXhpdGluZ1xyXG4gICAgdmFyIG51bVByZXNlbnQgPSBwcmVzZW50S2V5cy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByZXNlbnQ7IGkrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBwcmVzZW50S2V5c1tpXTtcclxuICAgICAgICBpZiAodGFyZ2V0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGV4aXRpbmcuYWRkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIHRoaXMga2V5IGhhcyByZS1lbnRlcmVkLCByZW1vdmUgZnJvbSB0aGUgZXhpdGluZyBsaXN0XHJcbiAgICAgICAgICAgIGV4aXRpbmcuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgZXhpdGluZyBjaGlsZHJlbiwgYW5kIHdlJ3JlIGRlZmVycmluZyByZW5kZXJpbmcgaW5jb21pbmcgY2hpbGRyZW5cclxuICAgIC8vIHVudGlsIGFmdGVyIGFsbCBjdXJyZW50IGNoaWxkcmVuIGhhdmUgZXhpdGluZywgZW1wdHkgdGhlIGNoaWxkcmVuVG9SZW5kZXIgYXJyYXlcclxuICAgIGlmIChleGl0QmVmb3JlRW50ZXIgJiYgZXhpdGluZy5zaXplKSB7XHJcbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlciA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBjdXJyZW50bHkgZXhpdGluZyBjb21wb25lbnRzIGFuZCBjbG9uZSB0aGVtIHRvIG92ZXJ3cml0ZSBgYW5pbWF0ZWBcclxuICAgIC8vIHdpdGggYW55IGBleGl0YCBwcm9wIHRoZXkgbWlnaHQgaGF2ZSBkZWZpbmVkLlxyXG4gICAgZXhpdGluZy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCBpcyBhY3R1YWxseSBlbnRlcmluZyBhZ2FpbiwgZWFybHkgcmV0dXJuXHJcbiAgICAgICAgaWYgKHRhcmdldEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGFsbENoaWxkcmVuLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghY2hpbGQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBwcmVzZW50S2V5cy5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgdmFyIG9uRXhpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZXhpdGluZy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgY2hpbGQgZnJvbSB0aGUgcHJlc2VudCBjaGlsZHJlblxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5maW5kSW5kZXgoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5rZXkgPT09IGtleTsgfSk7XHJcbiAgICAgICAgICAgIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50LnNwbGljZShyZW1vdmVJbmRleCwgMSk7XHJcbiAgICAgICAgICAgIC8vIERlZmVyIHJlLXJlbmRlcmluZyB1bnRpbCBhbGwgZXhpdGluZyBjaGlsZHJlbiBoYXZlIGluZGVlZCBsZWZ0XHJcbiAgICAgICAgICAgIGlmICghZXhpdGluZy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVzZW50Q2hpbGRyZW4uY3VycmVudCA9IGZpbHRlcmVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlci5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIGNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiBmYWxzZSwgb25FeGl0Q29tcGxldGU6IG9uRXhpdCwgY3VzdG9tOiBjdXN0b20gfSwgY2hpbGQpKTtcclxuICAgIH0pO1xyXG4gICAgLy8gQWRkIGBNb3Rpb25Db250ZXh0YCBldmVuIHRvIGNoaWxkcmVuIHRoYXQgZG9uJ3QgbmVlZCBpdCB0byBlbnN1cmUgd2UncmUgcmVuZGVyaW5nXHJcbiAgICAvLyB0aGUgc2FtZSB0cmVlIGJldHdlZW4gcmVuZGVyc1xyXG4gICAgY2hpbGRyZW5Ub1JlbmRlciA9IGNoaWxkcmVuVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XHJcbiAgICAgICAgcmV0dXJuIGV4aXRpbmcuaGFzKGtleSkgPyAoY2hpbGQpIDogKGNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiB0cnVlIH0sIGNoaWxkKSk7XHJcbiAgICB9KTtcclxuICAgIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gY2hpbGRyZW5Ub1JlbmRlcjtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcclxuICAgICAgICBleGl0QmVmb3JlRW50ZXIgJiZcclxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UncmUgYXR0ZW1wdGluZyB0byBhbmltYXRlIG11bHRpcGxlIGNoaWxkcmVuIHdpdGhpbiBBbmltYXRlUHJlc2VuY2UsIGJ1dCBpdHMgZXhpdEJlZm9yZUVudGVyIHByb3AgaXMgc2V0IHRvIHRydWUuIFRoaXMgd2lsbCBsZWFkIHRvIG9kZCB2aXN1YWwgYmVoYXZpb3VyLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgZXhpdGluZy5zaXplXHJcbiAgICAgICAgPyBjaGlsZHJlblRvUmVuZGVyXHJcbiAgICAgICAgOiBjaGlsZHJlblRvUmVuZGVyLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCk7IH0pKSk7XHJcbn07XG5cbi8vIERvZXMgdGhpcyBkZXZpY2UgcHJlZmVyIHJlZHVjZWQgbW90aW9uPyBSZXR1cm5zIGBudWxsYCBzZXJ2ZXItc2lkZS5cclxudmFyIHByZWZlcnNSZWR1Y2VkTW90aW9uID0gbW90aW9uVmFsdWUobnVsbCk7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcclxuICAgICAgICB2YXIgbW90aW9uTWVkaWFRdWVyeV8xID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XHJcbiAgICAgICAgdmFyIHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWZlcnNSZWR1Y2VkTW90aW9uLnNldChtb3Rpb25NZWRpYVF1ZXJ5XzEubWF0Y2hlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBtb3Rpb25NZWRpYVF1ZXJ5XzEuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcclxuICAgICAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLnNldChmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lU2hvdWxkUmVkdWNlTW90aW9uKHByZWZlcnNSZWR1Y2VkLCBpc1JlZHVjZWRNb3Rpb24pIHtcclxuICAgIHJldHVybiB0eXBlb2YgaXNSZWR1Y2VkTW90aW9uID09PSBcImJvb2xlYW5cIlxyXG4gICAgICAgID8gaXNSZWR1Y2VkTW90aW9uXHJcbiAgICAgICAgOiBCb29sZWFuKHByZWZlcnNSZWR1Y2VkKTtcclxufVxuXG4vKipcclxuICogQSBob29rIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgd2Ugc2hvdWxkIGJlIHVzaW5nIHJlZHVjZWQgbW90aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRldmljZSdzIFJlZHVjZWQgTW90aW9uIHNldHRpbmcuXHJcbiAqXHJcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGNoYW5nZXMgdG8geW91ciBVSSBiYXNlZCBvbiBSZWR1Y2VkIE1vdGlvbi4gRm9yIGluc3RhbmNlLCByZXBsYWNpbmcgbW90aW9uLXNpY2tuZXNzIGluZHVjaW5nXHJcbiAqIGB4YC9geWAgYW5pbWF0aW9ucyB3aXRoIGBvcGFjaXR5YCwgZGlzYWJsaW5nIHRoZSBhdXRvcGxheSBvZiBiYWNrZ3JvdW5kIHZpZGVvcywgb3IgdHVybmluZyBvZmYgcGFyYWxsYXggbW90aW9uLlxyXG4gKlxyXG4gKiBJdCB3aWxsIGFjdGl2ZWx5IHJlc3BvbmQgdG8gY2hhbmdlcyBhbmQgcmUtcmVuZGVyIHlvdXIgY29tcG9uZW50cyB3aXRoIHRoZSBsYXRlc3Qgc2V0dGluZy5cclxuICpcclxuICogYGBganN4XHJcbiAqIGV4cG9ydCBmdW5jdGlvbiBTaWRlYmFyKHsgaXNPcGVuIH0pIHtcclxuICogICBjb25zdCBzaG91bGRSZWR1Y2VNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uKClcclxuICogICBjb25zdCBjbG9zZWRYID0gc2hvdWxkUmVkdWNlTW90aW9uID8gMCA6IFwiLTEwMCVcIlxyXG4gKlxyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7XHJcbiAqICAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxyXG4gKiAgICAgICB4OiBpc09wZW4gPyAwIDogY2xvc2VkWFxyXG4gKiAgICAgfX0gLz5cclxuICogICApXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEByZXR1cm4gYm9vbGVhblxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uKCkge1xyXG4gICAgdmFyIGlzUmVkdWNlZE1vdGlvbiA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dCkuaXNSZWR1Y2VkTW90aW9uO1xyXG4gICAgdmFyIF9hID0gdXNlU3RhdGUoZGV0ZXJtaW5lU2hvdWxkUmVkdWNlTW90aW9uKHByZWZlcnNSZWR1Y2VkTW90aW9uLmdldCgpLCBpc1JlZHVjZWRNb3Rpb24pKSwgc2hvdWxkUmVkdWNlTW90aW9uID0gX2FbMF0sIHNldFNob3VsZFJlZHVjZU1vdGlvbiA9IF9hWzFdO1xyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gcHJlZmVyc1JlZHVjZWRNb3Rpb24ub25DaGFuZ2UoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgc2V0U2hvdWxkUmVkdWNlTW90aW9uKGRldGVybWluZVNob3VsZFJlZHVjZU1vdGlvbih2LCBpc1JlZHVjZWRNb3Rpb24pKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtzZXRTaG91bGRSZWR1Y2VNb3Rpb24sIGlzUmVkdWNlZE1vdGlvbl0pO1xyXG4gICAgcmV0dXJuIHNob3VsZFJlZHVjZU1vdGlvbjtcclxufVxuXG4vKipcclxuICogRGVmaW5lIGFjY2Vzc2liaWxpdHkgb3B0aW9ucyBmb3IgYSB0cmVlLiBDYW4gYmUgdXNlZCB0byBmb3JjZSB0aGUgdHJlZSBpbnRvIFJlZHVjZWQgTW90aW9uIG1vZGUsXHJcbiAqIG9yIGRpc2FibGUgZGV2aWNlIGRldGVjdGlvbi5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWR1Y2VkTW90aW9uKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZW5hYmxlZCA9IF9hLmVuYWJsZWQ7XHJcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XHJcbiAgICBjb250ZXh0ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGlzUmVkdWNlZE1vdGlvbjogZW5hYmxlZCB9KSk7IH0sIFtlbmFibGVkXSk7XHJcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbikpO1xyXG59XG5cbmV4cG9ydCB7IEFuaW1hdGVQcmVzZW5jZSwgQW5pbWF0aW9uQ29udHJvbHMsIERyYWdDb250cm9scywgTW90aW9uQ29udGV4dCwgTW90aW9uUGx1Z2luQ29udGV4dCwgTW90aW9uUGx1Z2lucywgTW90aW9uVmFsdWUsIFBvaW50LCBSZWR1Y2VkTW90aW9uLCBVbnN0YWJsZVN5bmNMYXlvdXQsIGFuaW1hdGlvbkNvbnRyb2xzLCBjcmVhdGVNb3Rpb25Db21wb25lbnQsIGlzVmFsaWRNb3Rpb25Qcm9wLCBtb3Rpb24sIG1vdGlvblZhbHVlLCB0cmFuc2Zvcm0sIHVud3JhcE1vdGlvblZhbHVlLCB1c2VBbmltYXRlZFN0YXRlLCB1c2VBbmltYXRpb24sIHVzZUN5Y2xlLCB1c2VEb21FdmVudCwgdXNlRHJhZ0NvbnRyb2xzLCB1c2VFbGVtZW50U2Nyb2xsLCB1c2VFeHRlcm5hbFJlZiwgdXNlR2VzdHVyZXMsIHVzZUludmVydGVkU2NhbGUsIHVzZU1vdGlvblZhbHVlLCB1c2VQYW5HZXN0dXJlLCB1c2VQcmVzZW5jZSwgdXNlUmVkdWNlZE1vdGlvbiwgdXNlU3ByaW5nLCB1c2VUYXBHZXN0dXJlLCB1c2VUcmFuc2Zvcm0sIHVzZVZpZXdwb3J0U2Nyb2xsIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/framer-motion/dist/framer-motion.es.js\n");

/***/ }),

/***/ "./node_modules/framesync/dist/framesync.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/framesync/dist/framesync.es.js ***!
  \*****************************************************/
/*! exports provided: default, cancelSync, getFrameData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cancelSync\", function() { return cancelSync; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFrameData\", function() { return getFrameData; });\n/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hey-listen */ \"./node_modules/hey-listen/dist/hey-listen.es.js\");\n\n\nvar prevTime = 0;\r\nvar onNextFrame = typeof window !== 'undefined' && window.requestAnimationFrame !== undefined\r\n    ? function (callback) { return window.requestAnimationFrame(callback); }\r\n    : function (callback) {\r\n        var timestamp = Date.now();\r\n        var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));\r\n        prevTime = timestamp + timeToCall;\r\n        setTimeout(function () { return callback(prevTime); }, timeToCall);\r\n    };\n\nvar createStep = (function (setRunNextFrame) {\r\n    var processToRun = [];\r\n    var processToRunNextFrame = [];\r\n    var numThisFrame = 0;\r\n    var isProcessing = false;\r\n    var i = 0;\r\n    var cancelled = new WeakSet();\r\n    var toKeepAlive = new WeakSet();\r\n    var renderStep = {\r\n        cancel: function (process) {\r\n            var indexOfCallback = processToRunNextFrame.indexOf(process);\r\n            cancelled.add(process);\r\n            if (indexOfCallback !== -1) {\r\n                processToRunNextFrame.splice(indexOfCallback, 1);\r\n            }\r\n        },\r\n        process: function (frame) {\r\n            var _a;\r\n            isProcessing = true;\r\n            _a = [\r\n                processToRunNextFrame,\r\n                processToRun\r\n            ], processToRun = _a[0], processToRunNextFrame = _a[1];\r\n            processToRunNextFrame.length = 0;\r\n            numThisFrame = processToRun.length;\r\n            if (numThisFrame) {\r\n                var process_1;\r\n                for (i = 0; i < numThisFrame; i++) {\r\n                    process_1 = processToRun[i];\r\n                    process_1(frame);\r\n                    if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {\r\n                        renderStep.schedule(process_1);\r\n                        setRunNextFrame(true);\r\n                    }\r\n                }\r\n            }\r\n            isProcessing = false;\r\n        },\r\n        schedule: function (process, keepAlive, immediate) {\r\n            if (keepAlive === void 0) { keepAlive = false; }\r\n            if (immediate === void 0) { immediate = false; }\r\n            Object(hey_listen__WEBPACK_IMPORTED_MODULE_0__[\"invariant\"])(typeof process === 'function', 'Argument must be a function');\r\n            var addToCurrentBuffer = immediate && isProcessing;\r\n            var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;\r\n            cancelled.delete(process);\r\n            if (keepAlive)\r\n                toKeepAlive.add(process);\r\n            if (buffer.indexOf(process) === -1) {\r\n                buffer.push(process);\r\n                if (addToCurrentBuffer)\r\n                    numThisFrame = processToRun.length;\r\n            }\r\n        }\r\n    };\r\n    return renderStep;\r\n});\n\nvar StepId;\r\n(function (StepId) {\r\n    StepId[\"Read\"] = \"read\";\r\n    StepId[\"Update\"] = \"update\";\r\n    StepId[\"Render\"] = \"render\";\r\n    StepId[\"PostRender\"] = \"postRender\";\r\n    StepId[\"FixedUpdate\"] = \"fixedUpdate\";\r\n})(StepId || (StepId = {}));\n\nvar maxElapsed = 40;\r\nvar defaultElapsed = (1 / 60) * 1000;\r\nvar useDefaultElapsed = true;\r\nvar willRunNextFrame = false;\r\nvar isProcessing = false;\r\nvar frame = {\r\n    delta: 0,\r\n    timestamp: 0\r\n};\r\nvar stepsOrder = [\r\n    StepId.Read,\r\n    StepId.Update,\r\n    StepId.Render,\r\n    StepId.PostRender\r\n];\r\nvar setWillRunNextFrame = function (willRun) { return (willRunNextFrame = willRun); };\r\nvar _a = stepsOrder.reduce(function (acc, key) {\r\n    var step = createStep(setWillRunNextFrame);\r\n    acc.sync[key] = function (process, keepAlive, immediate) {\r\n        if (keepAlive === void 0) { keepAlive = false; }\r\n        if (immediate === void 0) { immediate = false; }\r\n        if (!willRunNextFrame)\r\n            startLoop();\r\n        step.schedule(process, keepAlive, immediate);\r\n        return process;\r\n    };\r\n    acc.cancelSync[key] = function (process) { return step.cancel(process); };\r\n    acc.steps[key] = step;\r\n    return acc;\r\n}, {\r\n    steps: {},\r\n    sync: {},\r\n    cancelSync: {}\r\n}), steps = _a.steps, sync = _a.sync, cancelSync = _a.cancelSync;\r\nvar processStep = function (stepId) { return steps[stepId].process(frame); };\r\nvar processFrame = function (timestamp) {\r\n    willRunNextFrame = false;\r\n    frame.delta = useDefaultElapsed\r\n        ? defaultElapsed\r\n        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\r\n    if (!useDefaultElapsed)\r\n        defaultElapsed = frame.delta;\r\n    frame.timestamp = timestamp;\r\n    isProcessing = true;\r\n    stepsOrder.forEach(processStep);\r\n    isProcessing = false;\r\n    if (willRunNextFrame) {\r\n        useDefaultElapsed = false;\r\n        onNextFrame(processFrame);\r\n    }\r\n};\r\nvar startLoop = function () {\r\n    willRunNextFrame = true;\r\n    useDefaultElapsed = true;\r\n    if (!isProcessing)\r\n        onNextFrame(processFrame);\r\n};\r\nvar getFrameData = function () { return frame; };\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sync);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2ZyYW1lc3luYy5lcy5qcz83OTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVDOztBQUV2QztBQUNBO0FBQ0EsMkJBQTJCLCtDQUErQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkIsRUFBRTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRCx1Q0FBdUMsbUJBQW1CO0FBQzFELFlBQVksNERBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQ0FBcUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RCxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNkJBQTZCO0FBQzNFO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLENBQUM7QUFDRCxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7O0FBRS9CLG1FQUFJLEVBQUM7QUFDZ0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZnJhbWVzeW5jLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5cbnZhciBwcmV2VGltZSA9IDA7XHJcbnZhciBvbk5leHRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IHVuZGVmaW5lZFxyXG4gICAgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spOyB9XHJcbiAgICA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYuNyAtICh0aW1lc3RhbXAgLSBwcmV2VGltZSkpO1xyXG4gICAgICAgIHByZXZUaW1lID0gdGltZXN0YW1wICsgdGltZVRvQ2FsbDtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKHByZXZUaW1lKTsgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICB9O1xuXG52YXIgY3JlYXRlU3RlcCA9IChmdW5jdGlvbiAoc2V0UnVuTmV4dEZyYW1lKSB7XHJcbiAgICB2YXIgcHJvY2Vzc1RvUnVuID0gW107XHJcbiAgICB2YXIgcHJvY2Vzc1RvUnVuTmV4dEZyYW1lID0gW107XHJcbiAgICB2YXIgbnVtVGhpc0ZyYW1lID0gMDtcclxuICAgIHZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBjYW5jZWxsZWQgPSBuZXcgV2Vha1NldCgpO1xyXG4gICAgdmFyIHRvS2VlcEFsaXZlID0gbmV3IFdlYWtTZXQoKTtcclxuICAgIHZhciByZW5kZXJTdGVwID0ge1xyXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHByb2Nlc3MpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4T2ZDYWxsYmFjayA9IHByb2Nlc3NUb1J1bk5leHRGcmFtZS5pbmRleE9mKHByb2Nlc3MpO1xyXG4gICAgICAgICAgICBjYW5jZWxsZWQuYWRkKHByb2Nlc3MpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhPZkNhbGxiYWNrICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1RvUnVuTmV4dEZyYW1lLnNwbGljZShpbmRleE9mQ2FsbGJhY2ssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBfYSA9IFtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUb1J1bk5leHRGcmFtZSxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUb1J1blxyXG4gICAgICAgICAgICBdLCBwcm9jZXNzVG9SdW4gPSBfYVswXSwgcHJvY2Vzc1RvUnVuTmV4dEZyYW1lID0gX2FbMV07XHJcbiAgICAgICAgICAgIHByb2Nlc3NUb1J1bk5leHRGcmFtZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBudW1UaGlzRnJhbWUgPSBwcm9jZXNzVG9SdW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobnVtVGhpc0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc18xO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVRoaXNGcmFtZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc18xID0gcHJvY2Vzc1RvUnVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NfMShmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvS2VlcEFsaXZlLmhhcyhwcm9jZXNzXzEpID09PSB0cnVlICYmICFjYW5jZWxsZWQuaGFzKHByb2Nlc3NfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RlcC5zY2hlZHVsZShwcm9jZXNzXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSdW5OZXh0RnJhbWUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NoZWR1bGU6IGZ1bmN0aW9uIChwcm9jZXNzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoa2VlcEFsaXZlID09PSB2b2lkIDApIHsga2VlcEFsaXZlID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgcHJvY2VzcyA9PT0gJ2Z1bmN0aW9uJywgJ0FyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgYWRkVG9DdXJyZW50QnVmZmVyID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZztcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGFkZFRvQ3VycmVudEJ1ZmZlciA/IHByb2Nlc3NUb1J1biA6IHByb2Nlc3NUb1J1bk5leHRGcmFtZTtcclxuICAgICAgICAgICAgY2FuY2VsbGVkLmRlbGV0ZShwcm9jZXNzKTtcclxuICAgICAgICAgICAgaWYgKGtlZXBBbGl2ZSlcclxuICAgICAgICAgICAgICAgIHRvS2VlcEFsaXZlLmFkZChwcm9jZXNzKTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKHByb2Nlc3MpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2gocHJvY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWRkVG9DdXJyZW50QnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIG51bVRoaXNGcmFtZSA9IHByb2Nlc3NUb1J1bi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlbmRlclN0ZXA7XHJcbn0pO1xuXG52YXIgU3RlcElkO1xyXG4oZnVuY3Rpb24gKFN0ZXBJZCkge1xyXG4gICAgU3RlcElkW1wiUmVhZFwiXSA9IFwicmVhZFwiO1xyXG4gICAgU3RlcElkW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcclxuICAgIFN0ZXBJZFtcIlJlbmRlclwiXSA9IFwicmVuZGVyXCI7XHJcbiAgICBTdGVwSWRbXCJQb3N0UmVuZGVyXCJdID0gXCJwb3N0UmVuZGVyXCI7XHJcbiAgICBTdGVwSWRbXCJGaXhlZFVwZGF0ZVwiXSA9IFwiZml4ZWRVcGRhdGVcIjtcclxufSkoU3RlcElkIHx8IChTdGVwSWQgPSB7fSkpO1xuXG52YXIgbWF4RWxhcHNlZCA9IDQwO1xyXG52YXIgZGVmYXVsdEVsYXBzZWQgPSAoMSAvIDYwKSAqIDEwMDA7XHJcbnZhciB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XHJcbnZhciB3aWxsUnVuTmV4dEZyYW1lID0gZmFsc2U7XHJcbnZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcclxudmFyIGZyYW1lID0ge1xyXG4gICAgZGVsdGE6IDAsXHJcbiAgICB0aW1lc3RhbXA6IDBcclxufTtcclxudmFyIHN0ZXBzT3JkZXIgPSBbXHJcbiAgICBTdGVwSWQuUmVhZCxcclxuICAgIFN0ZXBJZC5VcGRhdGUsXHJcbiAgICBTdGVwSWQuUmVuZGVyLFxyXG4gICAgU3RlcElkLlBvc3RSZW5kZXJcclxuXTtcclxudmFyIHNldFdpbGxSdW5OZXh0RnJhbWUgPSBmdW5jdGlvbiAod2lsbFJ1bikgeyByZXR1cm4gKHdpbGxSdW5OZXh0RnJhbWUgPSB3aWxsUnVuKTsgfTtcclxudmFyIF9hID0gc3RlcHNPcmRlci5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XHJcbiAgICB2YXIgc3RlcCA9IGNyZWF0ZVN0ZXAoc2V0V2lsbFJ1bk5leHRGcmFtZSk7XHJcbiAgICBhY2Muc3luY1trZXldID0gZnVuY3Rpb24gKHByb2Nlc3MsIGtlZXBBbGl2ZSwgaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgaWYgKGtlZXBBbGl2ZSA9PT0gdm9pZCAwKSB7IGtlZXBBbGl2ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCF3aWxsUnVuTmV4dEZyYW1lKVxyXG4gICAgICAgICAgICBzdGFydExvb3AoKTtcclxuICAgICAgICBzdGVwLnNjaGVkdWxlKHByb2Nlc3MsIGtlZXBBbGl2ZSwgaW1tZWRpYXRlKTtcclxuICAgICAgICByZXR1cm4gcHJvY2VzcztcclxuICAgIH07XHJcbiAgICBhY2MuY2FuY2VsU3luY1trZXldID0gZnVuY3Rpb24gKHByb2Nlc3MpIHsgcmV0dXJuIHN0ZXAuY2FuY2VsKHByb2Nlc3MpOyB9O1xyXG4gICAgYWNjLnN0ZXBzW2tleV0gPSBzdGVwO1xyXG4gICAgcmV0dXJuIGFjYztcclxufSwge1xyXG4gICAgc3RlcHM6IHt9LFxyXG4gICAgc3luYzoge30sXHJcbiAgICBjYW5jZWxTeW5jOiB7fVxyXG59KSwgc3RlcHMgPSBfYS5zdGVwcywgc3luYyA9IF9hLnN5bmMsIGNhbmNlbFN5bmMgPSBfYS5jYW5jZWxTeW5jO1xyXG52YXIgcHJvY2Vzc1N0ZXAgPSBmdW5jdGlvbiAoc3RlcElkKSB7IHJldHVybiBzdGVwc1tzdGVwSWRdLnByb2Nlc3MoZnJhbWUpOyB9O1xyXG52YXIgcHJvY2Vzc0ZyYW1lID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xyXG4gICAgd2lsbFJ1bk5leHRGcmFtZSA9IGZhbHNlO1xyXG4gICAgZnJhbWUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZFxyXG4gICAgICAgID8gZGVmYXVsdEVsYXBzZWRcclxuICAgICAgICA6IE1hdGgubWF4KE1hdGgubWluKHRpbWVzdGFtcCAtIGZyYW1lLnRpbWVzdGFtcCwgbWF4RWxhcHNlZCksIDEpO1xyXG4gICAgaWYgKCF1c2VEZWZhdWx0RWxhcHNlZClcclxuICAgICAgICBkZWZhdWx0RWxhcHNlZCA9IGZyYW1lLmRlbHRhO1xyXG4gICAgZnJhbWUudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcclxuICAgIHN0ZXBzT3JkZXIuZm9yRWFjaChwcm9jZXNzU3RlcCk7XHJcbiAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgIGlmICh3aWxsUnVuTmV4dEZyYW1lKSB7XHJcbiAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xyXG4gICAgfVxyXG59O1xyXG52YXIgc3RhcnRMb29wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgd2lsbFJ1bk5leHRGcmFtZSA9IHRydWU7XHJcbiAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XHJcbiAgICBpZiAoIWlzUHJvY2Vzc2luZylcclxuICAgICAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xyXG59O1xyXG52YXIgZ2V0RnJhbWVEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhbWU7IH07XG5cbmV4cG9ydCBkZWZhdWx0IHN5bmM7XG5leHBvcnQgeyBjYW5jZWxTeW5jLCBnZXRGcmFtZURhdGEgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/framesync/dist/framesync.es.js\n");

/***/ }),

/***/ "./node_modules/hey-listen/dist/hey-listen.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/hey-listen/dist/hey-listen.es.js ***!
  \*******************************************************/
/*! exports provided: invariant, warning */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invariant\", function() { return invariant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warning\", function() { return warning; });\nvar warning = function () { };\r\nvar invariant = function () { };\r\nif (true) {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hleS1saXN0ZW4vZGlzdC9oZXktbGlzdGVuLmVzLmpzP2YzNjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2hleS1saXN0ZW4vZGlzdC9oZXktbGlzdGVuLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7IH07XHJcbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIWNoZWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hey-listen/dist/hey-listen.es.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcz80MWViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhLHNDQUFzQyxzQkFBc0I7QUFDekUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KTttb2R1bGUuZXhwb3J0cz1hc3NpZ247bW9kdWxlLmV4cG9ydHMuZGVmYXVsdD1tb2R1bGUuZXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/object-assign.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fprojects&absolutePagePath=%2Fhome%2Fmacmac%2FProjects%2Fmarkanthonyuy.github.io%2Fpages%2Fprojects.js!./":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fprojects&absolutePagePath=%2Fhome%2Fmacmac%2FProjects%2Fmarkanthonyuy.github.io%2Fpages%2Fprojects.js ***!
  \************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/projects\",\n      function () {\n        return __webpack_require__(/*! ./pages/projects.js */ \"./pages/projects.js\");\n      }\n    ]);\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzPzVmZmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBaUU7QUFDeEY7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9wYWdlPSUyRnByb2plY3RzJmFic29sdXRlUGFnZVBhdGg9JTJGaG9tZSUyRm1hY21hYyUyRlByb2plY3RzJTJGbWFya2FudGhvbnl1eS5naXRodWIuaW8lMkZwYWdlcyUyRnByb2plY3RzLmpzIS4vLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9wcm9qZWN0c1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi9ob21lL21hY21hYy9Qcm9qZWN0cy9tYXJrYW50aG9ueXV5LmdpdGh1Yi5pby9wYWdlcy9wcm9qZWN0cy5qc1wiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fprojects&absolutePagePath=%2Fhome%2Fmacmac%2FProjects%2Fmarkanthonyuy.github.io%2Fpages%2Fprojects.js!./\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks\n// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n// Tests for existence of standard globals is to allow style-loader\n// to operate correctly into non-standard environments\n// @see https://github.com/webpack-contrib/style-loader/issues/177\nmemo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself\nif(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked\n// due to cross-origin restrictions\nstyleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next\nstyleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=id+' '+count.toString();idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier:identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef\n true?__webpack_require__.nc:undefined;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(function(key){style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if\nif(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?'@media '+obj.media+' {'+obj.css+'}':obj.css;// For old IE\n/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+='\\n/*# sourceMappingURL=data:application/json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))+' */';}// For old IE\n/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=function(){removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=function(list,options){options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nif(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/Nzc2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSxpQ0FBaUMsU0FBUywyQkFBMkIsOEJBQThCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWUsR0FBRyxxQ0FBcUMsY0FBYyxpQ0FBaUMsc0NBQXNDLCtDQUErQztBQUN2UCw4RUFBOEUsSUFBSTtBQUNsRjtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZELG1CQUFtQiwwQkFBMEIsdUJBQXVCLEdBQUcscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVkscUJBQXFCLEtBQUssMkNBQTJDLFNBQVMsUUFBUSxlQUFlLG9DQUFvQyxvQkFBb0IscUJBQXFCLFlBQVksY0FBYyxLQUFLLG1CQUFtQixtREFBbUQsOEJBQThCLHlDQUF5Qyx1QkFBdUIsNkNBQTZDLFdBQVcsNkNBQTZDLGVBQWUsZ0NBQWdDLGlDQUFpQyxLQUFLLGtCQUFrQixpRUFBaUUsR0FBRyw4QkFBOEIsb0JBQW9CLHFDQUFxQyw0Q0FBNEMsd0NBQXdDLDBDQUEwQztBQUMxL0IsS0FBc0MsQ0FBQyxzQkFBaUIsQ0FBQyxTQUFJLENBQUMsVUFBVSx5QkFBeUIsOENBQThDLHlDQUF5QyxFQUFFLHVDQUF1Qyx1QkFBdUIsS0FBSywrQ0FBK0MsWUFBWSw0SEFBNEgsMkJBQTJCLGNBQWMsbUNBQW1DO0FBQ2hnQiw0QkFBNEIsY0FBYyxxQ0FBcUMsb0VBQW9FLG1CQUFtQiwyQ0FBMkMsNkJBQTZCLCtDQUErQyxHQUFHLHFEQUFxRCxxREFBcUQsWUFBWSxVQUFVO0FBQ2hhLDhDQUE4QyxpREFBaUQsS0FBSywyQ0FBMkMsa0NBQWtDLHNCQUFzQixzQ0FBc0Msc0JBQXNCLCtDQUErQyxLQUFLLDhCQUE4Qix1Q0FBdUMsZ0JBQWdCLHNCQUFzQiw4QkFBOEIsVUFBVSxtQ0FBbUMsS0FBSyxnQ0FBZ0MseUNBQXlDLG1EQUFtRCw4RUFBOEU7QUFDNXJCLDhDQUE4Qyw4QkFBOEIsS0FBSyx3QkFBd0IscUNBQXFDLGtEQUFrRCxtQkFBbUIsdUJBQXVCLCtCQUErQixVQUFVLFdBQVcsV0FBVyxzQkFBc0Isb0NBQW9DLHlEQUF5RCw2REFBNkQsNkRBQTZELEtBQUssa0NBQWtDLDJDQUEyQyxrQkFBa0IsNkJBQTZCLFlBQVksb0NBQW9DLFdBQVcscUZBQXFGLFFBQVEsb0JBQW9CLEtBQUssYUFBYSxzQ0FBc0Msb0JBQW9CO0FBQy80QjtBQUNBLDZEQUE2RCw2QkFBNkIsY0FBYywrQ0FBK0MsZ0NBQWdDLG9CQUFvQiwrREFBK0QsUUFBUSxZQUFZLHlCQUF5QixLQUFLLG9DQUFvQyw2Q0FBNkMsaUNBQWlDLHVEQUF1RCxZQUFZLHlCQUF5QixLQUFLLG9DQUFvQyw2Q0FBNkMsc0NBQXNDLDZCQUE2Qiw4QkFBOEI7QUFDanNCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtjb25zdCBpc09sZElFPWZ1bmN0aW9uIGlzT2xkSUUoKXtsZXQgbWVtbztyZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKXtpZih0eXBlb2YgbWVtbz09PSd1bmRlZmluZWQnKXsvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbm1lbW89Qm9vbGVhbih3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYik7fXJldHVybiBtZW1vO307fSgpO2NvbnN0IGdldFRhcmdldD1mdW5jdGlvbiBnZXRUYXJnZXQoKXtjb25zdCBtZW1vPXt9O3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpe2lmKHR5cGVvZiBtZW1vW3RhcmdldF09PT0ndW5kZWZpbmVkJyl7bGV0IHN0eWxlVGFyZ2V0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuaWYod2luZG93LkhUTUxJRnJhbWVFbGVtZW50JiZzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl7dHJ5ey8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4vLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuc3R5bGVUYXJnZXQ9c3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7fWNhdGNoKGUpey8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5zdHlsZVRhcmdldD1udWxsO319bWVtb1t0YXJnZXRdPXN0eWxlVGFyZ2V0O31yZXR1cm4gbWVtb1t0YXJnZXRdO307fSgpO2NvbnN0IHN0eWxlc0luRG9tPVtdO2Z1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpe2xldCByZXN1bHQ9LTE7Zm9yKGxldCBpPTA7aTxzdHlsZXNJbkRvbS5sZW5ndGg7aSsrKXtpZihzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyPT09aWRlbnRpZmllcil7cmVzdWx0PWk7YnJlYWs7fX1yZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCxvcHRpb25zKXtjb25zdCBpZENvdW50TWFwPXt9O2NvbnN0IGlkZW50aWZpZXJzPVtdO2ZvcihsZXQgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXtjb25zdCBpdGVtPWxpc3RbaV07Y29uc3QgaWQ9b3B0aW9ucy5iYXNlP2l0ZW1bMF0rb3B0aW9ucy5iYXNlOml0ZW1bMF07Y29uc3QgY291bnQ9aWRDb3VudE1hcFtpZF18fDA7Y29uc3QgaWRlbnRpZmllcj1pZCsnICcrY291bnQudG9TdHJpbmcoKTtpZENvdW50TWFwW2lkXT1jb3VudCsxO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2NvbnN0IG9iaj17Y3NzOml0ZW1bMV0sbWVkaWE6aXRlbVsyXSxzb3VyY2VNYXA6aXRlbVszXX07aWYoaW5kZXghPT0tMSl7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO31lbHNle3N0eWxlc0luRG9tLnB1c2goe2lkZW50aWZpZXI6aWRlbnRpZmllcix1cGRhdGVyOmFkZFN0eWxlKG9iaixvcHRpb25zKSxyZWZlcmVuY2VzOjF9KTt9aWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTt9cmV0dXJuIGlkZW50aWZpZXJzO31mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyl7Y29uc3Qgc3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjb25zdCBhdHRyaWJ1dGVzPW9wdGlvbnMuYXR0cmlidXRlc3x8e307aWYodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2U9PT0ndW5kZWZpbmVkJyl7Y29uc3Qgbm9uY2U9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG50eXBlb2YgX193ZWJwYWNrX25vbmNlX18hPT0ndW5kZWZpbmVkJz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsO2lmKG5vbmNlKXthdHRyaWJ1dGVzLm5vbmNlPW5vbmNlO319T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe3N0eWxlLnNldEF0dHJpYnV0ZShrZXksYXR0cmlidXRlc1trZXldKTt9KTtpZih0eXBlb2Ygb3B0aW9ucy5pbnNlcnQ9PT0nZnVuY3Rpb24nKXtvcHRpb25zLmluc2VydChzdHlsZSk7fWVsc2V7Y29uc3QgdGFyZ2V0PWdldFRhcmdldChvcHRpb25zLmluc2VydHx8J2hlYWQnKTtpZighdGFyZ2V0KXt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO310YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO31yZXR1cm4gc3R5bGU7fWZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSl7Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5pZihzdHlsZS5wYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuIGZhbHNlO31zdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTt9LyogaXN0YW5idWwgaWdub3JlIG5leHQgICovY29uc3QgcmVwbGFjZVRleHQ9ZnVuY3Rpb24gcmVwbGFjZVRleHQoKXtjb25zdCB0ZXh0U3RvcmU9W107cmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgscmVwbGFjZW1lbnQpe3RleHRTdG9yZVtpbmRleF09cmVwbGFjZW1lbnQ7cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7fTt9KCk7ZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSxpbmRleCxyZW1vdmUsb2JqKXtjb25zdCBjc3M9cmVtb3ZlPycnOm9iai5tZWRpYT8nQG1lZGlhICcrb2JqLm1lZGlhKycgeycrb2JqLmNzcysnfSc6b2JqLmNzczsvLyBGb3Igb2xkIElFXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovaWYoc3R5bGUuc3R5bGVTaGVldCl7c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0PXJlcGxhY2VUZXh0KGluZGV4LGNzcyk7fWVsc2V7Y29uc3QgY3NzTm9kZT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO2NvbnN0IGNoaWxkTm9kZXM9c3R5bGUuY2hpbGROb2RlcztpZihjaGlsZE5vZGVzW2luZGV4XSl7c3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO31pZihjaGlsZE5vZGVzLmxlbmd0aCl7c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsY2hpbGROb2Rlc1tpbmRleF0pO31lbHNle3N0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO319fWZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsb3B0aW9ucyxvYmope2xldCBjc3M9b2JqLmNzcztjb25zdCBtZWRpYT1vYmoubWVkaWE7Y29uc3Qgc291cmNlTWFwPW9iai5zb3VyY2VNYXA7aWYobWVkaWEpe3N0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLG1lZGlhKTt9ZWxzZXtzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7fWlmKHNvdXJjZU1hcCYmdHlwZW9mIGJ0b2EhPT0ndW5kZWZpbmVkJyl7Y3NzKz0nXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkrJyAqLyc7fS8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9Y3NzO31lbHNle3doaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe3N0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO31zdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTt9fWxldCBzaW5nbGV0b249bnVsbDtsZXQgc2luZ2xldG9uQ291bnRlcj0wO2Z1bmN0aW9uIGFkZFN0eWxlKG9iaixvcHRpb25zKXtsZXQgc3R5bGU7bGV0IHVwZGF0ZTtsZXQgcmVtb3ZlO2lmKG9wdGlvbnMuc2luZ2xldG9uKXtjb25zdCBzdHlsZUluZGV4PXNpbmdsZXRvbkNvdW50ZXIrKztzdHlsZT1zaW5nbGV0b258fChzaW5nbGV0b249aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTt1cGRhdGU9YXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsc3R5bGUsc3R5bGVJbmRleCxmYWxzZSk7cmVtb3ZlPWFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLHN0eWxlLHN0eWxlSW5kZXgsdHJ1ZSk7fWVsc2V7c3R5bGU9aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO3VwZGF0ZT1hcHBseVRvVGFnLmJpbmQobnVsbCxzdHlsZSxvcHRpb25zKTtyZW1vdmU9ZnVuY3Rpb24oKXtyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO307fXVwZGF0ZShvYmopO3JldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmope2lmKG5ld09iail7aWYobmV3T2JqLmNzcz09PW9iai5jc3MmJm5ld09iai5tZWRpYT09PW9iai5tZWRpYSYmbmV3T2JqLnNvdXJjZU1hcD09PW9iai5zb3VyY2VNYXApe3JldHVybjt9dXBkYXRlKG9iaj1uZXdPYmopO31lbHNle3JlbW92ZSgpO319O31tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihsaXN0LG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5pZighb3B0aW9ucy5zaW5nbGV0b24mJnR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiE9PSdib29sZWFuJyl7b3B0aW9ucy5zaW5nbGV0b249aXNPbGRJRSgpO31saXN0PWxpc3R8fFtdO2xldCBsYXN0SWRlbnRpZmllcnM9bW9kdWxlc1RvRG9tKGxpc3Qsb3B0aW9ucyk7cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KXtuZXdMaXN0PW5ld0xpc3R8fFtdO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSE9PSdbb2JqZWN0IEFycmF5XScpe3JldHVybjt9Zm9yKGxldCBpPTA7aTxsYXN0SWRlbnRpZmllcnMubGVuZ3RoO2krKyl7Y29uc3QgaWRlbnRpZmllcj1sYXN0SWRlbnRpZmllcnNbaV07Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTt9Y29uc3QgbmV3TGFzdElkZW50aWZpZXJzPW1vZHVsZXNUb0RvbShuZXdMaXN0LG9wdGlvbnMpO2ZvcihsZXQgaT0wO2k8bGFzdElkZW50aWZpZXJzLmxlbmd0aDtpKyspe2NvbnN0IGlkZW50aWZpZXI9bGFzdElkZW50aWZpZXJzW2ldO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2lmKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzPT09MCl7c3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsMSk7fX1sYXN0SWRlbnRpZmllcnM9bmV3TGFzdElkZW50aWZpZXJzO307fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************!*\
  !*** (webpack)/css-loader/api.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){\"use strict\";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return\"@media \".concat(t[2],\" {\").concat(r,\"}\")}return r}).join(\"\")};t.i=function(n,r,o){if(typeof n===\"string\"){n=[[null,n,\"\"]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]=\"\".concat(r,\" and \").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||\"\";var o=n[3];if(!o){return r}if(t&&typeof btoa===\"function\"){var e=toComment(o);var a=o.sources.map(function(n){return\"/*# sourceURL=\".concat(o.sourceRoot||\"\").concat(n,\" */\")});return[r].concat(a).concat([e]).join(\"\\n\")}return[r].join(\"\\n\")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r=\"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(t);return\"/*# \".concat(r,\" */\")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+\"/\";return __nccwpck_require__(762)}();\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9jc3MtbG9hZGVyL2FwaS5qcz84ZmI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJFQUEwQixhQUFhLE9BQU8sZ0JBQWdCLHNCQUFzQixTQUFTLCtCQUErQiw0QkFBNEIsa0NBQWtDLFNBQVMsK0JBQStCLGNBQWMsR0FBRyxTQUFTLFlBQVksb0JBQW9CLHdCQUF3QixnQkFBZ0IsU0FBUyxNQUFNLFlBQVksY0FBYyxLQUFLLGlCQUFpQixZQUFZLFlBQVksWUFBWSxXQUFXLEtBQUssc0JBQXNCLGVBQWUsU0FBUyxNQUFNLFVBQVUsT0FBTyxLQUFLLHdDQUF3QyxZQUFZLFVBQVUscUNBQXFDLGVBQWUsV0FBVyxPQUFPLFNBQVMsZ0NBQWdDLG1CQUFtQixnQ0FBZ0MsZ0VBQWdFLEVBQUUsMkNBQTJDLHFCQUFxQixzQkFBc0IsNERBQTRELDhDQUE4QyxjQUFjLG1CQUFtQixnQ0FBZ0MsU0FBUyxnQ0FBZ0MsU0FBUyxvQkFBb0IsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIscUNBQXFDLGdDQUFnQyxHIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ezc2MjpmdW5jdGlvbihuKXtuLmV4cG9ydHM9ZnVuY3Rpb24obil7dmFyIHQ9W107dC50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbih0KXt2YXIgcj1jc3NXaXRoTWFwcGluZ1RvU3RyaW5nKHQsbik7aWYodFsyXSl7cmV0dXJuXCJAbWVkaWEgXCIuY29uY2F0KHRbMl0sXCIge1wiKS5jb25jYXQocixcIn1cIil9cmV0dXJuIHJ9KS5qb2luKFwiXCIpfTt0Lmk9ZnVuY3Rpb24obixyLG8pe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7bj1bW251bGwsbixcIlwiXV19dmFyIGU9e307aWYobyl7Zm9yKHZhciBhPTA7YTx0aGlzLmxlbmd0aDthKyspe3ZhciBjPXRoaXNbYV1bMF07aWYoYyE9bnVsbCl7ZVtjXT10cnVlfX19Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciB1PVtdLmNvbmNhdChuW2ldKTtpZihvJiZlW3VbMF1dKXtjb250aW51ZX1pZihyKXtpZighdVsyXSl7dVsyXT1yfWVsc2V7dVsyXT1cIlwiLmNvbmNhdChyLFwiIGFuZCBcIikuY29uY2F0KHVbMl0pfX10LnB1c2godSl9fTtyZXR1cm4gdH07ZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhuLHQpe3ZhciByPW5bMV18fFwiXCI7dmFyIG89blszXTtpZighbyl7cmV0dXJuIHJ9aWYodCYmdHlwZW9mIGJ0b2E9PT1cImZ1bmN0aW9uXCIpe3ZhciBlPXRvQ29tbWVudChvKTt2YXIgYT1vLnNvdXJjZXMubWFwKGZ1bmN0aW9uKG4pe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoby5zb3VyY2VSb290fHxcIlwiKS5jb25jYXQobixcIiAqL1wiKX0pO3JldHVybltyXS5jb25jYXQoYSkuY29uY2F0KFtlXSkuam9pbihcIlxcblwiKX1yZXR1cm5bcl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiB0b0NvbW1lbnQobil7dmFyIHQ9YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobikpKSk7dmFyIHI9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQodCk7cmV0dXJuXCIvKiMgXCIuY29uY2F0KHIsXCIgKi9cIil9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXtpZih0W3JdKXtyZXR1cm4gdFtyXS5leHBvcnRzfXZhciBvPXRbcl09e2V4cG9ydHM6e319O3ZhciBlPXRydWU7dHJ5e25bcl0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7ZT1mYWxzZX1maW5hbGx5e2lmKGUpZGVsZXRlIHRbcl19cmV0dXJuIG8uZXhwb3J0c31fX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXyg3NjIpfSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/api.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Nav.module.scss":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/Nav.module.scss ***!
  \**********************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ \"./node_modules/next/dist/compiled/css-loader/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"@-webkit-keyframes Nav_changeColor__3TrF3 {\\n  0% {\\n    -webkit-filter: hue-rotate(0);\\n            filter: hue-rotate(0);\\n  }\\n  50% {\\n    -webkit-filter: hue-rotate(360deg);\\n            filter: hue-rotate(360deg);\\n  }\\n}\\n@-moz-keyframes Nav_changeColor__3TrF3 {\\n  0% {\\n    filter: hue-rotate(0);\\n  }\\n  50% {\\n    filter: hue-rotate(360deg);\\n  }\\n}\\n@keyframes Nav_changeColor__3TrF3 {\\n  0% {\\n    -webkit-filter: hue-rotate(0);\\n            filter: hue-rotate(0);\\n  }\\n  50% {\\n    -webkit-filter: hue-rotate(360deg);\\n            filter: hue-rotate(360deg);\\n  }\\n}\\n.Nav_nav__3RhQs {\\n  display: -moz-box;\\n  display: flex;\\n  -moz-box-pack: justify;\\n       justify-content: space-between;\\n}\\n.Nav_nav__3RhQs > a {\\n  position: relative;\\n  padding: 20px 0;\\n  font-size: 2rem;\\n  text-decoration: none;\\n  background-repeat: no-repeat;\\n}\\n.Nav_nav__3RhQs > a::after {\\n  position: absolute;\\n  bottom: 13px;\\n  left: 0;\\n  width: 0;\\n  height: 3px;\\n  content: \\\" \\\";\\n  -webkit-transition: width 0.3s ease-in-out, all 0.3s ease-in-out;\\n  -moz-transition: width 0.3s ease-in-out, all 0.3s ease-in-out;\\n  transition: width 0.3s ease-in-out, all 0.3s ease-in-out;\\n  text-decoration: none;\\n}\\n.Nav_nav__3RhQs > a.Nav_active__4n2x0 {\\n  color: #fff;\\n}\\n.Nav_nav__3RhQs > a.Nav_active__4n2x0::after {\\n  width: 100%;\\n  background: #fff;\\n}\\n.Nav_nav__3RhQs > a:hover::after {\\n  width: 100%;\\n  background: #fff;\\n}\\n@media (max-width: 800px) {\\n  .Nav_nav__3RhQs > a {\\n    font-size: 1.3rem;\\n  }\\n}\\n@media (max-width: 500px) {\\n  .Nav_nav__3RhQs > a {\\n    padding: 20px 0;\\n  }\\n}\\n@media (max-width: 400px) {\\n  .Nav_nav__3RhQs > a {\\n    font-size: 1.1rem;\\n  }\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://../vars.scss\",\"webpack://Nav.module.scss\"],\"names\":[],\"mappings\":\"AAOA;EACE;IACE,6BAAA;YAAA,qBAAA;ECNF;EDQA;IACE,kCAAA;YAAA,0BAAA;ECNF;AACF;ADAA;EACE;IACE,qBAAA;ECNF;EDQA;IACE,0BAAA;ECNF;AACF;ADAA;EACE;IACE,6BAAA;YAAA,qBAAA;ECNF;EDQA;IACE,kCAAA;YAAA,0BAAA;ECNF;AACF;AALA;EACE,iBAAA;EAAA,aAAA;EACA,sBAAA;OAAA,8BAAA;AAOF;AALE;EACE,kBAAA;EACA,eAAA;EACA,eAAA;EACA,qBAAA;EACA,4BAAA;AAOJ;AALI;EACE,kBAAA;EACA,YAAA;EACA,OAAA;EACA,QAAA;EACA,WAAA;EACA,YAAA;EACA,gEAAA;EAAA,6DAAA;EAAA,wDAAA;EACA,qBAAA;AAON;AAJI;EACE,WAAA;AAMN;AAJM;EACE,WAAA;EACA,gBAAA;AAMR;AADM;EACE,WAAA;EACA,gBAAA;AAGR;AACI;EAlCF;IAmCI,iBAAA;EAEJ;AACF;AAAI;EAtCF;IAuCI,eAAA;EAGJ;AACF;AADI;EA1CF;IA2CI,iBAAA;EAIJ;AACF\",\"sourcesContent\":[\"$main-red: #ce5e13;\\n$main-yellow: #f7db6c;\\n$main-purple: #a767e5;\\n$main-blue: #3182c4;\\n$main-green: #44ce7b;\\n$color-animation-duration: 60s;\\n\\n@keyframes changeColor {\\n  0% {\\n    filter: hue-rotate(0);\\n  }\\n  50% {\\n    filter: hue-rotate(360deg);\\n  }\\n}\\n\",\"@import './vars';\\n\\n.nav {\\n  display: flex;\\n  justify-content: space-between;\\n\\n  > a {\\n    position: relative;\\n    padding: 20px 0;\\n    font-size: 2rem;\\n    text-decoration: none;\\n    background-repeat: no-repeat;\\n\\n    &::after {\\n      position: absolute;\\n      bottom: 13px;\\n      left: 0;\\n      width: 0;\\n      height: 3px;\\n      content: ' ';\\n      transition: width 0.3s ease-in-out, all 0.3s ease-in-out;\\n      text-decoration: none;\\n    }\\n\\n    &.active {\\n      color: #fff;\\n\\n      &::after {\\n        width: 100%;\\n        background: #fff;\\n      }\\n    }\\n\\n    &:hover {\\n      &::after {\\n        width: 100%;\\n        background: #fff;\\n      }\\n    }\\n\\n    @media (max-width: 800px) {\\n      font-size: 1.3rem;\\n    }\\n\\n    @media (max-width: 500px) {\\n      padding: 20px 0;\\n    }\\n\\n    @media (max-width: 400px) {\\n      font-size: 1.1rem;\\n    }\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"nav\": \"Nav_nav__3RhQs\",\n\t\"active\": \"Nav_active__4n2x0\",\n\t\"changeColor\": \"Nav_changeColor__3TrF3\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXYubW9kdWxlLnNjc3M/OTU2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGlIQUFzRDtBQUNoRztBQUNBO0FBQ0EsOEJBQThCLFFBQVMsOENBQThDLFFBQVEsb0NBQW9DLG9DQUFvQyxLQUFLLFNBQVMseUNBQXlDLHlDQUF5QyxLQUFLLEdBQUcsMENBQTBDLFFBQVEsNEJBQTRCLEtBQUssU0FBUyxpQ0FBaUMsS0FBSyxHQUFHLHFDQUFxQyxRQUFRLG9DQUFvQyxvQ0FBb0MsS0FBSyxTQUFTLHlDQUF5Qyx5Q0FBeUMsS0FBSyxHQUFHLG1CQUFtQixzQkFBc0Isa0JBQWtCLDJCQUEyQix3Q0FBd0MsR0FBRyx1QkFBdUIsdUJBQXVCLG9CQUFvQixvQkFBb0IsMEJBQTBCLGlDQUFpQyxHQUFHLDhCQUE4Qix1QkFBdUIsaUJBQWlCLFlBQVksYUFBYSxnQkFBZ0IsbUJBQW1CLHFFQUFxRSxrRUFBa0UsNkRBQTZELDBCQUEwQixHQUFHLHlDQUF5QyxnQkFBZ0IsR0FBRyxnREFBZ0QsZ0JBQWdCLHFCQUFxQixHQUFHLG9DQUFvQyxnQkFBZ0IscUJBQXFCLEdBQUcsNkJBQTZCLHlCQUF5Qix3QkFBd0IsS0FBSyxHQUFHLDZCQUE2Qix5QkFBeUIsc0JBQXNCLEtBQUssR0FBRyw2QkFBNkIseUJBQXlCLHdCQUF3QixLQUFLLEdBQUcsT0FBTyx5R0FBeUcsS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLFVBQVUsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxXQUFXLEtBQUssS0FBSyxNQUFNLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxXQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sWUFBWSxLQUFLLDRDQUE0Qyx3QkFBd0Isd0JBQXdCLHNCQUFzQix1QkFBdUIsaUNBQWlDLDRCQUE0QixRQUFRLDRCQUE0QixLQUFLLFNBQVMsaUNBQWlDLEtBQUssR0FBRyxzQkFBc0IsVUFBVSxrQkFBa0IsbUNBQW1DLFdBQVcseUJBQXlCLHNCQUFzQixzQkFBc0IsNEJBQTRCLG1DQUFtQyxrQkFBa0IsMkJBQTJCLHFCQUFxQixnQkFBZ0IsaUJBQWlCLG9CQUFvQixxQkFBcUIsaUVBQWlFLDhCQUE4QixPQUFPLGtCQUFrQixvQkFBb0Isb0JBQW9CLHNCQUFzQiwyQkFBMkIsU0FBUyxPQUFPLGlCQUFpQixrQkFBa0Isc0JBQXNCLDJCQUEyQixTQUFTLE9BQU8sbUNBQW1DLDBCQUEwQixPQUFPLG1DQUFtQyx3QkFBd0IsT0FBTyxtQ0FBbUMsMEJBQTBCLE9BQU8sS0FBSyxHQUFHLHFCQUFxQjtBQUM3a0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPyEuL2NvbXBvbmVudHMvTmF2Lm1vZHVsZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQC13ZWJraXQta2V5ZnJhbWVzIE5hdl9jaGFuZ2VDb2xvcl9fM1RyRjMge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gICAgICAgICAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5ALW1vei1rZXlmcmFtZXMgTmF2X2NoYW5nZUNvbG9yX18zVHJGMyB7XFxuICAwJSB7XFxuICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIE5hdl9jaGFuZ2VDb2xvcl9fM1RyRjMge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gICAgICAgICAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG4uTmF2X25hdl9fM1JoUXMge1xcbiAgZGlzcGxheTogLW1vei1ib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLW1vei1ib3gtcGFjazoganVzdGlmeTtcXG4gICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG4uTmF2X25hdl9fM1JoUXMgPiBhIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHBhZGRpbmc6IDIwcHggMDtcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbi5OYXZfbmF2X18zUmhRcyA+IGE6OmFmdGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMTNweDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogM3B4O1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiB3aWR0aCAwLjNzIGVhc2UtaW4tb3V0LCBhbGwgMC4zcyBlYXNlLWluLW91dDtcXG4gIC1tb3otdHJhbnNpdGlvbjogd2lkdGggMC4zcyBlYXNlLWluLW91dCwgYWxsIDAuM3MgZWFzZS1pbi1vdXQ7XFxuICB0cmFuc2l0aW9uOiB3aWR0aCAwLjNzIGVhc2UtaW4tb3V0LCBhbGwgMC4zcyBlYXNlLWluLW91dDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLk5hdl9uYXZfXzNSaFFzID4gYS5OYXZfYWN0aXZlX180bjJ4MCB7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuLk5hdl9uYXZfXzNSaFFzID4gYS5OYXZfYWN0aXZlX180bjJ4MDo6YWZ0ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbn1cXG4uTmF2X25hdl9fM1JoUXMgPiBhOmhvdmVyOjphZnRlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA4MDBweCkge1xcbiAgLk5hdl9uYXZfXzNSaFFzID4gYSB7XFxuICAgIGZvbnQtc2l6ZTogMS4zcmVtO1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNTAwcHgpIHtcXG4gIC5OYXZfbmF2X18zUmhRcyA+IGEge1xcbiAgICBwYWRkaW5nOiAyMHB4IDA7XFxuICB9XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA0MDBweCkge1xcbiAgLk5hdl9uYXZfXzNSaFFzID4gYSB7XFxuICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xcbiAgfVxcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi4vdmFycy5zY3NzXCIsXCJ3ZWJwYWNrOi8vTmF2Lm1vZHVsZS5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQU9BO0VBQ0U7SUFDRSw2QkFBQTtZQUFBLHFCQUFBO0VDTkY7RURRQTtJQUNFLGtDQUFBO1lBQUEsMEJBQUE7RUNORjtBQUNGO0FEQUE7RUFDRTtJQUNFLHFCQUFBO0VDTkY7RURRQTtJQUNFLDBCQUFBO0VDTkY7QUFDRjtBREFBO0VBQ0U7SUFDRSw2QkFBQTtZQUFBLHFCQUFBO0VDTkY7RURRQTtJQUNFLGtDQUFBO1lBQUEsMEJBQUE7RUNORjtBQUNGO0FBTEE7RUFDRSxpQkFBQTtFQUFBLGFBQUE7RUFDQSxzQkFBQTtPQUFBLDhCQUFBO0FBT0Y7QUFMRTtFQUNFLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSxxQkFBQTtFQUNBLDRCQUFBO0FBT0o7QUFMSTtFQUNFLGtCQUFBO0VBQ0EsWUFBQTtFQUNBLE9BQUE7RUFDQSxRQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxnRUFBQTtFQUFBLDZEQUFBO0VBQUEsd0RBQUE7RUFDQSxxQkFBQTtBQU9OO0FBSkk7RUFDRSxXQUFBO0FBTU47QUFKTTtFQUNFLFdBQUE7RUFDQSxnQkFBQTtBQU1SO0FBRE07RUFDRSxXQUFBO0VBQ0EsZ0JBQUE7QUFHUjtBQUNJO0VBbENGO0lBbUNJLGlCQUFBO0VBRUo7QUFDRjtBQUFJO0VBdENGO0lBdUNJLGVBQUE7RUFHSjtBQUNGO0FBREk7RUExQ0Y7SUEyQ0ksaUJBQUE7RUFJSjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiRtYWluLXJlZDogI2NlNWUxMztcXG4kbWFpbi15ZWxsb3c6ICNmN2RiNmM7XFxuJG1haW4tcHVycGxlOiAjYTc2N2U1O1xcbiRtYWluLWJsdWU6ICMzMTgyYzQ7XFxuJG1haW4tZ3JlZW46ICM0NGNlN2I7XFxuJGNvbG9yLWFuaW1hdGlvbi1kdXJhdGlvbjogNjBzO1xcblxcbkBrZXlmcmFtZXMgY2hhbmdlQ29sb3Ige1xcbiAgMCUge1xcbiAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuXCIsXCJAaW1wb3J0ICcuL3ZhcnMnO1xcblxcbi5uYXYge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG5cXG4gID4gYSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgcGFkZGluZzogMjBweCAwO1xcbiAgICBmb250LXNpemU6IDJyZW07XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG5cXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBib3R0b206IDEzcHg7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICB3aWR0aDogMDtcXG4gICAgICBoZWlnaHQ6IDNweDtcXG4gICAgICBjb250ZW50OiAnICc7XFxuICAgICAgdHJhbnNpdGlvbjogd2lkdGggMC4zcyBlYXNlLWluLW91dCwgYWxsIDAuM3MgZWFzZS1pbi1vdXQ7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICB9XFxuXFxuICAgICYuYWN0aXZlIHtcXG4gICAgICBjb2xvcjogI2ZmZjtcXG5cXG4gICAgICAmOjphZnRlciB7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgICY6aG92ZXIge1xcbiAgICAgICY6OmFmdGVyIHtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZDogI2ZmZjtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSB7XFxuICAgICAgZm9udC1zaXplOiAxLjNyZW07XFxuICAgIH1cXG5cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDUwMHB4KSB7XFxuICAgICAgcGFkZGluZzogMjBweCAwO1xcbiAgICB9XFxuXFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA0MDBweCkge1xcbiAgICAgIGZvbnQtc2l6ZTogMS4xcmVtO1xcbiAgICB9XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcIm5hdlwiOiBcIk5hdl9uYXZfXzNSaFFzXCIsXG5cdFwiYWN0aXZlXCI6IFwiTmF2X2FjdGl2ZV9fNG4yeDBcIixcblx0XCJjaGFuZ2VDb2xvclwiOiBcIk5hdl9jaGFuZ2VDb2xvcl9fM1RyRjNcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/Nav.module.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/container.module.scss":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/container.module.scss ***!
  \****************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ \"./node_modules/next/dist/compiled/css-loader/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"@-webkit-keyframes container_changeColor__1imQv {\\n  0% {\\n    -webkit-filter: hue-rotate(0);\\n            filter: hue-rotate(0);\\n  }\\n  50% {\\n    -webkit-filter: hue-rotate(360deg);\\n            filter: hue-rotate(360deg);\\n  }\\n}\\n@-moz-keyframes container_changeColor__1imQv {\\n  0% {\\n    filter: hue-rotate(0);\\n  }\\n  50% {\\n    filter: hue-rotate(360deg);\\n  }\\n}\\n@keyframes container_changeColor__1imQv {\\n  0% {\\n    -webkit-filter: hue-rotate(0);\\n            filter: hue-rotate(0);\\n  }\\n  50% {\\n    -webkit-filter: hue-rotate(360deg);\\n            filter: hue-rotate(360deg);\\n  }\\n}\\n.container_outer__2cfYh {\\n  min-height: -webkit-calc( 100vh - 67px );\\n  min-height: -moz-calc( 100vh - 67px );\\n  min-height: calc( 100vh - 67px );\\n}\\n.container_outer__2cfYh::before {\\n  width: 100%;\\n  height: 10px;\\n  display: block;\\n  content: \\\"\\\";\\n  background: -webkit-gradient(linear, left top, right top, from(#ce5e13), color-stop(#f7db6c), color-stop(#a767e5), color-stop(#3182c4), to(#44ce7b));\\n  background: -webkit-linear-gradient(left, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  background: -moz-linear-gradient(left, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  background: linear-gradient(90deg, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  -webkit-animation: container_changeColor__1imQv 60s infinite;\\n     -moz-animation: container_changeColor__1imQv 60s infinite;\\n          animation: container_changeColor__1imQv 60s infinite;\\n}\\n.container_outer__2cfYh::after {\\n  width: 100%;\\n  height: 10px;\\n  display: block;\\n  content: \\\"\\\";\\n  background: -webkit-gradient(linear, left top, right top, from(#ce5e13), color-stop(#f7db6c), color-stop(#a767e5), color-stop(#3182c4), to(#44ce7b));\\n  background: -webkit-linear-gradient(left, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  background: -moz-linear-gradient(left, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  background: linear-gradient(90deg, #ce5e13, #f7db6c, #a767e5, #3182c4, #44ce7b);\\n  -webkit-animation: container_changeColor__1imQv 60s infinite;\\n     -moz-animation: container_changeColor__1imQv 60s infinite;\\n          animation: container_changeColor__1imQv 60s infinite;\\n}\\n\\n.container_container__c-75Z {\\n  max-width: 1000px;\\n  min-height: -webkit-calc( 100vh - 67px );\\n  min-height: -moz-calc( 100vh - 67px );\\n  min-height: calc( 100vh - 67px );\\n  margin: 0 auto;\\n}\\n@media (max-width: 1100px) {\\n  .container_container__c-75Z {\\n    padding: 20px;\\n  }\\n}\\n@media (max-width: 600px) {\\n  .container_container__c-75Z {\\n    padding: 0 10px;\\n  }\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://../vars.scss\",\"webpack://container.module.scss\"],\"names\":[],\"mappings\":\"AAOA;EACE;IACE,6BAAA;YAAA,qBAAA;ECNF;EDQA;IACE,kCAAA;YAAA,0BAAA;ECNF;AACF;ADAA;EACE;IACE,qBAAA;ECNF;EDQA;IACE,0BAAA;ECNF;AACF;ADAA;EACE;IACE,6BAAA;YAAA,qBAAA;ECNF;EDQA;IACE,kCAAA;YAAA,0BAAA;ECNF;AACF;AALA;EACE,wCAAA;EAAA,qCAAA;EAAA,gCAAA;AAOF;AAHE;EACE,WAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,oJAAA;EAAA,sFAAA;EAAA,mFAAA;EAAA,+EAAA;EAQA,4DAAA;KAAA,yDAAA;UAAA,oDAAA;AAFJ;AAKE;EACE,WAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,oJAAA;EAAA,sFAAA;EAAA,mFAAA;EAAA,+EAAA;EAQA,4DAAA;KAAA,yDAAA;UAAA,oDAAA;AAVJ;;AAcA;EACE,iBAAA;EACA,wCAAA;EAAA,qCAAA;EAAA,gCAAA;EAGA,cAAA;AAbF;AAeE;EAPF;IAQI,aAAA;EAZF;AACF;AAcE;EAXF;IAYI,eAAA;EAXF;AACF\",\"sourcesContent\":[\"$main-red: #ce5e13;\\n$main-yellow: #f7db6c;\\n$main-purple: #a767e5;\\n$main-blue: #3182c4;\\n$main-green: #44ce7b;\\n$color-animation-duration: 60s;\\n\\n@keyframes changeColor {\\n  0% {\\n    filter: hue-rotate(0);\\n  }\\n  50% {\\n    filter: hue-rotate(360deg);\\n  }\\n}\\n\",\"@import './vars';\\n\\n.outer {\\n  min-height: calc(\\n    100vh - 67px\\n  ); // 47px (footer height) + 20px (::before and ::after height )= 67px\\n\\n  &::before {\\n    width: 100%;\\n    height: 10px;\\n    display: block;\\n    content: '';\\n    background: linear-gradient(\\n      90deg,\\n      $main-red,\\n      $main-yellow,\\n      $main-purple,\\n      $main-blue,\\n      $main-green\\n    );\\n    animation: changeColor $color-animation-duration infinite;\\n  }\\n\\n  &::after {\\n    width: 100%;\\n    height: 10px;\\n    display: block;\\n    content: '';\\n    background: linear-gradient(\\n      90deg,\\n      $main-red,\\n      $main-yellow,\\n      $main-purple,\\n      $main-blue,\\n      $main-green\\n    );\\n    animation: changeColor $color-animation-duration infinite;\\n  }\\n}\\n\\n.container {\\n  max-width: 1000px;\\n  min-height: calc(\\n    100vh - 67px\\n  ); // 47px (footer height) + 20px (::before and ::after height )= 67px\\n  margin: 0 auto;\\n\\n  @media (max-width: 1100px) {\\n    padding: 20px;\\n  }\\n\\n  @media (max-width: 600px) {\\n    padding: 0 10px;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"outer\": \"container_outer__2cfYh\",\n\t\"changeColor\": \"container_changeColor__1imQv\",\n\t\"container\": \"container_container__c-75Z\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb250YWluZXIubW9kdWxlLnNjc3M/ODE0YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGlIQUFzRDtBQUNoRztBQUNBO0FBQ0EsOEJBQThCLFFBQVMsb0RBQW9ELFFBQVEsb0NBQW9DLG9DQUFvQyxLQUFLLFNBQVMseUNBQXlDLHlDQUF5QyxLQUFLLEdBQUcsZ0RBQWdELFFBQVEsNEJBQTRCLEtBQUssU0FBUyxpQ0FBaUMsS0FBSyxHQUFHLDJDQUEyQyxRQUFRLG9DQUFvQyxvQ0FBb0MsS0FBSyxTQUFTLHlDQUF5Qyx5Q0FBeUMsS0FBSyxHQUFHLDJCQUEyQiw2Q0FBNkMsMENBQTBDLHFDQUFxQyxHQUFHLG1DQUFtQyxnQkFBZ0IsaUJBQWlCLG1CQUFtQixrQkFBa0IseUpBQXlKLDJGQUEyRix3RkFBd0Ysb0ZBQW9GLGlFQUFpRSxpRUFBaUUsaUVBQWlFLEdBQUcsa0NBQWtDLGdCQUFnQixpQkFBaUIsbUJBQW1CLGtCQUFrQix5SkFBeUosMkZBQTJGLHdGQUF3RixvRkFBb0YsaUVBQWlFLGlFQUFpRSxpRUFBaUUsR0FBRyxpQ0FBaUMsc0JBQXNCLDZDQUE2QywwQ0FBMEMscUNBQXFDLG1CQUFtQixHQUFHLDhCQUE4QixpQ0FBaUMsb0JBQW9CLEtBQUssR0FBRyw2QkFBNkIsaUNBQWlDLHNCQUFzQixLQUFLLEdBQUcsT0FBTywrR0FBK0csS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxLQUFLLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxLQUFLLEtBQUssVUFBVSxLQUFLLDRDQUE0Qyx3QkFBd0Isd0JBQXdCLHNCQUFzQix1QkFBdUIsaUNBQWlDLDRCQUE0QixRQUFRLDRCQUE0QixLQUFLLFNBQVMsaUNBQWlDLEtBQUssR0FBRyxzQkFBc0IsWUFBWSw2Q0FBNkMscUZBQXFGLGtCQUFrQixtQkFBbUIscUJBQXFCLGtCQUFrQiwwSkFBMEosZ0VBQWdFLEtBQUssZ0JBQWdCLGtCQUFrQixtQkFBbUIscUJBQXFCLGtCQUFrQiwwSkFBMEosZ0VBQWdFLEtBQUssR0FBRyxnQkFBZ0Isc0JBQXNCLDZDQUE2Qyx1RkFBdUYsa0NBQWtDLG9CQUFvQixLQUFLLGlDQUFpQyxzQkFBc0IsS0FBSyxHQUFHLHFCQUFxQjtBQUN6bko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPyEuL2NvbXBvbmVudHMvY29udGFpbmVyLm1vZHVsZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQC13ZWJraXQta2V5ZnJhbWVzIGNvbnRhaW5lcl9jaGFuZ2VDb2xvcl9fMWltUXYge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gICAgICAgICAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5ALW1vei1rZXlmcmFtZXMgY29udGFpbmVyX2NoYW5nZUNvbG9yX18xaW1RdiB7XFxuICAwJSB7XFxuICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIGNvbnRhaW5lcl9jaGFuZ2VDb2xvcl9fMWltUXYge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgwKTtcXG4gICAgICAgICAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICAtd2Via2l0LWZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIGZpbHRlcjogaHVlLXJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG4uY29udGFpbmVyX291dGVyX18yY2ZZaCB7XFxuICBtaW4taGVpZ2h0OiAtd2Via2l0LWNhbGMoIDEwMHZoIC0gNjdweCApO1xcbiAgbWluLWhlaWdodDogLW1vei1jYWxjKCAxMDB2aCAtIDY3cHggKTtcXG4gIG1pbi1oZWlnaHQ6IGNhbGMoIDEwMHZoIC0gNjdweCApO1xcbn1cXG4uY29udGFpbmVyX291dGVyX18yY2ZZaDo6YmVmb3JlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBmcm9tKCNjZTVlMTMpLCBjb2xvci1zdG9wKCNmN2RiNmMpLCBjb2xvci1zdG9wKCNhNzY3ZTUpLCBjb2xvci1zdG9wKCMzMTgyYzQpLCB0bygjNDRjZTdiKSk7XFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAjY2U1ZTEzLCAjZjdkYjZjLCAjYTc2N2U1LCAjMzE4MmM0LCAjNDRjZTdiKTtcXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KGxlZnQsICNjZTVlMTMsICNmN2RiNmMsICNhNzY3ZTUsICMzMTgyYzQsICM0NGNlN2IpO1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjY2U1ZTEzLCAjZjdkYjZjLCAjYTc2N2U1LCAjMzE4MmM0LCAjNDRjZTdiKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG4gICAgIC1tb3otYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG4gICAgICAgICAgYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG59XFxuLmNvbnRhaW5lcl9vdXRlcl9fMmNmWWg6OmFmdGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBmcm9tKCNjZTVlMTMpLCBjb2xvci1zdG9wKCNmN2RiNmMpLCBjb2xvci1zdG9wKCNhNzY3ZTUpLCBjb2xvci1zdG9wKCMzMTgyYzQpLCB0bygjNDRjZTdiKSk7XFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAjY2U1ZTEzLCAjZjdkYjZjLCAjYTc2N2U1LCAjMzE4MmM0LCAjNDRjZTdiKTtcXG4gIGJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KGxlZnQsICNjZTVlMTMsICNmN2RiNmMsICNhNzY3ZTUsICMzMTgyYzQsICM0NGNlN2IpO1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjY2U1ZTEzLCAjZjdkYjZjLCAjYTc2N2U1LCAjMzE4MmM0LCAjNDRjZTdiKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG4gICAgIC1tb3otYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG4gICAgICAgICAgYW5pbWF0aW9uOiBjb250YWluZXJfY2hhbmdlQ29sb3JfXzFpbVF2IDYwcyBpbmZpbml0ZTtcXG59XFxuXFxuLmNvbnRhaW5lcl9jb250YWluZXJfX2MtNzVaIHtcXG4gIG1heC13aWR0aDogMTAwMHB4O1xcbiAgbWluLWhlaWdodDogLXdlYmtpdC1jYWxjKCAxMDB2aCAtIDY3cHggKTtcXG4gIG1pbi1oZWlnaHQ6IC1tb3otY2FsYyggMTAwdmggLSA2N3B4ICk7XFxuICBtaW4taGVpZ2h0OiBjYWxjKCAxMDB2aCAtIDY3cHggKTtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogMTEwMHB4KSB7XFxuICAuY29udGFpbmVyX2NvbnRhaW5lcl9fYy03NVoge1xcbiAgICBwYWRkaW5nOiAyMHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXG4gIC5jb250YWluZXJfY29udGFpbmVyX19jLTc1WiB7XFxuICAgIHBhZGRpbmc6IDAgMTBweDtcXG4gIH1cXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4uL3ZhcnMuc2Nzc1wiLFwid2VicGFjazovL2NvbnRhaW5lci5tb2R1bGUuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFPQTtFQUNFO0lBQ0UsNkJBQUE7WUFBQSxxQkFBQTtFQ05GO0VEUUE7SUFDRSxrQ0FBQTtZQUFBLDBCQUFBO0VDTkY7QUFDRjtBREFBO0VBQ0U7SUFDRSxxQkFBQTtFQ05GO0VEUUE7SUFDRSwwQkFBQTtFQ05GO0FBQ0Y7QURBQTtFQUNFO0lBQ0UsNkJBQUE7WUFBQSxxQkFBQTtFQ05GO0VEUUE7SUFDRSxrQ0FBQTtZQUFBLDBCQUFBO0VDTkY7QUFDRjtBQUxBO0VBQ0Usd0NBQUE7RUFBQSxxQ0FBQTtFQUFBLGdDQUFBO0FBT0Y7QUFIRTtFQUNFLFdBQUE7RUFDQSxZQUFBO0VBQ0EsY0FBQTtFQUNBLFdBQUE7RUFDQSxvSkFBQTtFQUFBLHNGQUFBO0VBQUEsbUZBQUE7RUFBQSwrRUFBQTtFQVFBLDREQUFBO0tBQUEseURBQUE7VUFBQSxvREFBQTtBQUZKO0FBS0U7RUFDRSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGNBQUE7RUFDQSxXQUFBO0VBQ0Esb0pBQUE7RUFBQSxzRkFBQTtFQUFBLG1GQUFBO0VBQUEsK0VBQUE7RUFRQSw0REFBQTtLQUFBLHlEQUFBO1VBQUEsb0RBQUE7QUFWSjs7QUFjQTtFQUNFLGlCQUFBO0VBQ0Esd0NBQUE7RUFBQSxxQ0FBQTtFQUFBLGdDQUFBO0VBR0EsY0FBQTtBQWJGO0FBZUU7RUFQRjtJQVFJLGFBQUE7RUFaRjtBQUNGO0FBY0U7RUFYRjtJQVlJLGVBQUE7RUFYRjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiRtYWluLXJlZDogI2NlNWUxMztcXG4kbWFpbi15ZWxsb3c6ICNmN2RiNmM7XFxuJG1haW4tcHVycGxlOiAjYTc2N2U1O1xcbiRtYWluLWJsdWU6ICMzMTgyYzQ7XFxuJG1haW4tZ3JlZW46ICM0NGNlN2I7XFxuJGNvbG9yLWFuaW1hdGlvbi1kdXJhdGlvbjogNjBzO1xcblxcbkBrZXlmcmFtZXMgY2hhbmdlQ29sb3Ige1xcbiAgMCUge1xcbiAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICBmaWx0ZXI6IGh1ZS1yb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuXCIsXCJAaW1wb3J0ICcuL3ZhcnMnO1xcblxcbi5vdXRlciB7XFxuICBtaW4taGVpZ2h0OiBjYWxjKFxcbiAgICAxMDB2aCAtIDY3cHhcXG4gICk7IC8vIDQ3cHggKGZvb3RlciBoZWlnaHQpICsgMjBweCAoOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgaGVpZ2h0ICk9IDY3cHhcXG5cXG4gICY6OmJlZm9yZSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwcHg7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICAgIDkwZGVnLFxcbiAgICAgICRtYWluLXJlZCxcXG4gICAgICAkbWFpbi15ZWxsb3csXFxuICAgICAgJG1haW4tcHVycGxlLFxcbiAgICAgICRtYWluLWJsdWUsXFxuICAgICAgJG1haW4tZ3JlZW5cXG4gICAgKTtcXG4gICAgYW5pbWF0aW9uOiBjaGFuZ2VDb2xvciAkY29sb3ItYW5pbWF0aW9uLWR1cmF0aW9uIGluZmluaXRlO1xcbiAgfVxcblxcbiAgJjo6YWZ0ZXIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMHB4O1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgY29udGVudDogJyc7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgICA5MGRlZyxcXG4gICAgICAkbWFpbi1yZWQsXFxuICAgICAgJG1haW4teWVsbG93LFxcbiAgICAgICRtYWluLXB1cnBsZSxcXG4gICAgICAkbWFpbi1ibHVlLFxcbiAgICAgICRtYWluLWdyZWVuXFxuICAgICk7XFxuICAgIGFuaW1hdGlvbjogY2hhbmdlQ29sb3IgJGNvbG9yLWFuaW1hdGlvbi1kdXJhdGlvbiBpbmZpbml0ZTtcXG4gIH1cXG59XFxuXFxuLmNvbnRhaW5lciB7XFxuICBtYXgtd2lkdGg6IDEwMDBweDtcXG4gIG1pbi1oZWlnaHQ6IGNhbGMoXFxuICAgIDEwMHZoIC0gNjdweFxcbiAgKTsgLy8gNDdweCAoZm9vdGVyIGhlaWdodCkgKyAyMHB4ICg6OmJlZm9yZSBhbmQgOjphZnRlciBoZWlnaHQgKT0gNjdweFxcbiAgbWFyZ2luOiAwIGF1dG87XFxuXFxuICBAbWVkaWEgKG1heC13aWR0aDogMTEwMHB4KSB7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXG4gICAgcGFkZGluZzogMCAxMHB4O1xcbiAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJvdXRlclwiOiBcImNvbnRhaW5lcl9vdXRlcl9fMmNmWWhcIixcblx0XCJjaGFuZ2VDb2xvclwiOiBcImNvbnRhaW5lcl9jaGFuZ2VDb2xvcl9fMWltUXZcIixcblx0XCJjb250YWluZXJcIjogXCJjb250YWluZXJfY29udGFpbmVyX19jLTc1WlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/container.module.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/footer.module.scss":
/*!*************************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./components/footer.module.scss ***!
  \*************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ \"./node_modules/next/dist/compiled/css-loader/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \".footer_footer__3LSES > p {\\n  margin: 0;\\n  padding: 10px 0;\\n  font-size: 0.9rem;\\n  text-align: center;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://footer.module.scss\"],\"names\":[],\"mappings\":\"AACE;EACE,SAAA;EACA,eAAA;EACA,iBAAA;EACA,kBAAA;AAAJ\",\"sourcesContent\":[\".footer {\\n  > p {\\n    margin: 0;\\n    padding: 10px 0;\\n    font-size: 0.9rem;\\n    text-align: center;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"footer\": \"footer_footer__3LSES\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9mb290ZXIubW9kdWxlLnNjc3M/ZTA1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGlIQUFzRDtBQUNoRztBQUNBO0FBQ0EsOEJBQThCLFFBQVMsOEJBQThCLGNBQWMsb0JBQW9CLHNCQUFzQix1QkFBdUIsR0FBRyxPQUFPLG1GQUFtRixVQUFVLFVBQVUsV0FBVyxXQUFXLGtDQUFrQyxTQUFTLGdCQUFnQixzQkFBc0Isd0JBQXdCLHlCQUF5QixLQUFLLEdBQUcscUJBQXFCO0FBQzFiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPyEuL2NvbXBvbmVudHMvZm9vdGVyLm1vZHVsZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmZvb3Rlcl9mb290ZXJfXzNMU0VTID4gcCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBmb250LXNpemU6IDAuOXJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2Zvb3Rlci5tb2R1bGUuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFDRTtFQUNFLFNBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtBQUFKXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5mb290ZXIge1xcbiAgPiBwIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAxMHB4IDA7XFxuICAgIGZvbnQtc2l6ZTogMC45cmVtO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImZvb3RlclwiOiBcImZvb3Rlcl9mb290ZXJfXzNMU0VTXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./components/footer.module.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./pages/projects.module.scss":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-3-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-3-2!(webpack)/resolve-url-loader??ref--5-oneOf-3-3!(webpack)/sass-loader/cjs.js??ref--5-oneOf-3-4!./pages/projects.module.scss ***!
  \**********************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ \"./node_modules/next/dist/compiled/css-loader/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \".projects_project__3UJxW {\\n  min-height: 80vh;\\n  padding-top: 50px;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF {\\n  display: -moz-box;\\n  display: flex;\\n  flex-wrap: wrap;\\n  -moz-box-pack: start;\\n       justify-content: flex-start;\\n}\\n@media (max-width: 600px) {\\n  .projects_project__3UJxW > .projects_list__1sWTF {\\n    display: block;\\n  }\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div {\\n  width: 32%;\\n  margin: 0 0.5% 10px;\\n  text-decoration: none;\\n  background: #273146;\\n  padding: 15px;\\n  border-radius: 5px;\\n  -webkit-box-shadow: 0px 2px 2px #0b152b;\\n          box-shadow: 0px 2px 2px #0b152b;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div.projects_broken__3JZbp {\\n  opacity: 0.4 !important;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div:hover {\\n  background: #2e3c58;\\n}\\n@media (max-width: 900px) {\\n  .projects_project__3UJxW > .projects_list__1sWTF > div {\\n    width: 49%;\\n  }\\n}\\n@media (max-width: 600px) {\\n  .projects_project__3UJxW > .projects_list__1sWTF > div {\\n    width: 100%;\\n    margin: 0 0 10px;\\n  }\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_top__1_zqJ {\\n  display: -moz-box;\\n  display: flex;\\n  -moz-box-pack: justify;\\n       justify-content: space-between;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_top__1_zqJ > .projects_title__2cAy9 {\\n  margin-bottom: 5px;\\n  display: inline-block;\\n  font-size: 1.5rem;\\n  color: #fff;\\n  font-weight: bold;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_top__1_zqJ .projects_icon__2Cx3Q {\\n  margin-top: 5px;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_top__1_zqJ .projects_icon__2Cx3Q > svg {\\n  width: 13px;\\n  fill: #fff;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_desc__1rO7_ {\\n  margin-bottom: 5px;\\n  display: block;\\n  font-size: 0.9rem;\\n  font-style: italic;\\n  line-height: 1.4rem;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_built__1Q9_J {\\n  display: -moz-box;\\n  display: flex;\\n  -moz-box-pack: start;\\n       justify-content: flex-start;\\n  flex-wrap: wrap;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_built__1Q9_J > span {\\n  margin: 0 5px 5px 0;\\n  padding: 3px 7px;\\n  display: inline-block;\\n  font-size: 0.7rem;\\n  text-transform: uppercase;\\n  line-height: 1;\\n  background: #a2a2a2;\\n  border-radius: 3px;\\n  color: #000;\\n}\\n.projects_project__3UJxW > .projects_list__1sWTF > div > .projects_brokenAPI__J3AGN {\\n  padding: 3px 7px;\\n  display: inline-block;\\n  text-transform: uppercase;\\n  font-size: 10px;\\n  color: #ff0d0d;\\n  background: #000;\\n  border-radius: 3px;\\n  font-weight: 700;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://projects.module.scss\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAA;EACA,iBAAA;AACF;AACE;EACE,iBAAA;EAAA,aAAA;EACA,eAAA;EACA,oBAAA;OAAA,2BAAA;AACJ;AACI;EALF;IAMI,cAAA;EAEJ;AACF;AAAI;EACE,UAAA;EACA,mBAAA;EACA,qBAAA;EACA,mBAAA;EACA,aAAA;EACA,kBAAA;EACA,uCAAA;UAAA,+BAAA;AAEN;AAAM;EACE,uBAAA;AAER;AACM;EACE,mBAAA;AACR;AAEM;EAjBF;IAkBI,UAAA;EACN;AACF;AACM;EArBF;IAsBI,WAAA;IACA,gBAAA;EAEN;AACF;AAAM;EACE,iBAAA;EAAA,aAAA;EACA,sBAAA;OAAA,8BAAA;AAER;AAAQ;EACE,kBAAA;EACA,qBAAA;EACA,iBAAA;EACA,WAAA;EACA,iBAAA;AAEV;AACQ;EACE,eAAA;AACV;AACU;EACE,WAAA;EACA,UAAA;AACZ;AAIM;EACE,kBAAA;EACA,cAAA;EACA,iBAAA;EACA,kBAAA;EACA,mBAAA;AAFR;AAKM;EACE,iBAAA;EAAA,aAAA;EACA,oBAAA;OAAA,2BAAA;EACA,eAAA;AAHR;AAKQ;EACE,mBAAA;EACA,gBAAA;EACA,qBAAA;EACA,iBAAA;EACA,yBAAA;EACA,cAAA;EACA,mBAAA;EACA,kBAAA;EACA,WAAA;AAHV;AAOM;EACE,gBAAA;EACA,qBAAA;EACA,yBAAA;EACA,eAAA;EACA,cAAA;EACA,gBAAA;EACA,kBAAA;EACA,gBAAA;AALR\",\"sourcesContent\":[\".project {\\n  min-height: 80vh;\\n  padding-top: 50px;\\n\\n  > .list {\\n    display: flex;\\n    flex-wrap: wrap;\\n    justify-content: flex-start;\\n\\n    @media (max-width: 600px) {\\n      display: block;\\n    }\\n\\n    > div {\\n      width: 32%;\\n      margin: 0 0.5% 10px;\\n      text-decoration: none;\\n      background: #273146;\\n      padding: 15px;\\n      border-radius: 5px;\\n      box-shadow: 0px 2px 2px #0b152b;\\n\\n      &.broken {\\n        opacity: 0.4 !important;\\n      }\\n\\n      &:hover {\\n        background: #2e3c58;\\n      }\\n\\n      @media (max-width: 900px) {\\n        width: 49%;\\n      }\\n\\n      @media (max-width: 600px) {\\n        width: 100%;\\n        margin: 0 0 10px;\\n      }\\n\\n      > .top {\\n        display: flex;\\n        justify-content: space-between;\\n\\n        > .title {\\n          margin-bottom: 5px;\\n          display: inline-block;\\n          font-size: 1.5rem;\\n          color: #fff;\\n          font-weight: bold;\\n        }\\n\\n        .icon {\\n          margin-top: 5px;\\n\\n          > svg {\\n            width: 13px;\\n            fill: #fff;\\n          }\\n        }\\n      }\\n\\n      > .desc {\\n        margin-bottom: 5px;\\n        display: block;\\n        font-size: 0.9rem;\\n        font-style: italic;\\n        line-height: 1.4rem;\\n      }\\n\\n      > .built {\\n        display: flex;\\n        justify-content: flex-start;\\n        flex-wrap: wrap;\\n\\n        > span {\\n          margin: 0 5px 5px 0;\\n          padding: 3px 7px;\\n          display: inline-block;\\n          font-size: 0.7rem;\\n          text-transform: uppercase;\\n          line-height: 1;\\n          background: #a2a2a2;\\n          border-radius: 3px;\\n          color: #000;\\n        }\\n      }\\n\\n      > .brokenAPI {\\n        padding: 3px 7px;\\n        display: inline-block;\\n        text-transform: uppercase;\\n        font-size: 10px;\\n        color: #ff0d0d;\\n        background: #000;\\n        border-radius: 3px;\\n        font-weight: 700;\\n      }\\n    }\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"project\": \"projects_project__3UJxW\",\n\t\"list\": \"projects_list__1sWTF\",\n\t\"broken\": \"projects_broken__3JZbp\",\n\t\"top\": \"projects_top__1_zqJ\",\n\t\"title\": \"projects_title__2cAy9\",\n\t\"icon\": \"projects_icon__2Cx3Q\",\n\t\"desc\": \"projects_desc__1rO7_\",\n\t\"built\": \"projects_built__1Q9_J\",\n\t\"brokenAPI\": \"projects_brokenAPI__J3AGN\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvcHJvamVjdHMubW9kdWxlLnNjc3M/MmMxYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGlIQUFzRDtBQUNoRztBQUNBO0FBQ0EsOEJBQThCLFFBQVMsNkJBQTZCLHFCQUFxQixzQkFBc0IsR0FBRyxvREFBb0Qsc0JBQXNCLGtCQUFrQixvQkFBb0IseUJBQXlCLHFDQUFxQyxHQUFHLDZCQUE2QixzREFBc0QscUJBQXFCLEtBQUssR0FBRywwREFBMEQsZUFBZSx3QkFBd0IsMEJBQTBCLHdCQUF3QixrQkFBa0IsdUJBQXVCLDRDQUE0Qyw0Q0FBNEMsR0FBRyxpRkFBaUYsNEJBQTRCLEdBQUcsZ0VBQWdFLHdCQUF3QixHQUFHLDZCQUE2Qiw0REFBNEQsaUJBQWlCLEtBQUssR0FBRyw2QkFBNkIsNERBQTRELGtCQUFrQix1QkFBdUIsS0FBSyxHQUFHLGlGQUFpRixzQkFBc0Isa0JBQWtCLDJCQUEyQix3Q0FBd0MsR0FBRywwR0FBMEcsdUJBQXVCLDBCQUEwQixzQkFBc0IsZ0JBQWdCLHNCQUFzQixHQUFHLHVHQUF1RyxvQkFBb0IsR0FBRyw2R0FBNkcsZ0JBQWdCLGVBQWUsR0FBRyxrRkFBa0YsdUJBQXVCLG1CQUFtQixzQkFBc0IsdUJBQXVCLHdCQUF3QixHQUFHLG1GQUFtRixzQkFBc0Isa0JBQWtCLHlCQUF5QixxQ0FBcUMsb0JBQW9CLEdBQUcsMEZBQTBGLHdCQUF3QixxQkFBcUIsMEJBQTBCLHNCQUFzQiw4QkFBOEIsbUJBQW1CLHdCQUF3Qix1QkFBdUIsZ0JBQWdCLEdBQUcsdUZBQXVGLHFCQUFxQiwwQkFBMEIsOEJBQThCLG9CQUFvQixtQkFBbUIscUJBQXFCLHVCQUF1QixxQkFBcUIsR0FBRyxPQUFPLHFGQUFxRixXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxVQUFVLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxLQUFLLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxXQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLFdBQVcsVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxtQ0FBbUMscUJBQXFCLHNCQUFzQixlQUFlLG9CQUFvQixzQkFBc0Isa0NBQWtDLG1DQUFtQyx1QkFBdUIsT0FBTyxlQUFlLG1CQUFtQiw0QkFBNEIsOEJBQThCLDRCQUE0QixzQkFBc0IsMkJBQTJCLHdDQUF3QyxvQkFBb0Isa0NBQWtDLFNBQVMsbUJBQW1CLDhCQUE4QixTQUFTLHFDQUFxQyxxQkFBcUIsU0FBUyxxQ0FBcUMsc0JBQXNCLDJCQUEyQixTQUFTLGtCQUFrQix3QkFBd0IseUNBQXlDLHNCQUFzQiwrQkFBK0Isa0NBQWtDLDhCQUE4Qix3QkFBd0IsOEJBQThCLFdBQVcsbUJBQW1CLDRCQUE0QixxQkFBcUIsMEJBQTBCLHlCQUF5QixhQUFhLFdBQVcsU0FBUyxtQkFBbUIsNkJBQTZCLHlCQUF5Qiw0QkFBNEIsNkJBQTZCLDhCQUE4QixTQUFTLG9CQUFvQix3QkFBd0Isc0NBQXNDLDBCQUEwQixvQkFBb0IsZ0NBQWdDLDZCQUE2QixrQ0FBa0MsOEJBQThCLHNDQUFzQywyQkFBMkIsZ0NBQWdDLCtCQUErQix3QkFBd0IsV0FBVyxTQUFTLHdCQUF3QiwyQkFBMkIsZ0NBQWdDLG9DQUFvQywwQkFBMEIseUJBQXlCLDJCQUEyQiw2QkFBNkIsMkJBQTJCLFNBQVMsT0FBTyxLQUFLLEdBQUcscUJBQXFCO0FBQzVtTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/IS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/IS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/IS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/IS4vcGFnZXMvcHJvamVjdHMubW9kdWxlLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIucHJvamVjdHNfcHJvamVjdF9fM1VKeFcge1xcbiAgbWluLWhlaWdodDogODB2aDtcXG4gIHBhZGRpbmctdG9wOiA1MHB4O1xcbn1cXG4ucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYge1xcbiAgZGlzcGxheTogLW1vei1ib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgLW1vei1ib3gtcGFjazogc3RhcnQ7XFxuICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG59XFxuQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG59XFxuLnByb2plY3RzX3Byb2plY3RfXzNVSnhXID4gLnByb2plY3RzX2xpc3RfXzFzV1RGID4gZGl2IHtcXG4gIHdpZHRoOiAzMiU7XFxuICBtYXJnaW46IDAgMC41JSAxMHB4O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgYmFja2dyb3VuZDogIzI3MzE0NjtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDBweCAycHggMnB4ICMwYjE1MmI7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IDBweCAycHggMnB4ICMwYjE1MmI7XFxufVxcbi5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdi5wcm9qZWN0c19icm9rZW5fXzNKWmJwIHtcXG4gIG9wYWNpdHk6IDAuNCAhaW1wb3J0YW50O1xcbn1cXG4ucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYgPiBkaXY6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogIzJlM2M1ODtcXG59XFxuQG1lZGlhIChtYXgtd2lkdGg6IDkwMHB4KSB7XFxuICAucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYgPiBkaXYge1xcbiAgICB3aWR0aDogNDklO1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXG4gIC5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW46IDAgMCAxMHB4O1xcbiAgfVxcbn1cXG4ucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYgPiBkaXYgPiAucHJvamVjdHNfdG9wX18xX3pxSiB7XFxuICBkaXNwbGF5OiAtbW96LWJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtbW96LWJveC1wYWNrOiBqdXN0aWZ5O1xcbiAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdiA+IC5wcm9qZWN0c190b3BfXzFfenFKID4gLnByb2plY3RzX3RpdGxlX18yY0F5OSB7XFxuICBtYXJnaW4tYm90dG9tOiA1cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdiA+IC5wcm9qZWN0c190b3BfXzFfenFKIC5wcm9qZWN0c19pY29uX18yQ3gzUSB7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxufVxcbi5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdiA+IC5wcm9qZWN0c190b3BfXzFfenFKIC5wcm9qZWN0c19pY29uX18yQ3gzUSA+IHN2ZyB7XFxuICB3aWR0aDogMTNweDtcXG4gIGZpbGw6ICNmZmY7XFxufVxcbi5wcm9qZWN0c19wcm9qZWN0X18zVUp4VyA+IC5wcm9qZWN0c19saXN0X18xc1dURiA+IGRpdiA+IC5wcm9qZWN0c19kZXNjX18xck83XyB7XFxuICBtYXJnaW4tYm90dG9tOiA1cHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc2l6ZTogMC45cmVtO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgbGluZS1oZWlnaHQ6IDEuNHJlbTtcXG59XFxuLnByb2plY3RzX3Byb2plY3RfXzNVSnhXID4gLnByb2plY3RzX2xpc3RfXzFzV1RGID4gZGl2ID4gLnByb2plY3RzX2J1aWx0X18xUTlfSiB7XFxuICBkaXNwbGF5OiAtbW96LWJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtbW96LWJveC1wYWNrOiBzdGFydDtcXG4gICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4ucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYgPiBkaXYgPiAucHJvamVjdHNfYnVpbHRfXzFROV9KID4gc3BhbiB7XFxuICBtYXJnaW46IDAgNXB4IDVweCAwO1xcbiAgcGFkZGluZzogM3B4IDdweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtc2l6ZTogMC43cmVtO1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgYmFja2dyb3VuZDogI2EyYTJhMjtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGNvbG9yOiAjMDAwO1xcbn1cXG4ucHJvamVjdHNfcHJvamVjdF9fM1VKeFcgPiAucHJvamVjdHNfbGlzdF9fMXNXVEYgPiBkaXYgPiAucHJvamVjdHNfYnJva2VuQVBJX19KM0FHTiB7XFxuICBwYWRkaW5nOiAzcHggN3B4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiAjZmYwZDBkO1xcbiAgYmFja2dyb3VuZDogIzAwMDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9wcm9qZWN0cy5tb2R1bGUuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFBO0VBQ0EsaUJBQUE7QUFDRjtBQUNFO0VBQ0UsaUJBQUE7RUFBQSxhQUFBO0VBQ0EsZUFBQTtFQUNBLG9CQUFBO09BQUEsMkJBQUE7QUFDSjtBQUNJO0VBTEY7SUFNSSxjQUFBO0VBRUo7QUFDRjtBQUFJO0VBQ0UsVUFBQTtFQUNBLG1CQUFBO0VBQ0EscUJBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLHVDQUFBO1VBQUEsK0JBQUE7QUFFTjtBQUFNO0VBQ0UsdUJBQUE7QUFFUjtBQUNNO0VBQ0UsbUJBQUE7QUFDUjtBQUVNO0VBakJGO0lBa0JJLFVBQUE7RUFDTjtBQUNGO0FBQ007RUFyQkY7SUFzQkksV0FBQTtJQUNBLGdCQUFBO0VBRU47QUFDRjtBQUFNO0VBQ0UsaUJBQUE7RUFBQSxhQUFBO0VBQ0Esc0JBQUE7T0FBQSw4QkFBQTtBQUVSO0FBQVE7RUFDRSxrQkFBQTtFQUNBLHFCQUFBO0VBQ0EsaUJBQUE7RUFDQSxXQUFBO0VBQ0EsaUJBQUE7QUFFVjtBQUNRO0VBQ0UsZUFBQTtBQUNWO0FBQ1U7RUFDRSxXQUFBO0VBQ0EsVUFBQTtBQUNaO0FBSU07RUFDRSxrQkFBQTtFQUNBLGNBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsbUJBQUE7QUFGUjtBQUtNO0VBQ0UsaUJBQUE7RUFBQSxhQUFBO0VBQ0Esb0JBQUE7T0FBQSwyQkFBQTtFQUNBLGVBQUE7QUFIUjtBQUtRO0VBQ0UsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLHFCQUFBO0VBQ0EsaUJBQUE7RUFDQSx5QkFBQTtFQUNBLGNBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsV0FBQTtBQUhWO0FBT007RUFDRSxnQkFBQTtFQUNBLHFCQUFBO0VBQ0EseUJBQUE7RUFDQSxlQUFBO0VBQ0EsY0FBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtBQUxSXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5wcm9qZWN0IHtcXG4gIG1pbi1oZWlnaHQ6IDgwdmg7XFxuICBwYWRkaW5nLXRvcDogNTBweDtcXG5cXG4gID4gLmxpc3Qge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG5cXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgIH1cXG5cXG4gICAgPiBkaXYge1xcbiAgICAgIHdpZHRoOiAzMiU7XFxuICAgICAgbWFyZ2luOiAwIDAuNSUgMTBweDtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgYmFja2dyb3VuZDogIzI3MzE0NjtcXG4gICAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgICBib3gtc2hhZG93OiAwcHggMnB4IDJweCAjMGIxNTJiO1xcblxcbiAgICAgICYuYnJva2VuIHtcXG4gICAgICAgIG9wYWNpdHk6IDAuNCAhaW1wb3J0YW50O1xcbiAgICAgIH1cXG5cXG4gICAgICAmOmhvdmVyIHtcXG4gICAgICAgIGJhY2tncm91bmQ6ICMyZTNjNTg7XFxuICAgICAgfVxcblxcbiAgICAgIEBtZWRpYSAobWF4LXdpZHRoOiA5MDBweCkge1xcbiAgICAgICAgd2lkdGg6IDQ5JTtcXG4gICAgICB9XFxuXFxuICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIG1hcmdpbjogMCAwIDEwcHg7XFxuICAgICAgfVxcblxcbiAgICAgID4gLnRvcCB7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcblxcbiAgICAgICAgPiAudGl0bGUge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7XFxuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC5pY29uIHtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogNXB4O1xcblxcbiAgICAgICAgICA+IHN2ZyB7XFxuICAgICAgICAgICAgd2lkdGg6IDEzcHg7XFxuICAgICAgICAgICAgZmlsbDogI2ZmZjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICA+IC5kZXNjIHtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDVweDtcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgZm9udC1zaXplOiAwLjlyZW07XFxuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICAgICAgICBsaW5lLWhlaWdodDogMS40cmVtO1xcbiAgICAgIH1cXG5cXG4gICAgICA+IC5idWlsdCB7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xcblxcbiAgICAgICAgPiBzcGFuIHtcXG4gICAgICAgICAgbWFyZ2luOiAwIDVweCA1cHggMDtcXG4gICAgICAgICAgcGFkZGluZzogM3B4IDdweDtcXG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICBmb250LXNpemU6IDAuN3JlbTtcXG4gICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgICAgICAgIGJhY2tncm91bmQ6ICNhMmEyYTI7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgICAgICAgY29sb3I6ICMwMDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgID4gLmJyb2tlbkFQSSB7XFxuICAgICAgICBwYWRkaW5nOiAzcHggN3B4O1xcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTBweDtcXG4gICAgICAgIGNvbG9yOiAjZmYwZDBkO1xcbiAgICAgICAgYmFja2dyb3VuZDogIzAwMDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInByb2plY3RcIjogXCJwcm9qZWN0c19wcm9qZWN0X18zVUp4V1wiLFxuXHRcImxpc3RcIjogXCJwcm9qZWN0c19saXN0X18xc1dURlwiLFxuXHRcImJyb2tlblwiOiBcInByb2plY3RzX2Jyb2tlbl9fM0paYnBcIixcblx0XCJ0b3BcIjogXCJwcm9qZWN0c190b3BfXzFfenFKXCIsXG5cdFwidGl0bGVcIjogXCJwcm9qZWN0c190aXRsZV9fMmNBeTlcIixcblx0XCJpY29uXCI6IFwicHJvamVjdHNfaWNvbl9fMkN4M1FcIixcblx0XCJkZXNjXCI6IFwicHJvamVjdHNfZGVzY19fMXJPN19cIixcblx0XCJidWlsdFwiOiBcInByb2plY3RzX2J1aWx0X18xUTlfSlwiLFxuXHRcImJyb2tlbkFQSVwiOiBcInByb2plY3RzX2Jyb2tlbkFQSV9fSjNBR05cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./pages/projects.module.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/webpack/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =\n/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 931:\n/***/ (function(module) {\n\nmodule.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat */\n/******/ \t\n/******/ \t__nccwpck_require__.ab = __dirname + \"/\";/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(931);\n/******/ })()\n;\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL2hhcm1vbnktbW9kdWxlLmpzP2YzNDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVAsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3dlYnBhY2svaGFybW9ueS1tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA5MzE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcblx0aWYgKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHR2YXIgdGhyZXcgPSB0cnVlO1xuLyoqKioqKi8gXHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX25jY3dwY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XHRcdHRocmV3ID0gZmFsc2U7XG4vKioqKioqLyBcdFx0fSBmaW5hbGx5IHtcbi8qKioqKiovIFx0XHRcdGlmKHRocmV3KSBkZWxldGUgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCAqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0X19uY2N3cGNrX3JlcXVpcmVfXy5hYiA9IF9fZGlybmFtZSArIFwiL1wiOy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIG1vZHVsZSBleHBvcnRzIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBydW50aW1lIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX25jY3dwY2tfcmVxdWlyZV9fKDkzMSk7XG4vKioqKioqLyB9KSgpXG47Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/webpack/harmony-module.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/webpack/module.js":
/*!***********************************!*\
  !*** (webpack)/webpack/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports =\n/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 880:\n/***/ (function(module) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat */\n/******/ \t\n/******/ \t__nccwpck_require__.ab = __dirname + \"/\";/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(880);\n/******/ })()\n;\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS93ZWJwYWNrL21vZHVsZS5qcz8zZTczIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC93ZWJwYWNrL21vZHVsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDg4MDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0dmFyIHRocmV3ID0gdHJ1ZTtcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX19uY2N3cGNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFx0XHR0aHJldyA9IGZhbHNlO1xuLyoqKioqKi8gXHRcdH0gZmluYWxseSB7XG4vKioqKioqLyBcdFx0XHRpZih0aHJldykgZGVsZXRlIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdF9fbmNjd3Bja19yZXF1aXJlX18uYWIgPSBfX2Rpcm5hbWUgKyBcIi9cIjsvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXyg4ODApO1xuLyoqKioqKi8gfSkoKVxuOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/webpack/module.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nexports.__esModule = true;\nexports.AmpStateContext = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar AmpStateContext = /*#__PURE__*/_react[\"default\"].createContext({});\n\nexports.AmpStateContext = AmpStateContext;\n\nif (true) {\n  AmpStateContext.displayName = 'AmpStateContext';\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAtY29udGV4dC50cz84NzlmIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7QUFFTzs7QUFBQSxJQUFNQSxlQUFtQyxnQkFBR0MsZ0NBQTVDLEVBQTRDQSxDQUE1Qzs7OztBQUVQLFVBQTJDO0FBQ3pDRCxpQkFBZSxDQUFmQTtBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvYW1wLWNvbnRleHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/amp-context.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _s = $RefreshSig$();\n\nexports.__esModule = true;\nexports.isInAmpMode = isInAmpMode;\nexports.useAmp = useAmp;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _ampContext = __webpack_require__(/*! ./amp-context */ \"./node_modules/next/dist/next-server/lib/amp-context.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction isInAmpMode() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$ampFirst = _ref.ampFirst,\n      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,\n      _ref$hybrid = _ref.hybrid,\n      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,\n      _ref$hasQuery = _ref.hasQuery,\n      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;\n\n  return ampFirst || hybrid && hasQuery;\n}\n\nfunction useAmp() {\n  _s();\n\n  // Don't assign the context value to a variable to save bytes\n  return isInAmpMode(_react[\"default\"].useContext(_ampContext.AmpStateContext));\n}\n\n_s(useAmp, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAudHM/MDdkMiJdLCJuYW1lcyI6WyJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5IiwiaXNJbkFtcE1vZGUiLCJSZWFjdCIsIkFtcFN0YXRlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7O0FBRU87O0FBQUEsdUJBSVU7QUFBQSxpRkFKVixFQUlVO0FBQUEsMkJBSGZBLFFBR2U7QUFBQSxNQUhmQSxRQUdlLDhCQUpXLEtBSVg7QUFBQSx5QkFGZkMsTUFFZTtBQUFBLE1BRmZBLE1BRWUsNEJBSlcsS0FJWDtBQUFBLDJCQURmQyxRQUNlO0FBQUEsTUFEZkEsUUFDZSw4QkFKVyxLQUlYOztBQUNmLFNBQU9GLFFBQVEsSUFBS0MsTUFBTSxJQUExQjtBQUdLOztBQUFBLGtCQUEyQjtBQUFBOztBQUNoQztBQUNBLFNBQU9FLFdBQVcsQ0FBQ0MsNkJBQWlCQyxZQUFwQyxlQUFtQkQsQ0FBRCxDQUFsQjtBQUNEOztHQUhNLE0iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9hbXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFtcCgpOiBib29sZWFuIHtcbiAgLy8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xuICByZXR1cm4gaXNJbkFtcE1vZGUoUmVhY3QudXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/amp.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nexports.__esModule = true;\nexports.HeadManagerContext = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar HeadManagerContext = /*#__PURE__*/_react[\"default\"].createContext({});\n\nexports.HeadManagerContext = HeadManagerContext;\n\nif (true) {\n  HeadManagerContext.displayName = 'HeadManagerContext';\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cz9iMmQ2Il0sIm5hbWVzIjpbIkhlYWRNYW5hZ2VyQ29udGV4dCIsIlJlYWN0Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7QUFFTzs7QUFBQSxJQUFNQSxrQkFLWCxnQkFBR0MsZ0NBTEUsRUFLRkEsQ0FMRTs7OztBQU9QLFVBQTJDO0FBQ3pDRCxvQkFBa0IsQ0FBbEJBO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG4gIHVwZGF0ZVNjcmlwdHM/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBzY3JpcHRzPzogYW55XG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/head-manager-context.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty */ \"./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nexports.__esModule = true;\nexports.defaultHead = defaultHead;\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ \"./node_modules/next/dist/next-server/lib/side-effect.js\"));\n\nvar _ampContext = __webpack_require__(/*! ./amp-context */ \"./node_modules/next/dist/next-server/lib/amp-context.js\");\n\nvar _headManagerContext = __webpack_require__(/*! ./head-manager-context */ \"./node_modules/next/dist/next-server/lib/head-manager-context.js\");\n\nvar _amp = __webpack_require__(/*! ./amp */ \"./node_modules/next/dist/next-server/lib/amp.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction defaultHead() {\n  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var head = [/*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n    charSet: \"utf-8\"\n  })];\n\n  if (!inAmpMode) {\n    head.push( /*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n      name: \"viewport\",\n      content: \"width=device-width\"\n    }));\n  }\n\n  return head;\n}\n\nfunction onlyReactElement(list, child) {\n  // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n  if (typeof child === 'string' || typeof child === 'number') {\n    return list;\n  } // Adds support for React.Fragment\n\n\n  if (child.type === _react[\"default\"].Fragment) {\n    return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {\n      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n        return fragmentList;\n      }\n\n      return fragmentList.concat(fragmentChild);\n    }, []));\n  }\n\n  return list.concat(child);\n}\n\nvar METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];\n/*\nreturns a function for filtering head child elements\nwhich shouldn't be duplicated, like <title/>\nAlso adds support for deduplicated `key` properties\n*/\n\nfunction unique() {\n  var keys = new Set();\n  var tags = new Set();\n  var metaTypes = new Set();\n  var metaCategories = {};\n  return function (h) {\n    var isUnique = true;\n    var hasKey = false;\n\n    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n      hasKey = true;\n      var key = h.key.slice(h.key.indexOf('$') + 1);\n\n      if (keys.has(key)) {\n        isUnique = false;\n      } else {\n        keys.add(key);\n      }\n    } // eslint-disable-next-line default-case\n\n\n    switch (h.type) {\n      case 'title':\n      case 'base':\n        if (tags.has(h.type)) {\n          isUnique = false;\n        } else {\n          tags.add(h.type);\n        }\n\n        break;\n\n      case 'meta':\n        for (var i = 0, len = METATYPES.length; i < len; i++) {\n          var metatype = METATYPES[i];\n          if (!h.props.hasOwnProperty(metatype)) continue;\n\n          if (metatype === 'charSet') {\n            if (metaTypes.has(metatype)) {\n              isUnique = false;\n            } else {\n              metaTypes.add(metatype);\n            }\n          } else {\n            var category = h.props[metatype];\n            var categories = metaCategories[metatype] || new Set();\n\n            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n              isUnique = false;\n            } else {\n              categories.add(category);\n              metaCategories[metatype] = categories;\n            }\n          }\n        }\n\n        break;\n    }\n\n    return isUnique;\n  };\n}\n/**\n*\n* @param headElements List of multiple <Head> instances\n*/\n\n\nfunction reduceComponents(headElements, props) {\n  return headElements.reduce(function (list, headElement) {\n    var headElementChildren = _react[\"default\"].Children.toArray(headElement.props.children);\n\n    return list.concat(headElementChildren);\n  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {\n    var key = c.key || i;\n\n    if (false) { var newProps; }\n\n    return /*#__PURE__*/_react[\"default\"].cloneElement(c, {\n      key: key\n    });\n  });\n}\n/**\n* This component injects elements to `<head>` of your page.\n* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n*/\n\n\nfunction Head(_ref) {\n  var children = _ref.children;\n  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);\n  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);\n  return /*#__PURE__*/_react[\"default\"].createElement(_sideEffect[\"default\"], {\n    reduceComponentsToState: reduceComponents,\n    headManager: headManager,\n    inAmpMode: (0, _amp.isInAmpMode)(ampState)\n  }, children);\n} // TODO: Remove in the next major release\n\n\n_c = Head;\n\nHead.rewind = function () {};\n\nvar _default = Head;\nexports[\"default\"] = _default;\n\nvar _c;\n\n$RefreshReg$(_c, \"Head\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeD84YjI3Il0sIm5hbWVzIjpbImluQW1wTW9kZSIsImhlYWQiLCJjaGlsZCIsIlJlYWN0IiwibGlzdCIsImZyYWdtZW50TGlzdCIsIk1FVEFUWVBFUyIsImtleXMiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpIiwibGVuIiwibWV0YXR5cGUiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJoZWFkRWxlbWVudHMiLCJoZWFkRWxlbWVudENoaWxkcmVuIiwiaGVhZEVsZW1lbnQiLCJkZWZhdWx0SGVhZCIsInByb3BzIiwidW5pcXVlIiwiYyIsInByb2Nlc3MiLCJhbXBTdGF0ZSIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiSGVhZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNTzs7QUFBQSx1QkFBdUQ7QUFBQSxNQUFsQ0EsU0FBa0MsdUVBQXZELEtBQXVEO0FBQzVELE1BQU1DLElBQUksR0FBRyxjQUFDO0FBQU0sV0FBTyxFQUEzQjtBQUFjLElBQUQsQ0FBYjs7QUFDQSxNQUFJLENBQUosV0FBZ0I7QUFDZEEsUUFBSSxDQUFKQSxtQkFBVTtBQUFNLFVBQUksRUFBVjtBQUFzQixhQUFPLEVBQXZDQTtBQUFVLE1BQVZBO0FBRUY7O0FBQUE7QUFHRjs7QUFBQSx1Q0FHa0M7QUFDaEM7QUFDQSxNQUFJLDZCQUE2QixpQkFBakMsVUFBNEQ7QUFDMUQ7QUFFRixHQUxnQyxDQUtoQzs7O0FBQ0EsTUFBSUMsS0FBSyxDQUFMQSxTQUFlQyxrQkFBbkIsVUFBbUM7QUFDakMsV0FBT0MsSUFBSSxD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LENBWmRBLFNBYUdLLE1BYkhMLGtCQWVBLGdCQUEyQztBQUM5QyxRQUFNTixHQUFHLEdBQUdZLENBQUMsQ0FBREEsT0FBWjs7QUFDQSxRQUNFQyxLQURGLEVBSUUsaUJBb0JGOztBQUFBLHdCQUFPeEIsa0NBQXNCO0FBQUVXLFNBQS9CLEVBQStCQTtBQUFGLEtBQXRCWCxDQUFQO0FBekNKLEdBQU9pQixDQUFQO0FBNkNGO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLG9CQUEyRDtBQUFBLE1BQTNELFFBQTJELFFBQTNELFFBQTJEO0FBQ3pELE1BQU1RLFFBQVEsR0FBRyx1QkFBV0MsWUFBNUIsZUFBaUIsQ0FBakI7QUFDQSxNQUFNQyxXQUFXLEdBQUcsdUJBQVdDLG9CQUEvQixrQkFBb0IsQ0FBcEI7QUFDQSxzQkFDRSxnQ0FBQyxXQUFEO0FBQ0UsMkJBQXVCLEVBRHpCO0FBRUUsZUFBVyxFQUZiO0FBR0UsYUFBUyxFQUFFLHNCQUhiLFFBR2E7QUFIYixLQURGLFFBQ0UsQ0FERjtBQVdGLEMsQ0FBQTs7O0tBZEEsSTs7QUFlQUMsSUFBSSxDQUFKQSxTQUFjLFlBQU0sQ0FBcEJBOztlQUVlQSxJIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPl1cbiAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICBoZWFkLnB1c2goPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIC8+KVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbik6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiB7XG4gIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIC8vIEFkZHMgc3VwcG9ydCBmb3IgUmVhY3QuRnJhZ21lbnRcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KFxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAoXG4gICAgICAgICAgZnJhZ21lbnRMaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgICAgICAgZnJhZ21lbnRDaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkRWxlbWVudHMgTGlzdCBvZiBtdWx0aXBsZSA8SGVhZD4gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoXG4gIGhlYWRFbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogV2l0aEluQW1wTW9kZVxuKSB7XG4gIHJldHVybiBoZWFkRWxlbWVudHNcbiAgICAucmVkdWNlKFxuICAgICAgKGxpc3Q6IFJlYWN0LlJlYWN0Q2hpbGRbXSwgaGVhZEVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KFxuICAgICAgICAgIGhlYWRFbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pXG4gICAgICB9LFxuICAgICAgW11cbiAgICApXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFwcm9wcy5pbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LycsXG4gICAgICAgICAgXS5zb21lKCh1cmwpID0+IGMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi4oYy5wcm9wcyB8fCB7fSkgfVxuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ11cbiAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtb3B0aW1pemVkLWZvbnRzJ10gPSB0cnVlXG5cbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/head.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ \"./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ \"./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _assertThisInitialized = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized */ \"./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/inherits */ \"./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf */ \"./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar isServer = false;\n\nvar _default = /*#__PURE__*/function (_react$Component) {\n  _inherits(_default, _react$Component);\n\n  var _super = _createSuper(_default);\n\n  function _default(props) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _super.call(this, props);\n    _this._hasHeadManager = void 0;\n\n    _this.emitChange = function () {\n      if (_this._hasHeadManager) {\n        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));\n      }\n    };\n\n    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;\n\n    if (isServer && _this._hasHeadManager) {\n      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));\n\n      _this.emitChange();\n    }\n\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this._hasHeadManager) {\n        this.props.headManager.mountedInstances.add(this);\n      }\n\n      this.emitChange();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.emitChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._hasHeadManager) {\n        this.props.headManager.mountedInstances[\"delete\"](this);\n      }\n\n      this.emitChange();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return _default;\n}(_react.Component);\n\nexports[\"default\"] = _default;\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9zaWRlLWVmZmVjdC50c3g/MTNiNyJdLCJuYW1lcyI6WyJpc1NlcnZlciIsImNvbnN0cnVjdG9yIiwiX2hhc0hlYWRNYW5hZ2VyIiwiZW1pdENoYW5nZSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUEsSUFBTUEsUUFBTjs7SUFjZSxROzs7OztBQWNiQyxvQkFBVyxLQUFYQSxFQUF3QjtBQUFBOztBQUFBOztBQUN0QjtBQURzQixVQWJoQkMsZUFhZ0I7O0FBQUEsVUFYeEJDLFVBV3dCLEdBWFgsWUFBWTtBQUN2QixVQUFJLE1BQUosaUJBQTBCO0FBQ3hCLDJDQUNFLHVEQUNNLHdCQUROLG1CQUVFLE1BSEosS0FDRSxDQURGO0FBT0g7QUFFdUI7O0FBRXRCLDRCQUNFLDJCQUEwQix3QkFENUI7O0FBR0EsUUFBSUgsUUFBUSxJQUFJLE1BQWhCLGlCQUFzQztBQUNwQzs7QUFDQTtBQUVIOztBQVR1QjtBQVV4Qkk7Ozs7d0NBQW9CO0FBQ2xCLFVBQUksS0FBSixpQkFBMEI7QUFDeEI7QUFFRjs7QUFBQTtBQUVGQzs7O3lDQUFxQjtBQUNuQjtBQUVGQzs7OzJDQUF1QjtBQUNyQixVQUFJLEtBQUosaUJBQTBCO0FBQ3hCO0FBRUY7O0FBQUE7QUFHRkM7Ozs2QkFBUztBQUNQO0FBekNvRDs7OztFQUEzQkMsZ0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9zaWRlLWVmZmVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIFN0YXRlID0gSlNYLkVsZW1lbnRbXSB8IHVuZGVmaW5lZFxuXG50eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUPihcbiAgICBjb21wb25lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgcHJvcHM6IFRcbiAgKSA9PiBTdGF0ZVxuICBoYW5kbGVTdGF0ZUNoYW5nZT86IChzdGF0ZTogU3RhdGUpID0+IHZvaWRcbiAgaGVhZE1hbmFnZXI6IGFueVxuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50PFNpZGVFZmZlY3RQcm9wcz4ge1xuICBwcml2YXRlIF9oYXNIZWFkTWFuYWdlcjogYm9vbGVhblxuXG4gIGVtaXRDaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQoXG4gICAgICAgIHRoaXMucHJvcHMucmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoXG4gICAgICAgICAgWy4uLnRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc10sXG4gICAgICAgICAgdGhpcy5wcm9wc1xuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuX2hhc0hlYWRNYW5hZ2VyID1cbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIgJiYgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXG5cbiAgICBpZiAoaXNTZXJ2ZXIgJiYgdGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZSh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/side-effect.js\n");

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ \"./node_modules/next/dist/next-server/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcz84MzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHFGQUE2QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9uZXh0LXNlcnZlci9saWIvaGVhZCcpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcz9lZGU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanM/ZTVmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUIsbUJBQU8sQ0FBQyx1R0FBb0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzP2E5NzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanM/ZmM2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/OGI2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/YTA4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanM/NGY0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanM/ZTNjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyxtR0FBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzP2FlNTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanM/OTA2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ \"./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz9iNDIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyx3R0FBK0I7O0FBRXJELDRCQUE0QixtQkFBTyxDQUFDLGlIQUF5Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanM/YWExYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ \"./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ \"./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanM/OThmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsbUJBQU8sQ0FBQyx5R0FBcUI7O0FBRXJELHNCQUFzQixtQkFBTyxDQUFDLHFHQUFtQjs7QUFFakQsaUNBQWlDLG1CQUFPLENBQUMsMkhBQThCOztBQUV2RSx3QkFBd0IsbUJBQU8sQ0FBQyx5R0FBcUI7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzPzBiZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ \"./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/MjljOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUIsbUJBQU8sQ0FBQyx1R0FBb0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\n");

/***/ }),

/***/ "./node_modules/popmotion/dist/popmotion.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/popmotion/dist/popmotion.es.js ***!
  \*****************************************************/
/*! exports provided: Action, ValueReaction, action, chain, composite, crossfade, decay, delay, everyFrame, inertia, keyframes, listen, merge, mouse, multicast, multitouch, parallel, physics, pointer, schedule, spring, stagger, styler, timeline, tween, value */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Action\", function() { return Action; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValueReaction\", function() { return ValueReaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"action\", function() { return action; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chain\", function() { return chain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"composite\", function() { return composite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"crossfade\", function() { return crossfade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decay\", function() { return vectorDecay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delay\", function() { return delay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"everyFrame\", function() { return frame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inertia\", function() { return index; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyframes\", function() { return keyframes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listen\", function() { return listen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouse\", function() { return mouse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multicast\", function() { return multicast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multitouch\", function() { return multitouch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parallel\", function() { return parallel$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"physics\", function() { return vectorPhysics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointer\", function() { return index$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"schedule\", function() { return schedule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spring\", function() { return vectorSpring; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stagger\", function() { return stagger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"styler\", function() { return styler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timeline\", function() { return timeline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tween\", function() { return tween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"value\", function() { return value; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popmotion/popcorn */ \"./node_modules/@popmotion/popcorn/dist/popcorn.es.js\");\n/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framesync */ \"./node_modules/framesync/dist/framesync.es.js\");\n/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! style-value-types */ \"./node_modules/style-value-types/dist/style-value-types.es.js\");\n/* harmony import */ var _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @popmotion/easing */ \"./node_modules/@popmotion/easing/dist/easing.es.js\");\n/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hey-listen */ \"./node_modules/hey-listen/dist/hey-listen.es.js\");\n\n\n\n\n\n\n\nvar Observer = /*#__PURE__*/function () {\n    function Observer(_a, observer) {\n        var _this = this;\n        var middleware = _a.middleware,\n            onComplete = _a.onComplete;\n        this.isActive = true;\n        this.update = function (v) {\n            if (_this.observer.update) _this.updateObserver(v);\n        };\n        this.complete = function () {\n            if (_this.observer.complete && _this.isActive) _this.observer.complete();\n            if (_this.onComplete) _this.onComplete();\n            _this.isActive = false;\n        };\n        this.error = function (err) {\n            if (_this.observer.error && _this.isActive) _this.observer.error(err);\n            _this.isActive = false;\n        };\n        this.observer = observer;\n        this.updateObserver = function (v) {\n            return observer.update(v);\n        };\n        this.onComplete = onComplete;\n        if (observer.update && middleware && middleware.length) {\n            middleware.forEach(function (m) {\n                return _this.updateObserver = m(_this.updateObserver, _this.complete);\n            });\n        }\n    }\n    return Observer;\n}();\nvar createObserver = function (observerCandidate, _a, onComplete) {\n    var middleware = _a.middleware;\n    if (typeof observerCandidate === 'function') {\n        return new Observer({ middleware: middleware, onComplete: onComplete }, { update: observerCandidate });\n    } else {\n        return new Observer({ middleware: middleware, onComplete: onComplete }, observerCandidate);\n    }\n};\n\nvar Action = /*#__PURE__*/function () {\n    function Action(props) {\n        if (props === void 0) {\n            props = {};\n        }\n        this.props = props;\n    }\n    Action.prototype.create = function (props) {\n        return new Action(props);\n    };\n    Action.prototype.start = function (observerCandidate) {\n        if (observerCandidate === void 0) {\n            observerCandidate = {};\n        }\n        var isComplete = false;\n        var subscription = {\n            stop: function () {\n                return undefined;\n            }\n        };\n        var _a = this.props,\n            init = _a.init,\n            observerProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"init\"]);\n        var observer = createObserver(observerCandidate, observerProps, function () {\n            isComplete = true;\n            subscription.stop();\n        });\n        var api = init(observer);\n        subscription = api ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, subscription, api) : subscription;\n        if (isComplete) subscription.stop();\n        return subscription;\n    };\n    Action.prototype.applyMiddleware = function (middleware) {\n        return this.create(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));\n    };\n    Action.prototype.pipe = function () {\n        var funcs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            funcs[_i] = arguments[_i];\n        }\n        var pipedUpdate = funcs.length === 1 ? funcs[0] : _popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"pipe\"].apply(void 0, funcs);\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return update(pipedUpdate(v));\n            };\n        });\n    };\n    return Action;\n}();\nvar action = function (init) {\n    return new Action({ init: init });\n};\n\nvar Chainable = /*#__PURE__*/function () {\n    function Chainable(props) {\n        if (props === void 0) {\n            props = {};\n        }\n        this.props = props;\n    }\n    Chainable.prototype.applyMiddleware = function (middleware) {\n        return this.create(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));\n    };\n    Chainable.prototype.pipe = function () {\n        var funcs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            funcs[_i] = arguments[_i];\n        }\n        var pipedUpdate = funcs.length === 1 ? funcs[0] : _popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"pipe\"].apply(void 0, funcs);\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return update(pipedUpdate(v));\n            };\n        });\n    };\n    Chainable.prototype.while = function (predicate) {\n        return this.applyMiddleware(function (update, complete) {\n            return function (v) {\n                return predicate(v) ? update(v) : complete();\n            };\n        });\n    };\n    Chainable.prototype.filter = function (predicate) {\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return predicate(v) && update(v);\n            };\n        });\n    };\n    return Chainable;\n}();\n\nvar BaseMulticast = /*#__PURE__*/function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BaseMulticast, _super);\n    function BaseMulticast() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.subscribers = [];\n        return _this;\n    }\n    BaseMulticast.prototype.complete = function () {\n        this.subscribers.forEach(function (subscriber) {\n            return subscriber.complete();\n        });\n    };\n    BaseMulticast.prototype.error = function (err) {\n        this.subscribers.forEach(function (subscriber) {\n            return subscriber.error(err);\n        });\n    };\n    BaseMulticast.prototype.update = function (v) {\n        for (var i = 0; i < this.subscribers.length; i++) {\n            this.subscribers[i].update(v);\n        }\n    };\n    BaseMulticast.prototype.subscribe = function (observerCandidate) {\n        var _this = this;\n        var observer = createObserver(observerCandidate, this.props);\n        this.subscribers.push(observer);\n        var subscription = {\n            unsubscribe: function () {\n                var index = _this.subscribers.indexOf(observer);\n                if (index !== -1) _this.subscribers.splice(index, 1);\n            }\n        };\n        return subscription;\n    };\n    BaseMulticast.prototype.stop = function () {\n        if (this.parent) this.parent.stop();\n    };\n    return BaseMulticast;\n}(Chainable);\n\nvar Multicast = /*#__PURE__*/function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Multicast, _super);\n    function Multicast() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Multicast.prototype.create = function (props) {\n        return new Multicast(props);\n    };\n    return Multicast;\n}(BaseMulticast);\nvar multicast = function () {\n    return new Multicast();\n};\n\nvar ValueReaction = /*#__PURE__*/function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ValueReaction, _super);\n    function ValueReaction(props) {\n        var _this = _super.call(this, props) || this;\n        _this.scheduleVelocityCheck = function () {\n            return framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].postRender(_this.velocityCheck);\n        };\n        _this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n            }\n        };\n        _this.prev = _this.current = props.value || 0;\n        _this.updateCurrent = function (v) {\n            return _this.current = v;\n        };\n        _this.getVelocityOfCurrent = function () {\n            return _this.getSingleVelocity(_this.current, _this.prev);\n        };\n        if (props.initialSubscription) _this.subscribe(props.initialSubscription);\n        return _this;\n    }\n    ValueReaction.prototype.create = function (props) {\n        return new ValueReaction(props);\n    };\n    ValueReaction.prototype.get = function () {\n        return this.current;\n    };\n    ValueReaction.prototype.getVelocity = function () {\n        return this.getVelocityOfCurrent();\n    };\n    ValueReaction.prototype.update = function (v) {\n        _super.prototype.update.call(this, v);\n        this.prev = this.current;\n        this.updateCurrent(v);\n        var _a = Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])(),\n            delta = _a.delta,\n            timestamp = _a.timestamp;\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].postRender(this.scheduleVelocityCheck);\n    };\n    ValueReaction.prototype.subscribe = function (observerCandidate) {\n        var sub = _super.prototype.subscribe.call(this, observerCandidate);\n        this.subscribers[this.subscribers.length - 1].update(this.current);\n        return sub;\n    };\n    ValueReaction.prototype.getSingleVelocity = function (current, prev) {\n        return typeof current === 'number' && typeof prev === 'number' ? Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerSecond\"])(current - prev, this.timeDelta) : Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerSecond\"])(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;\n    };\n    return ValueReaction;\n}(BaseMulticast);\nvar value = function (value, initialSubscription) {\n    return new ValueReaction({ value: value, initialSubscription: initialSubscription });\n};\n\nvar createVectorTests = function (typeTests) {\n    var testNames = Object.keys(typeTests);\n    var isVectorProp = function (prop, key) {\n        return prop !== undefined && !typeTests[key](prop);\n    };\n    var getVectorKeys = function (props) {\n        return testNames.reduce(function (vectorKeys, key) {\n            if (isVectorProp(props[key], key)) vectorKeys.push(key);\n            return vectorKeys;\n        }, []);\n    };\n    var testVectorProps = function (props) {\n        return props && testNames.some(function (key) {\n            return isVectorProp(props[key], key);\n        });\n    };\n    return { getVectorKeys: getVectorKeys, testVectorProps: testVectorProps };\n};\nvar unitTypes = [style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"px\"], style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"percent\"], style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"degrees\"], style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"vh\"], style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"vw\"]];\nvar findUnitType = function (prop) {\n    return unitTypes.find(function (type) {\n        return type.test(prop);\n    });\n};\nvar isUnitProp = function (prop) {\n    return Boolean(findUnitType(prop));\n};\nvar createAction = function (action, props) {\n    return action(props);\n};\nvar createUnitAction = function (action, _a) {\n    var from = _a.from,\n        to = _a.to,\n        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"from\", \"to\"]);\n    var unitType = findUnitType(from) || findUnitType(to);\n    var transform = unitType.transform,\n        parse = unitType.parse;\n    return action(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props, { from: typeof from === 'string' ? parse(from) : from, to: typeof to === 'string' ? parse(to) : to })).pipe(transform);\n};\nvar createMixerAction = function (mixer) {\n    return function (action, _a) {\n        var from = _a.from,\n            to = _a.to,\n            props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"from\", \"to\"]);\n        return action(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props, { from: 0, to: 1 })).pipe(mixer(from, to));\n    };\n};\nvar createColorAction = /*#__PURE__*/createMixerAction(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"mixColor\"]);\nvar createComplexAction = /*#__PURE__*/createMixerAction(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"mixComplex\"]);\nvar createVectorAction = function (action, typeTests) {\n    var _a = createVectorTests(typeTests),\n        testVectorProps = _a.testVectorProps,\n        getVectorKeys = _a.getVectorKeys;\n    var vectorAction = function (props) {\n        var isVector = testVectorProps(props);\n        if (!isVector) return action(props);\n        var vectorKeys = getVectorKeys(props);\n        var testKey = vectorKeys[0];\n        var testProp = props[testKey];\n        return getActionCreator(testProp)(action, props, vectorKeys);\n    };\n    return vectorAction;\n};\nvar getActionCreator = function (prop) {\n    if (typeof prop === 'number') {\n        return createAction;\n    } else if (isUnitProp(prop)) {\n        return createUnitAction;\n    } else if (style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"color\"].test(prop)) {\n        return createColorAction;\n    } else if (style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"complex\"].test(prop)) {\n        return createComplexAction;\n    } else {\n        return createAction;\n    }\n};\n\nvar decay = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var complete = _a.complete,\n            update = _a.update;\n        var _b = props.velocity,\n            velocity = _b === void 0 ? 0 : _b,\n            _c = props.from,\n            from = _c === void 0 ? 0 : _c,\n            _d = props.power,\n            power = _d === void 0 ? 0.8 : _d,\n            _e = props.timeConstant,\n            timeConstant = _e === void 0 ? 350 : _e,\n            _f = props.restDelta,\n            restDelta = _f === void 0 ? 0.5 : _f,\n            modifyTarget = props.modifyTarget;\n        var elapsed = 0;\n        var amplitude = power * velocity;\n        var idealTarget = Math.round(from + amplitude);\n        var target = typeof modifyTarget === 'undefined' ? idealTarget : modifyTarget(idealTarget);\n        var process = framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(function (_a) {\n            var frameDelta = _a.delta;\n            elapsed += frameDelta;\n            var delta = -amplitude * Math.exp(-elapsed / timeConstant);\n            var isMoving = delta > restDelta || delta < -restDelta;\n            var current = isMoving ? target + delta : target;\n            update(current);\n            if (!isMoving) {\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n                complete();\n            }\n        }, true);\n        return {\n            stop: function () {\n                return framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n            }\n        };\n    });\n};\nvar vectorDecay = /*#__PURE__*/createVectorAction(decay, {\n    from: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    modifyTarget: function (func) {\n        return typeof func === 'function';\n    },\n    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test\n});\n\nvar spring = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var _b = props.velocity,\n            velocity = _b === void 0 ? 0.0 : _b;\n        var _c = props.from,\n            from = _c === void 0 ? 0.0 : _c,\n            _d = props.to,\n            to = _d === void 0 ? 0.0 : _d,\n            _e = props.stiffness,\n            stiffness = _e === void 0 ? 100 : _e,\n            _f = props.damping,\n            damping = _f === void 0 ? 10 : _f,\n            _g = props.mass,\n            mass = _g === void 0 ? 1.0 : _g,\n            _h = props.restSpeed,\n            restSpeed = _h === void 0 ? 0.01 : _h,\n            _j = props.restDelta,\n            restDelta = _j === void 0 ? 0.01 : _j;\n        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        var t = 0;\n        var delta = to - from;\n        var position = from;\n        var prevPosition = position;\n        var process = framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(function (_a) {\n            var timeDelta = _a.delta;\n            t += timeDelta;\n            var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n            var angularFreq = Math.sqrt(stiffness / mass) / 1000;\n            prevPosition = position;\n            if (dampingRatio < 1) {\n                var envelope = Math.exp(-dampingRatio * angularFreq * t);\n                var expoDecay = angularFreq * Math.sqrt(1.0 - dampingRatio * dampingRatio);\n                position = to - envelope * ((initialVelocity + dampingRatio * angularFreq * delta) / expoDecay * Math.sin(expoDecay * t) + delta * Math.cos(expoDecay * t));\n            } else {\n                var envelope = Math.exp(-angularFreq * t);\n                position = to - envelope * (delta + (initialVelocity + angularFreq * delta) * t);\n            }\n            velocity = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerSecond\"])(position - prevPosition, timeDelta);\n            var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;\n            var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;\n            if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {\n                position = to;\n                update(position);\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n                complete();\n            } else {\n                update(position);\n            }\n        }, true);\n        return {\n            stop: function () {\n                return framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n            }\n        };\n    });\n};\nvar vectorSpring = /*#__PURE__*/createVectorAction(spring, {\n    from: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    to: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    stiffness: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    damping: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    mass: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test\n});\n\nvar inertia = function (_a) {\n    var _b = _a.from,\n        from = _b === void 0 ? 0 : _b,\n        _c = _a.velocity,\n        velocity = _c === void 0 ? 0 : _c,\n        min = _a.min,\n        max = _a.max,\n        _d = _a.power,\n        power = _d === void 0 ? 0.8 : _d,\n        _e = _a.timeConstant,\n        timeConstant = _e === void 0 ? 700 : _e,\n        _f = _a.bounceStiffness,\n        bounceStiffness = _f === void 0 ? 500 : _f,\n        _g = _a.bounceDamping,\n        bounceDamping = _g === void 0 ? 10 : _g,\n        _h = _a.restDelta,\n        restDelta = _h === void 0 ? 1 : _h,\n        modifyTarget = _a.modifyTarget;\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var prev = from;\n        var current = from;\n        var activeAnimation;\n        var isSpring = false;\n        var isLessThanMin = function (v) {\n            return min !== undefined && v <= min;\n        };\n        var isMoreThanMax = function (v) {\n            return max !== undefined && v >= max;\n        };\n        var isOutOfBounds = function (v) {\n            return isLessThanMin(v) || isMoreThanMax(v);\n        };\n        var isTravellingAwayFromBounds = function (v, currentVelocity) {\n            return isLessThanMin(v) && currentVelocity < 0 || isMoreThanMax(v) && currentVelocity > 0;\n        };\n        var onUpdate = function (v) {\n            update(v);\n            prev = current;\n            current = v;\n            velocity = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerSecond\"])(current - prev, Object(framesync__WEBPACK_IMPORTED_MODULE_2__[\"getFrameData\"])().delta);\n            if (activeAnimation && !isSpring && isTravellingAwayFromBounds(v, velocity)) {\n                startSpring({ from: v, velocity: velocity });\n            }\n        };\n        var startAnimation = function (animation, next) {\n            activeAnimation && activeAnimation.stop();\n            activeAnimation = animation.start({\n                update: onUpdate,\n                complete: function () {\n                    if (next) {\n                        next();\n                        return;\n                    }\n                    complete();\n                }\n            });\n        };\n        var startSpring = function (props) {\n            isSpring = true;\n            startAnimation(vectorSpring(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props, { to: isLessThanMin(props.from) ? min : max, stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta })));\n        };\n        if (isOutOfBounds(from)) {\n            startSpring({ from: from, velocity: velocity });\n        } else if (velocity !== 0) {\n            var animation = vectorDecay({\n                from: from,\n                velocity: velocity,\n                timeConstant: timeConstant,\n                power: power,\n                restDelta: isOutOfBounds(from) ? 20 : restDelta,\n                modifyTarget: modifyTarget\n            });\n            startAnimation(animation, function () {\n                if (isOutOfBounds(current)) {\n                    startSpring({ from: current, velocity: velocity });\n                } else {\n                    complete();\n                }\n            });\n        } else {\n            complete();\n        }\n        return {\n            stop: function () {\n                return activeAnimation && activeAnimation.stop();\n            }\n        };\n    });\n};\nvar index = /*#__PURE__*/createVectorAction(inertia, {\n    from: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    min: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    max: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    damping: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    stiffness: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    modifyTarget: function (func) {\n        return typeof func === 'function';\n    }\n});\n\nvar frame = function () {\n    return action(function (_a) {\n        var update = _a.update;\n        var initialTime = 0;\n        var process = framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(function (_a) {\n            var timestamp = _a.timestamp;\n            if (!initialTime) initialTime = timestamp;\n            update(timestamp - initialTime);\n        }, true, true);\n        return {\n            stop: function () {\n                return framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n            }\n        };\n    });\n};\n\nvar scrubber = function (_a) {\n    var _b = _a.from,\n        from = _b === void 0 ? 0 : _b,\n        _c = _a.to,\n        to = _c === void 0 ? 1 : _c,\n        _d = _a.ease,\n        ease = _d === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"linear\"] : _d,\n        _e = _a.reverseEase,\n        reverseEase = _e === void 0 ? false : _e;\n    if (reverseEase) {\n        ease = Object(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"createReversedEasing\"])(ease);\n    }\n    return action(function (_a) {\n        var update = _a.update;\n        return {\n            seek: function (progress) {\n                return update(progress);\n            }\n        };\n    }).pipe(ease, function (v) {\n        return Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"mix\"])(from, to, v);\n    });\n};\nvar vectorScrubber = /*#__PURE__*/createVectorAction(scrubber, {\n    ease: function (func) {\n        return typeof func === 'function';\n    },\n    from: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    to: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test\n});\n\nvar clampProgress = /*#__PURE__*/Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(0, 1);\nvar tween = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var _b = props.duration,\n            duration = _b === void 0 ? 300 : _b,\n            _c = props.ease,\n            ease = _c === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"easeOut\"] : _c,\n            _d = props.flip,\n            flip = _d === void 0 ? 0 : _d,\n            _e = props.loop,\n            loop = _e === void 0 ? 0 : _e,\n            _f = props.yoyo,\n            yoyo = _f === void 0 ? 0 : _f,\n            _g = props.repeatDelay,\n            repeatDelay = _g === void 0 ? 0 : _g;\n        var _h = props.from,\n            from = _h === void 0 ? 0 : _h,\n            _j = props.to,\n            to = _j === void 0 ? 1 : _j,\n            _k = props.elapsed,\n            elapsed = _k === void 0 ? 0 : _k,\n            _l = props.flipCount,\n            flipCount = _l === void 0 ? 0 : _l,\n            _m = props.yoyoCount,\n            yoyoCount = _m === void 0 ? 0 : _m,\n            _o = props.loopCount,\n            loopCount = _o === void 0 ? 0 : _o;\n        var playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);\n        var currentProgress = 0;\n        var process;\n        var isActive = false;\n        var reverseAnimation = function (reverseEase) {\n            var _a;\n            if (reverseEase === void 0) {\n                reverseEase = false;\n            }\n            _a = [to, from], from = _a[0], to = _a[1];\n            playhead = vectorScrubber({ from: from, to: to, ease: ease, reverseEase: reverseEase }).start(update);\n        };\n        var isTweenComplete = function () {\n            var isComplete = isActive && elapsed > duration + repeatDelay;\n            if (!isComplete) return false;\n            if (isComplete && !loop && !flip && !yoyo) return true;\n            var overtime = elapsed - duration;\n            elapsed = overtime - repeatDelay;\n            if (loop && loopCount < loop) {\n                loopCount++;\n                return false;\n            } else if (flip && flipCount < flip) {\n                flipCount++;\n                reverseAnimation();\n                return false;\n            } else if (yoyo && yoyoCount < yoyo) {\n                yoyoCount++;\n                reverseAnimation(yoyoCount % 2 !== 0);\n                return false;\n            }\n            return true;\n        };\n        var updateTween = function () {\n            currentProgress = clampProgress(Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"progress\"])(0, duration, elapsed));\n            playhead.seek(currentProgress);\n        };\n        var startTimer = function () {\n            isActive = true;\n            process = framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(function (_a) {\n                var delta = _a.delta;\n                elapsed += delta;\n                updateTween();\n                if (isTweenComplete()) {\n                    framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n                    complete && framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(complete, false, true);\n                }\n            }, true);\n        };\n        var stopTimer = function () {\n            isActive = false;\n            if (process) framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n        };\n        startTimer();\n        return {\n            isActive: function () {\n                return isActive;\n            },\n            getElapsed: function () {\n                return Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(0, duration, elapsed);\n            },\n            getProgress: function () {\n                return currentProgress;\n            },\n            stop: function () {\n                stopTimer();\n            },\n            pause: function () {\n                stopTimer();\n                return this;\n            },\n            resume: function () {\n                if (!isActive) startTimer();\n                return this;\n            },\n            seek: function (newProgress) {\n                elapsed = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"mix\"])(0, duration, newProgress);\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updateTween, false, true);\n                return this;\n            },\n            reverse: function () {\n                reverseAnimation();\n                return this;\n            }\n        };\n    });\n};\n\nvar clampProgress$1 = /*#__PURE__*/Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"clamp\"])(0, 1);\nvar defaultEasings = function (values, easing) {\n    return values.map(function () {\n        return easing || _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"easeOut\"];\n    }).splice(0, values.length - 1);\n};\nvar defaultTimings = function (values) {\n    var numValues = values.length;\n    return values.map(function (value, i) {\n        return i !== 0 ? i / (numValues - 1) : 0;\n    });\n};\nvar interpolateScrubbers = function (input, scrubbers, update) {\n    var rangeLength = input.length;\n    var finalInputIndex = rangeLength - 1;\n    var finalScrubberIndex = finalInputIndex - 1;\n    var subs = scrubbers.map(function (scrub) {\n        return scrub.start(update);\n    });\n    return function (v) {\n        if (v <= input[0]) {\n            subs[0].seek(0);\n        }\n        if (v >= input[finalInputIndex]) {\n            subs[finalScrubberIndex].seek(1);\n        }\n        var i = 1;\n        for (; i < rangeLength; i++) {\n            if (input[i] > v || i === finalInputIndex) break;\n        }\n        var progressInRange = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"progress\"])(input[i - 1], input[i], v);\n        subs[i - 1].seek(clampProgress$1(progressInRange));\n    };\n};\nvar keyframes = function (_a) {\n    var easings = _a.easings,\n        _b = _a.ease,\n        ease = _b === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"linear\"] : _b,\n        times = _a.times,\n        values = _a.values,\n        tweenProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"easings\", \"ease\", \"times\", \"values\"]);\n    easings = Array.isArray(easings) ? easings : defaultEasings(values, easings);\n    times = times || defaultTimings(values);\n    var scrubbers = easings.map(function (easing, i) {\n        return vectorScrubber({\n            from: values[i],\n            to: values[i + 1],\n            ease: easing\n        });\n    });\n    return tween(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, tweenProps, { ease: ease })).applyMiddleware(function (update) {\n        return interpolateScrubbers(times, scrubbers, update);\n    });\n};\n\nvar physics = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var complete = _a.complete,\n            update = _a.update;\n        var _b = props.acceleration,\n            acceleration = _b === void 0 ? 0 : _b,\n            _c = props.friction,\n            friction = _c === void 0 ? 0 : _c,\n            _d = props.velocity,\n            velocity = _d === void 0 ? 0 : _d,\n            springStrength = props.springStrength,\n            to = props.to;\n        var _e = props.restSpeed,\n            restSpeed = _e === void 0 ? 0.001 : _e,\n            _f = props.from,\n            from = _f === void 0 ? 0 : _f;\n        var current = from;\n        var process = framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(function (_a) {\n            var delta = _a.delta;\n            var elapsed = Math.max(delta, 16);\n            if (acceleration) velocity += Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerFrame\"])(acceleration, elapsed);\n            if (friction) velocity *= Math.pow(1 - friction, elapsed / 100);\n            if (springStrength !== undefined && to !== undefined) {\n                var distanceToTarget = to - current;\n                velocity += distanceToTarget * Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerFrame\"])(springStrength, elapsed);\n            }\n            current += Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"velocityPerFrame\"])(velocity, elapsed);\n            update(current);\n            var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);\n            if (isComplete) {\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n                complete();\n            }\n        }, true);\n        return {\n            set: function (v) {\n                current = v;\n                return this;\n            },\n            setAcceleration: function (v) {\n                acceleration = v;\n                return this;\n            },\n            setFriction: function (v) {\n                friction = v;\n                return this;\n            },\n            setSpringStrength: function (v) {\n                springStrength = v;\n                return this;\n            },\n            setSpringTarget: function (v) {\n                to = v;\n                return this;\n            },\n            setVelocity: function (v) {\n                velocity = v;\n                return this;\n            },\n            stop: function () {\n                return framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(process);\n            }\n        };\n    });\n};\nvar vectorPhysics = /*#__PURE__*/createVectorAction(physics, {\n    acceleration: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    friction: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    from: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    to: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test,\n    springStrength: style_value_types__WEBPACK_IMPORTED_MODULE_3__[\"number\"].test\n});\n\nvar multi = function (_a) {\n    var getCount = _a.getCount,\n        getFirst = _a.getFirst,\n        getOutput = _a.getOutput,\n        mapApi = _a.mapApi,\n        setProp = _a.setProp,\n        startActions = _a.startActions;\n    return function (actions) {\n        return action(function (_a) {\n            var update = _a.update,\n                complete = _a.complete,\n                error = _a.error;\n            var numActions = getCount(actions);\n            var output = getOutput();\n            var updateOutput = function () {\n                return update(output);\n            };\n            var numCompletedActions = 0;\n            var subs = startActions(actions, function (a, name) {\n                var hasCompleted = false;\n                return a.start({\n                    complete: function () {\n                        if (!hasCompleted) {\n                            hasCompleted = true;\n                            numCompletedActions++;\n                            if (numCompletedActions === numActions) framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(complete);\n                        }\n                    },\n                    error: error,\n                    update: function (v) {\n                        setProp(output, name, v);\n                        framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updateOutput, false, true);\n                    }\n                });\n            });\n            return Object.keys(getFirst(subs)).reduce(function (api, methodName) {\n                api[methodName] = mapApi(subs, methodName);\n                return api;\n            }, {});\n        });\n    };\n};\n\nvar composite = /*#__PURE__*/multi({\n    getOutput: function () {\n        return {};\n    },\n    getCount: function (subs) {\n        return Object.keys(subs).length;\n    },\n    getFirst: function (subs) {\n        return subs[Object.keys(subs)[0]];\n    },\n    mapApi: function (subs, methodName) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return Object.keys(subs).reduce(function (output, propKey) {\n                var _a;\n                if (subs[propKey][methodName]) {\n                    args[0] && args[0][propKey] !== undefined ? output[propKey] = subs[propKey][methodName](args[0][propKey]) : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);\n                }\n                return output;\n            }, {});\n        };\n    },\n    setProp: function (output, name, v) {\n        return output[name] = v;\n    },\n    startActions: function (actions, starter) {\n        return Object.keys(actions).reduce(function (subs, key) {\n            subs[key] = starter(actions[key], key);\n            return subs;\n        }, {});\n    }\n});\n\nvar DEFAULT_DURATION = 300;\nvar flattenTimings = function (instructions) {\n    var flatInstructions = [];\n    var lastArg = instructions[instructions.length - 1];\n    var isStaggered = typeof lastArg === 'number';\n    var staggerDelay = isStaggered ? lastArg : 0;\n    var segments = isStaggered ? instructions.slice(0, -1) : instructions;\n    var numSegments = segments.length;\n    var offset = 0;\n    segments.forEach(function (item, i) {\n        flatInstructions.push(item);\n        if (i !== numSegments - 1) {\n            var duration = item.duration || DEFAULT_DURATION;\n            offset += staggerDelay;\n            flatInstructions.push(\"-\" + (duration - offset));\n        }\n    });\n    return flatInstructions;\n};\nvar flattenArrayInstructions = function (instructions, instruction) {\n    Array.isArray(instruction) ? instructions.push.apply(instructions, flattenTimings(instruction)) : instructions.push(instruction);\n    return instructions;\n};\nvar convertDefToProps = function (props, def, i) {\n    var duration = props.duration,\n        easings = props.easings,\n        times = props.times,\n        values = props.values;\n    var numValues = values.length;\n    var prevTimeTo = times[numValues - 1];\n    var timeFrom = def.at === 0 ? 0 : def.at / duration;\n    var timeTo = (def.at + def.duration) / duration;\n    if (i === 0) {\n        values.push(def.from);\n        times.push(timeFrom);\n    } else {\n        if (prevTimeTo !== timeFrom) {\n            if (def.from !== undefined) {\n                values.push(values[numValues - 1]);\n                times.push(timeFrom);\n                easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"linear\"]);\n            }\n            var from = def.from !== undefined ? def.from : values[numValues - 1];\n            values.push(from);\n            times.push(timeFrom);\n            easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"linear\"]);\n        } else if (def.from !== undefined) {\n            values.push(def.from);\n            times.push(timeFrom);\n            easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"linear\"]);\n        }\n    }\n    values.push(def.to);\n    times.push(timeTo);\n    easings.push(def.ease || _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__[\"easeInOut\"]);\n    return props;\n};\nvar timeline = function (instructions, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        duration = _b.duration,\n        elapsed = _b.elapsed,\n        ease = _b.ease,\n        loop = _b.loop,\n        flip = _b.flip,\n        yoyo = _b.yoyo;\n    var playhead = 0;\n    var calculatedDuration = 0;\n    var flatInstructions = instructions.reduce(flattenArrayInstructions, []);\n    var animationDefs = [];\n    flatInstructions.forEach(function (instruction) {\n        if (typeof instruction === 'string') {\n            playhead += parseFloat(instruction);\n        } else if (typeof instruction === 'number') {\n            playhead = instruction;\n        } else {\n            var def = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, instruction, { at: playhead });\n            def.duration = def.duration === undefined ? DEFAULT_DURATION : def.duration;\n            animationDefs.push(def);\n            playhead += def.duration;\n            calculatedDuration = Math.max(calculatedDuration, def.at + def.duration);\n        }\n    });\n    var tracks = {};\n    var numDefs = animationDefs.length;\n    for (var i = 0; i < numDefs; i++) {\n        var def = animationDefs[i];\n        var track = def.track;\n        if (track === undefined) {\n            throw new Error('No track defined');\n        }\n        if (!tracks.hasOwnProperty(track)) tracks[track] = [];\n        tracks[track].push(def);\n    }\n    var trackKeyframes = {};\n    for (var key in tracks) {\n        if (tracks.hasOwnProperty(key)) {\n            var keyframeProps = tracks[key].reduce(convertDefToProps, {\n                duration: calculatedDuration,\n                easings: [],\n                times: [],\n                values: []\n            });\n            trackKeyframes[key] = keyframes(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, keyframeProps, { duration: duration || calculatedDuration, ease: ease,\n                elapsed: elapsed,\n                loop: loop,\n                yoyo: yoyo,\n                flip: flip }));\n        }\n    }\n    return composite(trackKeyframes);\n};\n\nvar listen = function (element, events, options) {\n    return action(function (_a) {\n        var update = _a.update;\n        var eventNames = events.split(' ').map(function (eventName) {\n            element.addEventListener(eventName, update, options);\n            return eventName;\n        });\n        return {\n            stop: function () {\n                return eventNames.forEach(function (eventName) {\n                    return element.removeEventListener(eventName, update, options);\n                });\n            }\n        };\n    });\n};\n\nvar defaultPointerPos = function () {\n    return {\n        clientX: 0,\n        clientY: 0,\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0\n    };\n};\nvar eventToPoint = function (e, point) {\n    if (point === void 0) {\n        point = defaultPointerPos();\n    }\n    point.clientX = point.x = e.clientX;\n    point.clientY = point.y = e.clientY;\n    point.pageX = e.pageX;\n    point.pageY = e.pageY;\n    return point;\n};\n\nvar points = [/*#__PURE__*/defaultPointerPos()];\nvar isTouchDevice = false;\nif (typeof document !== 'undefined') {\n    var updatePointsLocation = function (_a) {\n        var touches = _a.touches;\n        isTouchDevice = true;\n        var numTouches = touches.length;\n        points.length = 0;\n        for (var i = 0; i < numTouches; i++) {\n            var thisTouch = touches[i];\n            points.push(eventToPoint(thisTouch));\n        }\n    };\n    listen(document, 'touchstart touchmove', {\n        passive: true,\n        capture: true\n    }).start(updatePointsLocation);\n}\nvar multitouch = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.preventDefault,\n        preventDefault = _c === void 0 ? true : _c,\n        _d = _b.scale,\n        scale = _d === void 0 ? 1.0 : _d,\n        _e = _b.rotate,\n        rotate = _e === void 0 ? 0.0 : _e;\n    return action(function (_a) {\n        var update = _a.update;\n        var output = {\n            touches: points,\n            scale: scale,\n            rotate: rotate\n        };\n        var initialDistance = 0.0;\n        var initialRotation = 0.0;\n        var isGesture = points.length > 1;\n        if (isGesture) {\n            var firstTouch = points[0],\n                secondTouch = points[1];\n            initialDistance = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"distance\"])(firstTouch, secondTouch);\n            initialRotation = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"angle\"])(firstTouch, secondTouch);\n        }\n        var updatePoint = function () {\n            if (isGesture) {\n                var firstTouch = points[0],\n                    secondTouch = points[1];\n                var newDistance = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"distance\"])(firstTouch, secondTouch);\n                var newRotation = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"angle\"])(firstTouch, secondTouch);\n                output.scale = scale * (newDistance / initialDistance);\n                output.rotate = rotate + (newRotation - initialRotation);\n            }\n            update(output);\n        };\n        var onMove = function (e) {\n            if (preventDefault || e.touches.length > 1) e.preventDefault();\n            framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updatePoint);\n        };\n        var updateOnMove = listen(document, 'touchmove', {\n            passive: !preventDefault\n        }).start(onMove);\n        if (isTouchDevice) framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updatePoint);\n        return {\n            stop: function () {\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(updatePoint);\n                updateOnMove.stop();\n            }\n        };\n    });\n};\nvar getIsTouchDevice = function () {\n    return isTouchDevice;\n};\n\nvar point = /*#__PURE__*/defaultPointerPos();\nvar isMouseDevice = false;\nif (typeof document !== 'undefined') {\n    var updatePointLocation = function (e) {\n        isMouseDevice = true;\n        eventToPoint(e, point);\n    };\n    listen(document, 'mousedown mousemove', true).start(updatePointLocation);\n}\nvar mouse = function (_a) {\n    var _b = (_a === void 0 ? {} : _a).preventDefault,\n        preventDefault = _b === void 0 ? true : _b;\n    return action(function (_a) {\n        var update = _a.update;\n        var updatePoint = function () {\n            return update(point);\n        };\n        var onMove = function (e) {\n            if (preventDefault) e.preventDefault();\n            framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updatePoint);\n        };\n        var updateOnMove = listen(document, 'mousemove').start(onMove);\n        if (isMouseDevice) framesync__WEBPACK_IMPORTED_MODULE_2__[\"default\"].update(updatePoint);\n        return {\n            stop: function () {\n                framesync__WEBPACK_IMPORTED_MODULE_2__[\"cancelSync\"].update(updatePoint);\n                updateOnMove.stop();\n            }\n        };\n    });\n};\n\nvar getFirstTouch = function (_a) {\n    var firstTouch = _a[0];\n    return firstTouch;\n};\nvar pointer = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return getIsTouchDevice() ? multitouch(props).pipe(function (_a) {\n        var touches = _a.touches;\n        return touches;\n    }, getFirstTouch) : mouse(props);\n};\nvar index$1 = function (_a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var x = _a.x,\n        y = _a.y,\n        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"x\", \"y\"]);\n    if (x !== undefined || y !== undefined) {\n        var applyXOffset_1 = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"applyOffset\"])(x || 0);\n        var applyYOffset_1 = Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"applyOffset\"])(y || 0);\n        var delta_1 = { x: 0, y: 0 };\n        return pointer(props).pipe(function (point) {\n            delta_1.x = applyXOffset_1(point.x);\n            delta_1.y = applyYOffset_1(point.y);\n            return delta_1;\n        });\n    } else {\n        return pointer(props);\n    }\n};\n\nvar chain = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var i = 0;\n        var current;\n        var playCurrent = function () {\n            current = actions[i].start({\n                complete: function () {\n                    i++;\n                    i >= actions.length ? complete() : playCurrent();\n                },\n                update: update\n            });\n        };\n        playCurrent();\n        return {\n            stop: function () {\n                return current && current.stop();\n            }\n        };\n    });\n};\n\nvar parallel = /*#__PURE__*/multi({\n    getOutput: function () {\n        return [];\n    },\n    getCount: function (subs) {\n        return subs.length;\n    },\n    getFirst: function (subs) {\n        return subs[0];\n    },\n    mapApi: function (subs, methodName) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return subs.map(function (sub, i) {\n                if (sub[methodName]) {\n                    return Array.isArray(args[0]) ? sub[methodName](args[0][i]) : sub[methodName].apply(sub, args);\n                }\n            });\n        };\n    },\n    setProp: function (output, name, v) {\n        return output[name] = v;\n    },\n    startActions: function (actions, starter) {\n        return actions.map(function (action, i) {\n            return starter(action, i);\n        });\n    }\n});\nvar parallel$1 = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return parallel(actions);\n};\n\nvar crossfade = function (a, b) {\n    return action(function (observer) {\n        var balance = 0;\n        var fadable = parallel$1(a, b).start(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, observer, { update: function (_a) {\n                var va = _a[0],\n                    vb = _a[1];\n                observer.update(Object(_popmotion_popcorn__WEBPACK_IMPORTED_MODULE_1__[\"mix\"])(va, vb, balance));\n            } }));\n        return {\n            setBalance: function (v) {\n                return balance = v;\n            },\n            stop: function () {\n                return fadable.stop();\n            }\n        };\n    });\n};\n\nvar delay = function (timeToDelay) {\n    return action(function (_a) {\n        var complete = _a.complete;\n        var timeout = setTimeout(complete, timeToDelay);\n        return {\n            stop: function () {\n                return clearTimeout(timeout);\n            }\n        };\n    });\n};\n\nvar merge = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return action(function (observer) {\n        var subs = actions.map(function (thisAction) {\n            return thisAction.start(observer);\n        });\n        return {\n            stop: function () {\n                return subs.forEach(function (sub) {\n                    return sub.stop();\n                });\n            }\n        };\n    });\n};\n\nvar schedule = function (scheduler, schedulee) {\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var latest;\n        var schedulerSub = scheduler.start({\n            update: function () {\n                return latest !== undefined && update(latest);\n            },\n            complete: complete\n        });\n        var scheduleeSub = schedulee.start({\n            update: function (v) {\n                return latest = v;\n            },\n            complete: complete\n        });\n        return {\n            stop: function () {\n                schedulerSub.stop();\n                scheduleeSub.stop();\n            }\n        };\n    });\n};\n\nvar stagger = function (actions, interval) {\n    var intervalIsNumber = typeof interval === 'number';\n    var actionsWithDelay = actions.map(function (a, i) {\n        var timeToDelay = intervalIsNumber ? interval * i : interval(i);\n        return chain(delay(timeToDelay), a);\n    });\n    return parallel$1.apply(void 0, actionsWithDelay);\n};\n\nvar styler = function () {\n    return Object(hey_listen__WEBPACK_IMPORTED_MODULE_5__[\"invariant\"])(false, 'styler has been removed from Popmotion in 9.0. Downgrade to 8.x or npm install stylefire');\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L3BvcG1vdGlvbi5lcy5qcz8zNWViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFvRDtBQUNxRztBQUM5RjtBQUM4QjtBQUNKO0FBQzlDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaURBQWlELEdBQUcsNEJBQTRCO0FBQzdHLEtBQUs7QUFDTCw2QkFBNkIsaURBQWlEO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLHNEQUFRLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQVEsR0FBRyxlQUFlLGdHQUFnRztBQUNySjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQSwwREFBMEQsdURBQUk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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TDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFRLEdBQUcsYUFBYTtBQUNyRTtBQUNBO0FBQ0EsZ0NBQWdDLDhEQUFHO0FBQ25DLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDREQUFTO0FBQ3BCOztBQUVtViIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9wb3Btb3Rpb24uZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBwaXBlLCB2ZWxvY2l0eVBlclNlY29uZCwgbWl4Q29tcGxleCwgbWl4Q29sb3IsIG1peCwgY2xhbXAsIHByb2dyZXNzLCB2ZWxvY2l0eVBlckZyYW1lLCBkaXN0YW5jZSwgYW5nbGUsIGFwcGx5T2Zmc2V0IH0gZnJvbSAnQHBvcG1vdGlvbi9wb3Bjb3JuJztcbmltcG9ydCBzeW5jLCB7IGdldEZyYW1lRGF0YSwgY2FuY2VsU3luYyB9IGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgeyBjb2xvciwgY29tcGxleCwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZoLCB2dywgbnVtYmVyIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlUmV2ZXJzZWRFYXNpbmcsIGxpbmVhciwgZWFzZU91dCwgZWFzZUluT3V0IH0gZnJvbSAnQHBvcG1vdGlvbi9lYXNpbmcnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5cbnZhciBPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXIoX2EsIG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtaWRkbGV3YXJlID0gX2EubWlkZGxld2FyZSxcbiAgICAgICAgICAgIG9uQ29tcGxldGUgPSBfYS5vbkNvbXBsZXRlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVyLnVwZGF0ZSkgX3RoaXMudXBkYXRlT2JzZXJ2ZXIodik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2ZXIuY29tcGxldGUgJiYgX3RoaXMuaXNBY3RpdmUpIF90aGlzLm9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25Db21wbGV0ZSkgX3RoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZlci5lcnJvciAmJiBfdGhpcy5pc0FjdGl2ZSkgX3RoaXMub2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy51cGRhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIudXBkYXRlKHYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlO1xuICAgICAgICBpZiAob2JzZXJ2ZXIudXBkYXRlICYmIG1pZGRsZXdhcmUgJiYgbWlkZGxld2FyZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmUuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVPYnNlcnZlciA9IG0oX3RoaXMudXBkYXRlT2JzZXJ2ZXIsIF90aGlzLmNvbXBsZXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcbnZhciBjcmVhdGVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlckNhbmRpZGF0ZSwgX2EsIG9uQ29tcGxldGUpIHtcbiAgICB2YXIgbWlkZGxld2FyZSA9IF9hLm1pZGRsZXdhcmU7XG4gICAgaWYgKHR5cGVvZiBvYnNlcnZlckNhbmRpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmVyKHsgbWlkZGxld2FyZTogbWlkZGxld2FyZSwgb25Db21wbGV0ZTogb25Db21wbGV0ZSB9LCB7IHVwZGF0ZTogb2JzZXJ2ZXJDYW5kaWRhdGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZlcih7IG1pZGRsZXdhcmU6IG1pZGRsZXdhcmUsIG9uQ29tcGxldGU6IG9uQ29tcGxldGUgfSwgb2JzZXJ2ZXJDYW5kaWRhdGUpO1xuICAgIH1cbn07XG5cbnZhciBBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGlvbihwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICAgIEFjdGlvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHByb3BzKTtcbiAgICB9O1xuICAgIEFjdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob2JzZXJ2ZXJDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyQ2FuZGlkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyQ2FuZGlkYXRlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5pdCA9IF9hLmluaXQsXG4gICAgICAgICAgICBvYnNlcnZlclByb3BzID0gX19yZXN0KF9hLCBbXCJpbml0XCJdKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIob2JzZXJ2ZXJDYW5kaWRhdGUsIG9ic2VydmVyUHJvcHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcGkgPSBpbml0KG9ic2VydmVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gYXBpID8gX19hc3NpZ24oe30sIHN1YnNjcmlwdGlvbiwgYXBpKSA6IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHN1YnNjcmlwdGlvbi5zdG9wKCk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBBY3Rpb24ucHJvdG90eXBlLmFwcGx5TWlkZGxld2FyZSA9IGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBtaWRkbGV3YXJlOiB0aGlzLnByb3BzLm1pZGRsZXdhcmUgPyBbbWlkZGxld2FyZV0uY29uY2F0KHRoaXMucHJvcHMubWlkZGxld2FyZSkgOiBbbWlkZGxld2FyZV0gfSkpO1xuICAgIH07XG4gICAgQWN0aW9uLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGZ1bmNzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpcGVkVXBkYXRlID0gZnVuY3MubGVuZ3RoID09PSAxID8gZnVuY3NbMF0gOiBwaXBlLmFwcGx5KHZvaWQgMCwgZnVuY3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1pZGRsZXdhcmUoZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShwaXBlZFVwZGF0ZSh2KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBY3Rpb247XG59KCk7XG52YXIgYWN0aW9uID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICByZXR1cm4gbmV3IEFjdGlvbih7IGluaXQ6IGluaXQgfSk7XG59O1xuXG52YXIgQ2hhaW5hYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFpbmFibGUocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHByb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgICBDaGFpbmFibGUucHJvdG90eXBlLmFwcGx5TWlkZGxld2FyZSA9IGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBtaWRkbGV3YXJlOiB0aGlzLnByb3BzLm1pZGRsZXdhcmUgPyBbbWlkZGxld2FyZV0uY29uY2F0KHRoaXMucHJvcHMubWlkZGxld2FyZSkgOiBbbWlkZGxld2FyZV0gfSkpO1xuICAgIH07XG4gICAgQ2hhaW5hYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGZ1bmNzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpcGVkVXBkYXRlID0gZnVuY3MubGVuZ3RoID09PSAxID8gZnVuY3NbMF0gOiBwaXBlLmFwcGx5KHZvaWQgMCwgZnVuY3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1pZGRsZXdhcmUoZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShwaXBlZFVwZGF0ZSh2KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYWluYWJsZS5wcm90b3R5cGUud2hpbGUgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWlkZGxld2FyZShmdW5jdGlvbiAodXBkYXRlLCBjb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2KSA/IHVwZGF0ZSh2KSA6IGNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYWluYWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1pZGRsZXdhcmUoZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2KSAmJiB1cGRhdGUodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFpbmFibGU7XG59KCk7XG5cbnZhciBCYXNlTXVsdGljYXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZU11bHRpY2FzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlTXVsdGljYXN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCYXNlTXVsdGljYXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VNdWx0aWNhc3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZU11bHRpY2FzdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW2ldLnVwZGF0ZSh2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZU11bHRpY2FzdC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyQ2FuZGlkYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKG9ic2VydmVyQ2FuZGlkYXRlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuc3Vic2NyaWJlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgX3RoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIEJhc2VNdWx0aWNhc3QucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkgdGhpcy5wYXJlbnQuc3RvcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VNdWx0aWNhc3Q7XG59KENoYWluYWJsZSk7XG5cbnZhciBNdWx0aWNhc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aWNhc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE11bHRpY2FzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGljYXN0KHByb3BzKTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aWNhc3Q7XG59KEJhc2VNdWx0aWNhc3QpO1xudmFyIG11bHRpY2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpY2FzdCgpO1xufTtcblxudmFyIFZhbHVlUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWx1ZVJlYWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhbHVlUmVhY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLnBvc3RSZW5kZXIoX3RoaXMudmVsb2NpdHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBfYS50aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICE9PSBfdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudCA9IHByb3BzLnZhbHVlIHx8IDA7XG4gICAgICAgIF90aGlzLnVwZGF0ZUN1cnJlbnQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRWZWxvY2l0eU9mQ3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRTaW5nbGVWZWxvY2l0eShfdGhpcy5jdXJyZW50LCBfdGhpcy5wcmV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLmluaXRpYWxTdWJzY3JpcHRpb24pIF90aGlzLnN1YnNjcmliZShwcm9wcy5pbml0aWFsU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWYWx1ZVJlYWN0aW9uLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJlYWN0aW9uKHByb3BzKTtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZWxvY2l0eU9mQ3VycmVudCgpO1xuICAgIH07XG4gICAgVmFsdWVSZWFjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnQodik7XG4gICAgICAgIHZhciBfYSA9IGdldEZyYW1lRGF0YSgpLFxuICAgICAgICAgICAgZGVsdGEgPSBfYS5kZWx0YSxcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgc3luYy5wb3N0UmVuZGVyKHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlckNhbmRpZGF0ZSkge1xuICAgICAgICB2YXIgc3ViID0gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBvYnNlcnZlckNhbmRpZGF0ZSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbdGhpcy5zdWJzY3JpYmVycy5sZW5ndGggLSAxXS51cGRhdGUodGhpcy5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLmdldFNpbmdsZVZlbG9jaXR5ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcHJldiA9PT0gJ251bWJlcicgPyB2ZWxvY2l0eVBlclNlY29uZChjdXJyZW50IC0gcHJldiwgdGhpcy50aW1lRGVsdGEpIDogdmVsb2NpdHlQZXJTZWNvbmQocGFyc2VGbG9hdChjdXJyZW50KSAtIHBhcnNlRmxvYXQocHJldiksIHRoaXMudGltZURlbHRhKSB8fCAwO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlUmVhY3Rpb247XG59KEJhc2VNdWx0aWNhc3QpO1xudmFyIHZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsU3Vic2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZVJlYWN0aW9uKHsgdmFsdWU6IHZhbHVlLCBpbml0aWFsU3Vic2NyaXB0aW9uOiBpbml0aWFsU3Vic2NyaXB0aW9uIH0pO1xufTtcblxudmFyIGNyZWF0ZVZlY3RvclRlc3RzID0gZnVuY3Rpb24gKHR5cGVUZXN0cykge1xuICAgIHZhciB0ZXN0TmFtZXMgPSBPYmplY3Qua2V5cyh0eXBlVGVzdHMpO1xuICAgIHZhciBpc1ZlY3RvclByb3AgPSBmdW5jdGlvbiAocHJvcCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wICE9PSB1bmRlZmluZWQgJiYgIXR5cGVUZXN0c1trZXldKHByb3ApO1xuICAgIH07XG4gICAgdmFyIGdldFZlY3RvcktleXMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRlc3ROYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHZlY3RvcktleXMsIGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVmVjdG9yUHJvcChwcm9wc1trZXldLCBrZXkpKSB2ZWN0b3JLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3JLZXlzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICB2YXIgdGVzdFZlY3RvclByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBwcm9wcyAmJiB0ZXN0TmFtZXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNWZWN0b3JQcm9wKHByb3BzW2tleV0sIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHsgZ2V0VmVjdG9yS2V5czogZ2V0VmVjdG9yS2V5cywgdGVzdFZlY3RvclByb3BzOiB0ZXN0VmVjdG9yUHJvcHMgfTtcbn07XG52YXIgdW5pdFR5cGVzID0gW3B4LCBwZXJjZW50LCBkZWdyZWVzLCB2aCwgdnddO1xudmFyIGZpbmRVbml0VHlwZSA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHVuaXRUeXBlcy5maW5kKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlLnRlc3QocHJvcCk7XG4gICAgfSk7XG59O1xudmFyIGlzVW5pdFByb3AgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBCb29sZWFuKGZpbmRVbml0VHlwZShwcm9wKSk7XG59O1xudmFyIGNyZWF0ZUFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIHByb3BzKSB7XG4gICAgcmV0dXJuIGFjdGlvbihwcm9wcyk7XG59O1xudmFyIGNyZWF0ZVVuaXRBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCBfYSkge1xuICAgIHZhciBmcm9tID0gX2EuZnJvbSxcbiAgICAgICAgdG8gPSBfYS50byxcbiAgICAgICAgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJ0b1wiXSk7XG4gICAgdmFyIHVuaXRUeXBlID0gZmluZFVuaXRUeXBlKGZyb20pIHx8IGZpbmRVbml0VHlwZSh0byk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHVuaXRUeXBlLnRyYW5zZm9ybSxcbiAgICAgICAgcGFyc2UgPSB1bml0VHlwZS5wYXJzZTtcbiAgICByZXR1cm4gYWN0aW9uKF9fYXNzaWduKHt9LCBwcm9wcywgeyBmcm9tOiB0eXBlb2YgZnJvbSA9PT0gJ3N0cmluZycgPyBwYXJzZShmcm9tKSA6IGZyb20sIHRvOiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2UodG8pIDogdG8gfSkpLnBpcGUodHJhbnNmb3JtKTtcbn07XG52YXIgY3JlYXRlTWl4ZXJBY3Rpb24gPSBmdW5jdGlvbiAobWl4ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbiwgX2EpIHtcbiAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLFxuICAgICAgICAgICAgdG8gPSBfYS50byxcbiAgICAgICAgICAgIHByb3BzID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwidG9cIl0pO1xuICAgICAgICByZXR1cm4gYWN0aW9uKF9fYXNzaWduKHt9LCBwcm9wcywgeyBmcm9tOiAwLCB0bzogMSB9KSkucGlwZShtaXhlcihmcm9tLCB0bykpO1xuICAgIH07XG59O1xudmFyIGNyZWF0ZUNvbG9yQWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU1peGVyQWN0aW9uKG1peENvbG9yKTtcbnZhciBjcmVhdGVDb21wbGV4QWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU1peGVyQWN0aW9uKG1peENvbXBsZXgpO1xudmFyIGNyZWF0ZVZlY3RvckFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIHR5cGVUZXN0cykge1xuICAgIHZhciBfYSA9IGNyZWF0ZVZlY3RvclRlc3RzKHR5cGVUZXN0cyksXG4gICAgICAgIHRlc3RWZWN0b3JQcm9wcyA9IF9hLnRlc3RWZWN0b3JQcm9wcyxcbiAgICAgICAgZ2V0VmVjdG9yS2V5cyA9IF9hLmdldFZlY3RvcktleXM7XG4gICAgdmFyIHZlY3RvckFjdGlvbiA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgaXNWZWN0b3IgPSB0ZXN0VmVjdG9yUHJvcHMocHJvcHMpO1xuICAgICAgICBpZiAoIWlzVmVjdG9yKSByZXR1cm4gYWN0aW9uKHByb3BzKTtcbiAgICAgICAgdmFyIHZlY3RvcktleXMgPSBnZXRWZWN0b3JLZXlzKHByb3BzKTtcbiAgICAgICAgdmFyIHRlc3RLZXkgPSB2ZWN0b3JLZXlzWzBdO1xuICAgICAgICB2YXIgdGVzdFByb3AgPSBwcm9wc1t0ZXN0S2V5XTtcbiAgICAgICAgcmV0dXJuIGdldEFjdGlvbkNyZWF0b3IodGVzdFByb3ApKGFjdGlvbiwgcHJvcHMsIHZlY3RvcktleXMpO1xuICAgIH07XG4gICAgcmV0dXJuIHZlY3RvckFjdGlvbjtcbn07XG52YXIgZ2V0QWN0aW9uQ3JlYXRvciA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlQWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNVbml0UHJvcChwcm9wKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVW5pdEFjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLnRlc3QocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbG9yQWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoY29tcGxleC50ZXN0KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wbGV4QWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBY3Rpb247XG4gICAgfVxufTtcblxudmFyIGRlY2F5ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gX2EuY29tcGxldGUsXG4gICAgICAgICAgICB1cGRhdGUgPSBfYS51cGRhdGU7XG4gICAgICAgIHZhciBfYiA9IHByb3BzLnZlbG9jaXR5LFxuICAgICAgICAgICAgdmVsb2NpdHkgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICAgICAgX2MgPSBwcm9wcy5mcm9tLFxuICAgICAgICAgICAgZnJvbSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgICAgICBfZCA9IHByb3BzLnBvd2VyLFxuICAgICAgICAgICAgcG93ZXIgPSBfZCA9PT0gdm9pZCAwID8gMC44IDogX2QsXG4gICAgICAgICAgICBfZSA9IHByb3BzLnRpbWVDb25zdGFudCxcbiAgICAgICAgICAgIHRpbWVDb25zdGFudCA9IF9lID09PSB2b2lkIDAgPyAzNTAgOiBfZSxcbiAgICAgICAgICAgIF9mID0gcHJvcHMucmVzdERlbHRhLFxuICAgICAgICAgICAgcmVzdERlbHRhID0gX2YgPT09IHZvaWQgMCA/IDAuNSA6IF9mLFxuICAgICAgICAgICAgbW9kaWZ5VGFyZ2V0ID0gcHJvcHMubW9kaWZ5VGFyZ2V0O1xuICAgICAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgICAgIHZhciBhbXBsaXR1ZGUgPSBwb3dlciAqIHZlbG9jaXR5O1xuICAgICAgICB2YXIgaWRlYWxUYXJnZXQgPSBNYXRoLnJvdW5kKGZyb20gKyBhbXBsaXR1ZGUpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIG1vZGlmeVRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyBpZGVhbFRhcmdldCA6IG1vZGlmeVRhcmdldChpZGVhbFRhcmdldCk7XG4gICAgICAgIHZhciBwcm9jZXNzID0gc3luYy51cGRhdGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWVEZWx0YSA9IF9hLmRlbHRhO1xuICAgICAgICAgICAgZWxhcHNlZCArPSBmcmFtZURlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gLWFtcGxpdHVkZSAqIE1hdGguZXhwKC1lbGFwc2VkIC8gdGltZUNvbnN0YW50KTtcbiAgICAgICAgICAgIHZhciBpc01vdmluZyA9IGRlbHRhID4gcmVzdERlbHRhIHx8IGRlbHRhIDwgLXJlc3REZWx0YTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaXNNb3ZpbmcgPyB0YXJnZXQgKyBkZWx0YSA6IHRhcmdldDtcbiAgICAgICAgICAgIHVwZGF0ZShjdXJyZW50KTtcbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZShwcm9jZXNzKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsU3luYy51cGRhdGUocHJvY2Vzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xudmFyIHZlY3RvckRlY2F5ID0gLyojX19QVVJFX18qL2NyZWF0ZVZlY3RvckFjdGlvbihkZWNheSwge1xuICAgIGZyb206IG51bWJlci50ZXN0LFxuICAgIG1vZGlmeVRhcmdldDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgdmVsb2NpdHk6IG51bWJlci50ZXN0XG59KTtcblxudmFyIHNwcmluZyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGUsXG4gICAgICAgICAgICBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlO1xuICAgICAgICB2YXIgX2IgPSBwcm9wcy52ZWxvY2l0eSxcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gX2IgPT09IHZvaWQgMCA/IDAuMCA6IF9iO1xuICAgICAgICB2YXIgX2MgPSBwcm9wcy5mcm9tLFxuICAgICAgICAgICAgZnJvbSA9IF9jID09PSB2b2lkIDAgPyAwLjAgOiBfYyxcbiAgICAgICAgICAgIF9kID0gcHJvcHMudG8sXG4gICAgICAgICAgICB0byA9IF9kID09PSB2b2lkIDAgPyAwLjAgOiBfZCxcbiAgICAgICAgICAgIF9lID0gcHJvcHMuc3RpZmZuZXNzLFxuICAgICAgICAgICAgc3RpZmZuZXNzID0gX2UgPT09IHZvaWQgMCA/IDEwMCA6IF9lLFxuICAgICAgICAgICAgX2YgPSBwcm9wcy5kYW1waW5nLFxuICAgICAgICAgICAgZGFtcGluZyA9IF9mID09PSB2b2lkIDAgPyAxMCA6IF9mLFxuICAgICAgICAgICAgX2cgPSBwcm9wcy5tYXNzLFxuICAgICAgICAgICAgbWFzcyA9IF9nID09PSB2b2lkIDAgPyAxLjAgOiBfZyxcbiAgICAgICAgICAgIF9oID0gcHJvcHMucmVzdFNwZWVkLFxuICAgICAgICAgICAgcmVzdFNwZWVkID0gX2ggPT09IHZvaWQgMCA/IDAuMDEgOiBfaCxcbiAgICAgICAgICAgIF9qID0gcHJvcHMucmVzdERlbHRhLFxuICAgICAgICAgICAgcmVzdERlbHRhID0gX2ogPT09IHZvaWQgMCA/IDAuMDEgOiBfajtcbiAgICAgICAgdmFyIGluaXRpYWxWZWxvY2l0eSA9IHZlbG9jaXR5ID8gLSh2ZWxvY2l0eSAvIDEwMDApIDogMC4wO1xuICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgIHZhciBkZWx0YSA9IHRvIC0gZnJvbTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZnJvbTtcbiAgICAgICAgdmFyIHByZXZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB2YXIgcHJvY2VzcyA9IHN5bmMudXBkYXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IF9hLmRlbHRhO1xuICAgICAgICAgICAgdCArPSB0aW1lRGVsdGE7XG4gICAgICAgICAgICB2YXIgZGFtcGluZ1JhdGlvID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgICAgICAgICAgIHZhciBhbmd1bGFyRnJlcSA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKSAvIDEwMDA7XG4gICAgICAgICAgICBwcmV2UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIGFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9EZWNheSA9IGFuZ3VsYXJGcmVxICogTWF0aC5zcXJ0KDEuMCAtIGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0byAtIGVudmVsb3BlICogKChpbml0aWFsVmVsb2NpdHkgKyBkYW1waW5nUmF0aW8gKiBhbmd1bGFyRnJlcSAqIGRlbHRhKSAvIGV4cG9EZWNheSAqIE1hdGguc2luKGV4cG9EZWNheSAqIHQpICsgZGVsdGEgKiBNYXRoLmNvcyhleHBvRGVjYXkgKiB0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlbnZlbG9wZSA9IE1hdGguZXhwKC1hbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdG8gLSBlbnZlbG9wZSAqIChkZWx0YSArIChpbml0aWFsVmVsb2NpdHkgKyBhbmd1bGFyRnJlcSAqIGRlbHRhKSAqIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZChwb3NpdGlvbiAtIHByZXZQb3NpdGlvbiwgdGltZURlbHRhKTtcbiAgICAgICAgICAgIHZhciBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyh2ZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICAgICAgdmFyIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSBNYXRoLmFicyh0byAtIHBvc2l0aW9uKSA8PSByZXN0RGVsdGE7XG4gICAgICAgICAgICBpZiAoaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRvO1xuICAgICAgICAgICAgICAgIHVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3luYy51cGRhdGUocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFN5bmMudXBkYXRlKHByb2Nlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcbnZhciB2ZWN0b3JTcHJpbmcgPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKHNwcmluZywge1xuICAgIGZyb206IG51bWJlci50ZXN0LFxuICAgIHRvOiBudW1iZXIudGVzdCxcbiAgICBzdGlmZm5lc3M6IG51bWJlci50ZXN0LFxuICAgIGRhbXBpbmc6IG51bWJlci50ZXN0LFxuICAgIG1hc3M6IG51bWJlci50ZXN0LFxuICAgIHZlbG9jaXR5OiBudW1iZXIudGVzdFxufSk7XG5cbnZhciBpbmVydGlhID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuZnJvbSxcbiAgICAgICAgZnJvbSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgIF9jID0gX2EudmVsb2NpdHksXG4gICAgICAgIHZlbG9jaXR5ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgbWluID0gX2EubWluLFxuICAgICAgICBtYXggPSBfYS5tYXgsXG4gICAgICAgIF9kID0gX2EucG93ZXIsXG4gICAgICAgIHBvd2VyID0gX2QgPT09IHZvaWQgMCA/IDAuOCA6IF9kLFxuICAgICAgICBfZSA9IF9hLnRpbWVDb25zdGFudCxcbiAgICAgICAgdGltZUNvbnN0YW50ID0gX2UgPT09IHZvaWQgMCA/IDcwMCA6IF9lLFxuICAgICAgICBfZiA9IF9hLmJvdW5jZVN0aWZmbmVzcyxcbiAgICAgICAgYm91bmNlU3RpZmZuZXNzID0gX2YgPT09IHZvaWQgMCA/IDUwMCA6IF9mLFxuICAgICAgICBfZyA9IF9hLmJvdW5jZURhbXBpbmcsXG4gICAgICAgIGJvdW5jZURhbXBpbmcgPSBfZyA9PT0gdm9pZCAwID8gMTAgOiBfZyxcbiAgICAgICAgX2ggPSBfYS5yZXN0RGVsdGEsXG4gICAgICAgIHJlc3REZWx0YSA9IF9oID09PSB2b2lkIDAgPyAxIDogX2gsXG4gICAgICAgIG1vZGlmeVRhcmdldCA9IF9hLm1vZGlmeVRhcmdldDtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlLFxuICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIHByZXYgPSBmcm9tO1xuICAgICAgICB2YXIgY3VycmVudCA9IGZyb207XG4gICAgICAgIHZhciBhY3RpdmVBbmltYXRpb247XG4gICAgICAgIHZhciBpc1NwcmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNMZXNzVGhhbk1pbiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gbWluICE9PSB1bmRlZmluZWQgJiYgdiA8PSBtaW47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc01vcmVUaGFuTWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXggIT09IHVuZGVmaW5lZCAmJiB2ID49IG1heDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzT3V0T2ZCb3VuZHMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVzc1RoYW5NaW4odikgfHwgaXNNb3JlVGhhbk1heCh2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzVHJhdmVsbGluZ0F3YXlGcm9tQm91bmRzID0gZnVuY3Rpb24gKHYsIGN1cnJlbnRWZWxvY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVzc1RoYW5NaW4odikgJiYgY3VycmVudFZlbG9jaXR5IDwgMCB8fCBpc01vcmVUaGFuTWF4KHYpICYmIGN1cnJlbnRWZWxvY2l0eSA+IDA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblVwZGF0ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB1cGRhdGUodik7XG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZChjdXJyZW50IC0gcHJldiwgZ2V0RnJhbWVEYXRhKCkuZGVsdGEpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUFuaW1hdGlvbiAmJiAhaXNTcHJpbmcgJiYgaXNUcmF2ZWxsaW5nQXdheUZyb21Cb3VuZHModiwgdmVsb2NpdHkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tOiB2LCB2ZWxvY2l0eTogdmVsb2NpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24sIG5leHQpIHtcbiAgICAgICAgICAgIGFjdGl2ZUFuaW1hdGlvbiAmJiBhY3RpdmVBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgYWN0aXZlQW5pbWF0aW9uID0gYW5pbWF0aW9uLnN0YXJ0KHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0U3ByaW5nID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICBpc1NwcmluZyA9IHRydWU7XG4gICAgICAgICAgICBzdGFydEFuaW1hdGlvbih2ZWN0b3JTcHJpbmcoX19hc3NpZ24oe30sIHByb3BzLCB7IHRvOiBpc0xlc3NUaGFuTWluKHByb3BzLmZyb20pID8gbWluIDogbWF4LCBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgZGFtcGluZzogYm91bmNlRGFtcGluZywgcmVzdERlbHRhOiByZXN0RGVsdGEgfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICAgICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbTogZnJvbSwgdmVsb2NpdHk6IHZlbG9jaXR5IH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZlbG9jaXR5ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdmVjdG9yRGVjYXkoe1xuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIHRpbWVDb25zdGFudDogdGltZUNvbnN0YW50LFxuICAgICAgICAgICAgICAgIHBvd2VyOiBwb3dlcixcbiAgICAgICAgICAgICAgICByZXN0RGVsdGE6IGlzT3V0T2ZCb3VuZHMoZnJvbSkgPyAyMCA6IHJlc3REZWx0YSxcbiAgICAgICAgICAgICAgICBtb2RpZnlUYXJnZXQ6IG1vZGlmeVRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGFydEFuaW1hdGlvbihhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPdXRPZkJvdW5kcyhjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFNwcmluZyh7IGZyb206IGN1cnJlbnQsIHZlbG9jaXR5OiB2ZWxvY2l0eSB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVBbmltYXRpb24gJiYgYWN0aXZlQW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKGluZXJ0aWEsIHtcbiAgICBmcm9tOiBudW1iZXIudGVzdCxcbiAgICB2ZWxvY2l0eTogbnVtYmVyLnRlc3QsXG4gICAgbWluOiBudW1iZXIudGVzdCxcbiAgICBtYXg6IG51bWJlci50ZXN0LFxuICAgIGRhbXBpbmc6IG51bWJlci50ZXN0LFxuICAgIHN0aWZmbmVzczogbnVtYmVyLnRlc3QsXG4gICAgbW9kaWZ5VGFyZ2V0OiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG4gICAgfVxufSk7XG5cbnZhciBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlO1xuICAgICAgICB2YXIgaW5pdGlhbFRpbWUgPSAwO1xuICAgICAgICB2YXIgcHJvY2VzcyA9IHN5bmMudXBkYXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFRpbWUpIGluaXRpYWxUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgdXBkYXRlKHRpbWVzdGFtcCAtIGluaXRpYWxUaW1lKTtcbiAgICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFN5bmMudXBkYXRlKHByb2Nlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIHNjcnViYmVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuZnJvbSxcbiAgICAgICAgZnJvbSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgIF9jID0gX2EudG8sXG4gICAgICAgIHRvID0gX2MgPT09IHZvaWQgMCA/IDEgOiBfYyxcbiAgICAgICAgX2QgPSBfYS5lYXNlLFxuICAgICAgICBlYXNlID0gX2QgPT09IHZvaWQgMCA/IGxpbmVhciA6IF9kLFxuICAgICAgICBfZSA9IF9hLnJldmVyc2VFYXNlLFxuICAgICAgICByZXZlcnNlRWFzZSA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lO1xuICAgIGlmIChyZXZlcnNlRWFzZSkge1xuICAgICAgICBlYXNlID0gY3JlYXRlUmV2ZXJzZWRFYXNpbmcoZWFzZSk7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWVrOiBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KS5waXBlKGVhc2UsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBtaXgoZnJvbSwgdG8sIHYpO1xuICAgIH0pO1xufTtcbnZhciB2ZWN0b3JTY3J1YmJlciA9IC8qI19fUFVSRV9fKi9jcmVhdGVWZWN0b3JBY3Rpb24oc2NydWJiZXIsIHtcbiAgICBlYXNlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBmcm9tOiBudW1iZXIudGVzdCxcbiAgICB0bzogbnVtYmVyLnRlc3Rcbn0pO1xuXG52YXIgY2xhbXBQcm9ncmVzcyA9IC8qI19fUFVSRV9fKi9jbGFtcCgwLCAxKTtcbnZhciB0d2VlbiA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGUsXG4gICAgICAgICAgICBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlO1xuICAgICAgICB2YXIgX2IgPSBwcm9wcy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uID0gX2IgPT09IHZvaWQgMCA/IDMwMCA6IF9iLFxuICAgICAgICAgICAgX2MgPSBwcm9wcy5lYXNlLFxuICAgICAgICAgICAgZWFzZSA9IF9jID09PSB2b2lkIDAgPyBlYXNlT3V0IDogX2MsXG4gICAgICAgICAgICBfZCA9IHByb3BzLmZsaXAsXG4gICAgICAgICAgICBmbGlwID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCxcbiAgICAgICAgICAgIF9lID0gcHJvcHMubG9vcCxcbiAgICAgICAgICAgIGxvb3AgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lLFxuICAgICAgICAgICAgX2YgPSBwcm9wcy55b3lvLFxuICAgICAgICAgICAgeW95byA9IF9mID09PSB2b2lkIDAgPyAwIDogX2YsXG4gICAgICAgICAgICBfZyA9IHByb3BzLnJlcGVhdERlbGF5LFxuICAgICAgICAgICAgcmVwZWF0RGVsYXkgPSBfZyA9PT0gdm9pZCAwID8gMCA6IF9nO1xuICAgICAgICB2YXIgX2ggPSBwcm9wcy5mcm9tLFxuICAgICAgICAgICAgZnJvbSA9IF9oID09PSB2b2lkIDAgPyAwIDogX2gsXG4gICAgICAgICAgICBfaiA9IHByb3BzLnRvLFxuICAgICAgICAgICAgdG8gPSBfaiA9PT0gdm9pZCAwID8gMSA6IF9qLFxuICAgICAgICAgICAgX2sgPSBwcm9wcy5lbGFwc2VkLFxuICAgICAgICAgICAgZWxhcHNlZCA9IF9rID09PSB2b2lkIDAgPyAwIDogX2ssXG4gICAgICAgICAgICBfbCA9IHByb3BzLmZsaXBDb3VudCxcbiAgICAgICAgICAgIGZsaXBDb3VudCA9IF9sID09PSB2b2lkIDAgPyAwIDogX2wsXG4gICAgICAgICAgICBfbSA9IHByb3BzLnlveW9Db3VudCxcbiAgICAgICAgICAgIHlveW9Db3VudCA9IF9tID09PSB2b2lkIDAgPyAwIDogX20sXG4gICAgICAgICAgICBfbyA9IHByb3BzLmxvb3BDb3VudCxcbiAgICAgICAgICAgIGxvb3BDb3VudCA9IF9vID09PSB2b2lkIDAgPyAwIDogX287XG4gICAgICAgIHZhciBwbGF5aGVhZCA9IHZlY3RvclNjcnViYmVyKHsgZnJvbTogZnJvbSwgdG86IHRvLCBlYXNlOiBlYXNlIH0pLnN0YXJ0KHVwZGF0ZSk7XG4gICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3MgPSAwO1xuICAgICAgICB2YXIgcHJvY2VzcztcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHZhciByZXZlcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKHJldmVyc2VFYXNlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZUVhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldmVyc2VFYXNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYSA9IFt0bywgZnJvbV0sIGZyb20gPSBfYVswXSwgdG8gPSBfYVsxXTtcbiAgICAgICAgICAgIHBsYXloZWFkID0gdmVjdG9yU2NydWJiZXIoeyBmcm9tOiBmcm9tLCB0bzogdG8sIGVhc2U6IGVhc2UsIHJldmVyc2VFYXNlOiByZXZlcnNlRWFzZSB9KS5zdGFydCh1cGRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNUd2VlbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlzQ29tcGxldGUgPSBpc0FjdGl2ZSAmJiBlbGFwc2VkID4gZHVyYXRpb24gKyByZXBlYXREZWxheTtcbiAgICAgICAgICAgIGlmICghaXNDb21wbGV0ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUgJiYgIWxvb3AgJiYgIWZsaXAgJiYgIXlveW8pIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIG92ZXJ0aW1lID0gZWxhcHNlZCAtIGR1cmF0aW9uO1xuICAgICAgICAgICAgZWxhcHNlZCA9IG92ZXJ0aW1lIC0gcmVwZWF0RGVsYXk7XG4gICAgICAgICAgICBpZiAobG9vcCAmJiBsb29wQ291bnQgPCBsb29wKSB7XG4gICAgICAgICAgICAgICAgbG9vcENvdW50Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmbGlwICYmIGZsaXBDb3VudCA8IGZsaXApIHtcbiAgICAgICAgICAgICAgICBmbGlwQ291bnQrKztcbiAgICAgICAgICAgICAgICByZXZlcnNlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5b3lvICYmIHlveW9Db3VudCA8IHlveW8pIHtcbiAgICAgICAgICAgICAgICB5b3lvQ291bnQrKztcbiAgICAgICAgICAgICAgICByZXZlcnNlQW5pbWF0aW9uKHlveW9Db3VudCAlIDIgIT09IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdXBkYXRlVHdlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSBjbGFtcFByb2dyZXNzKHByb2dyZXNzKDAsIGR1cmF0aW9uLCBlbGFwc2VkKSk7XG4gICAgICAgICAgICBwbGF5aGVhZC5zZWVrKGN1cnJlbnRQcm9ncmVzcyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcHJvY2VzcyA9IHN5bmMudXBkYXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IF9hLmRlbHRhO1xuICAgICAgICAgICAgICAgIGVsYXBzZWQgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgdXBkYXRlVHdlZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUd2VlbkNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsU3luYy51cGRhdGUocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlICYmIHN5bmMudXBkYXRlKGNvbXBsZXRlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdG9wVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MpIGNhbmNlbFN5bmMudXBkYXRlKHByb2Nlc3MpO1xuICAgICAgICB9O1xuICAgICAgICBzdGFydFRpbWVyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FjdGl2ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbGFwc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYW1wKDAsIGR1cmF0aW9uLCBlbGFwc2VkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQcm9ncmVzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3BUaW1lcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FjdGl2ZSkgc3RhcnRUaW1lcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIChuZXdQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWQgPSBtaXgoMCwgZHVyYXRpb24sIG5ld1Byb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBzeW5jLnVwZGF0ZSh1cGRhdGVUd2VlbiwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG52YXIgY2xhbXBQcm9ncmVzcyQxID0gLyojX19QVVJFX18qL2NsYW1wKDAsIDEpO1xudmFyIGRlZmF1bHRFYXNpbmdzID0gZnVuY3Rpb24gKHZhbHVlcywgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZWFzaW5nIHx8IGVhc2VPdXQ7XG4gICAgfSkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn07XG52YXIgZGVmYXVsdFRpbWluZ3MgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHJldHVybiBpICE9PSAwID8gaSAvIChudW1WYWx1ZXMgLSAxKSA6IDA7XG4gICAgfSk7XG59O1xudmFyIGludGVycG9sYXRlU2NydWJiZXJzID0gZnVuY3Rpb24gKGlucHV0LCBzY3J1YmJlcnMsIHVwZGF0ZSkge1xuICAgIHZhciByYW5nZUxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgZmluYWxJbnB1dEluZGV4ID0gcmFuZ2VMZW5ndGggLSAxO1xuICAgIHZhciBmaW5hbFNjcnViYmVySW5kZXggPSBmaW5hbElucHV0SW5kZXggLSAxO1xuICAgIHZhciBzdWJzID0gc2NydWJiZXJzLm1hcChmdW5jdGlvbiAoc2NydWIpIHtcbiAgICAgICAgcmV0dXJuIHNjcnViLnN0YXJ0KHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XG4gICAgICAgICAgICBzdWJzWzBdLnNlZWsoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPj0gaW5wdXRbZmluYWxJbnB1dEluZGV4XSkge1xuICAgICAgICAgICAgc3Vic1tmaW5hbFNjcnViYmVySW5kZXhdLnNlZWsoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICBmb3IgKDsgaSA8IHJhbmdlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnB1dFtpXSA+IHYgfHwgaSA9PT0gZmluYWxJbnB1dEluZGV4KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbaSAtIDFdLCBpbnB1dFtpXSwgdik7XG4gICAgICAgIHN1YnNbaSAtIDFdLnNlZWsoY2xhbXBQcm9ncmVzcyQxKHByb2dyZXNzSW5SYW5nZSkpO1xuICAgIH07XG59O1xudmFyIGtleWZyYW1lcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBlYXNpbmdzID0gX2EuZWFzaW5ncyxcbiAgICAgICAgX2IgPSBfYS5lYXNlLFxuICAgICAgICBlYXNlID0gX2IgPT09IHZvaWQgMCA/IGxpbmVhciA6IF9iLFxuICAgICAgICB0aW1lcyA9IF9hLnRpbWVzLFxuICAgICAgICB2YWx1ZXMgPSBfYS52YWx1ZXMsXG4gICAgICAgIHR3ZWVuUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImVhc2luZ3NcIiwgXCJlYXNlXCIsIFwidGltZXNcIiwgXCJ2YWx1ZXNcIl0pO1xuICAgIGVhc2luZ3MgPSBBcnJheS5pc0FycmF5KGVhc2luZ3MpID8gZWFzaW5ncyA6IGRlZmF1bHRFYXNpbmdzKHZhbHVlcywgZWFzaW5ncyk7XG4gICAgdGltZXMgPSB0aW1lcyB8fCBkZWZhdWx0VGltaW5ncyh2YWx1ZXMpO1xuICAgIHZhciBzY3J1YmJlcnMgPSBlYXNpbmdzLm1hcChmdW5jdGlvbiAoZWFzaW5nLCBpKSB7XG4gICAgICAgIHJldHVybiB2ZWN0b3JTY3J1YmJlcih7XG4gICAgICAgICAgICBmcm9tOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICB0bzogdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgICAgIGVhc2U6IGVhc2luZ1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHdlZW4oX19hc3NpZ24oe30sIHR3ZWVuUHJvcHMsIHsgZWFzZTogZWFzZSB9KSkuYXBwbHlNaWRkbGV3YXJlKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU2NydWJiZXJzKHRpbWVzLCBzY3J1YmJlcnMsIHVwZGF0ZSk7XG4gICAgfSk7XG59O1xuXG52YXIgcGh5c2ljcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlLFxuICAgICAgICAgICAgdXBkYXRlID0gX2EudXBkYXRlO1xuICAgICAgICB2YXIgX2IgPSBwcm9wcy5hY2NlbGVyYXRpb24sXG4gICAgICAgICAgICBhY2NlbGVyYXRpb24gPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICAgICAgX2MgPSBwcm9wcy5mcmljdGlvbixcbiAgICAgICAgICAgIGZyaWN0aW9uID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgICAgIF9kID0gcHJvcHMudmVsb2NpdHksXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsXG4gICAgICAgICAgICBzcHJpbmdTdHJlbmd0aCA9IHByb3BzLnNwcmluZ1N0cmVuZ3RoLFxuICAgICAgICAgICAgdG8gPSBwcm9wcy50bztcbiAgICAgICAgdmFyIF9lID0gcHJvcHMucmVzdFNwZWVkLFxuICAgICAgICAgICAgcmVzdFNwZWVkID0gX2UgPT09IHZvaWQgMCA/IDAuMDAxIDogX2UsXG4gICAgICAgICAgICBfZiA9IHByb3BzLmZyb20sXG4gICAgICAgICAgICBmcm9tID0gX2YgPT09IHZvaWQgMCA/IDAgOiBfZjtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmcm9tO1xuICAgICAgICB2YXIgcHJvY2VzcyA9IHN5bmMudXBkYXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gX2EuZGVsdGE7XG4gICAgICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGgubWF4KGRlbHRhLCAxNik7XG4gICAgICAgICAgICBpZiAoYWNjZWxlcmF0aW9uKSB2ZWxvY2l0eSArPSB2ZWxvY2l0eVBlckZyYW1lKGFjY2VsZXJhdGlvbiwgZWxhcHNlZCk7XG4gICAgICAgICAgICBpZiAoZnJpY3Rpb24pIHZlbG9jaXR5ICo9IE1hdGgucG93KDEgLSBmcmljdGlvbiwgZWxhcHNlZCAvIDEwMCk7XG4gICAgICAgICAgICBpZiAoc3ByaW5nU3RyZW5ndGggIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlVG9UYXJnZXQgPSB0byAtIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKz0gZGlzdGFuY2VUb1RhcmdldCAqIHZlbG9jaXR5UGVyRnJhbWUoc3ByaW5nU3RyZW5ndGgsIGVsYXBzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCArPSB2ZWxvY2l0eVBlckZyYW1lKHZlbG9jaXR5LCBlbGFwc2VkKTtcbiAgICAgICAgICAgIHVwZGF0ZShjdXJyZW50KTtcbiAgICAgICAgICAgIHZhciBpc0NvbXBsZXRlID0gcmVzdFNwZWVkICE9PSBmYWxzZSAmJiAoIXZlbG9jaXR5IHx8IE1hdGguYWJzKHZlbG9jaXR5KSA8PSByZXN0U3BlZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZShwcm9jZXNzKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBY2NlbGVyYXRpb246IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRGcmljdGlvbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBmcmljdGlvbiA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U3ByaW5nU3RyZW5ndGg6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgc3ByaW5nU3RyZW5ndGggPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFNwcmluZ1RhcmdldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0byA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0VmVsb2NpdHk6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsU3luYy51cGRhdGUocHJvY2Vzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xudmFyIHZlY3RvclBoeXNpY3MgPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKHBoeXNpY3MsIHtcbiAgICBhY2NlbGVyYXRpb246IG51bWJlci50ZXN0LFxuICAgIGZyaWN0aW9uOiBudW1iZXIudGVzdCxcbiAgICB2ZWxvY2l0eTogbnVtYmVyLnRlc3QsXG4gICAgZnJvbTogbnVtYmVyLnRlc3QsXG4gICAgdG86IG51bWJlci50ZXN0LFxuICAgIHNwcmluZ1N0cmVuZ3RoOiBudW1iZXIudGVzdFxufSk7XG5cbnZhciBtdWx0aSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBnZXRDb3VudCA9IF9hLmdldENvdW50LFxuICAgICAgICBnZXRGaXJzdCA9IF9hLmdldEZpcnN0LFxuICAgICAgICBnZXRPdXRwdXQgPSBfYS5nZXRPdXRwdXQsXG4gICAgICAgIG1hcEFwaSA9IF9hLm1hcEFwaSxcbiAgICAgICAgc2V0UHJvcCA9IF9hLnNldFByb3AsXG4gICAgICAgIHN0YXJ0QWN0aW9ucyA9IF9hLnN0YXJ0QWN0aW9ucztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGUsXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICBlcnJvciA9IF9hLmVycm9yO1xuICAgICAgICAgICAgdmFyIG51bUFjdGlvbnMgPSBnZXRDb3VudChhY3Rpb25zKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBnZXRPdXRwdXQoKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShvdXRwdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBudW1Db21wbGV0ZWRBY3Rpb25zID0gMDtcbiAgICAgICAgICAgIHZhciBzdWJzID0gc3RhcnRBY3Rpb25zKGFjdGlvbnMsIGZ1bmN0aW9uIChhLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Db21wbGV0ZWRBY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUNvbXBsZXRlZEFjdGlvbnMgPT09IG51bUFjdGlvbnMpIHN5bmMudXBkYXRlKGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG91dHB1dCwgbmFtZSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jLnVwZGF0ZSh1cGRhdGVPdXRwdXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZ2V0Rmlyc3Qoc3VicykpLnJlZHVjZShmdW5jdGlvbiAoYXBpLCBtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgYXBpW21ldGhvZE5hbWVdID0gbWFwQXBpKHN1YnMsIG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG52YXIgY29tcG9zaXRlID0gLyojX19QVVJFX18qL211bHRpKHtcbiAgICBnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uIChzdWJzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdWJzKS5sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRGaXJzdDogZnVuY3Rpb24gKHN1YnMpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNbT2JqZWN0LmtleXMoc3VicylbMF1dO1xuICAgIH0sXG4gICAgbWFwQXBpOiBmdW5jdGlvbiAoc3VicywgbWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN1YnMpLnJlZHVjZShmdW5jdGlvbiAob3V0cHV0LCBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzW3Byb3BLZXldW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gJiYgYXJnc1swXVtwcm9wS2V5XSAhPT0gdW5kZWZpbmVkID8gb3V0cHV0W3Byb3BLZXldID0gc3Vic1twcm9wS2V5XVttZXRob2ROYW1lXShhcmdzWzBdW3Byb3BLZXldKSA6IG91dHB1dFtwcm9wS2V5XSA9IChfYSA9IHN1YnNbcHJvcEtleV0pW21ldGhvZE5hbWVdLmFwcGx5KF9hLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNldFByb3A6IGZ1bmN0aW9uIChvdXRwdXQsIG5hbWUsIHYpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dFtuYW1lXSA9IHY7XG4gICAgfSxcbiAgICBzdGFydEFjdGlvbnM6IGZ1bmN0aW9uIChhY3Rpb25zLCBzdGFydGVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhY3Rpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKHN1YnMsIGtleSkge1xuICAgICAgICAgICAgc3Vic1trZXldID0gc3RhcnRlcihhY3Rpb25zW2tleV0sIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gc3VicztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbn0pO1xuXG52YXIgREVGQVVMVF9EVVJBVElPTiA9IDMwMDtcbnZhciBmbGF0dGVuVGltaW5ncyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbnMpIHtcbiAgICB2YXIgZmxhdEluc3RydWN0aW9ucyA9IFtdO1xuICAgIHZhciBsYXN0QXJnID0gaW5zdHJ1Y3Rpb25zW2luc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaXNTdGFnZ2VyZWQgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ251bWJlcic7XG4gICAgdmFyIHN0YWdnZXJEZWxheSA9IGlzU3RhZ2dlcmVkID8gbGFzdEFyZyA6IDA7XG4gICAgdmFyIHNlZ21lbnRzID0gaXNTdGFnZ2VyZWQgPyBpbnN0cnVjdGlvbnMuc2xpY2UoMCwgLTEpIDogaW5zdHJ1Y3Rpb25zO1xuICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGZsYXRJbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IG51bVNlZ21lbnRzIC0gMSkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gaXRlbS5kdXJhdGlvbiB8fCBERUZBVUxUX0RVUkFUSU9OO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YWdnZXJEZWxheTtcbiAgICAgICAgICAgIGZsYXRJbnN0cnVjdGlvbnMucHVzaChcIi1cIiArIChkdXJhdGlvbiAtIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZsYXRJbnN0cnVjdGlvbnM7XG59O1xudmFyIGZsYXR0ZW5BcnJheUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKSB7XG4gICAgQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbikgPyBpbnN0cnVjdGlvbnMucHVzaC5hcHBseShpbnN0cnVjdGlvbnMsIGZsYXR0ZW5UaW1pbmdzKGluc3RydWN0aW9uKSkgOiBpbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbn07XG52YXIgY29udmVydERlZlRvUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGRlZiwgaSkge1xuICAgIHZhciBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdzID0gcHJvcHMuZWFzaW5ncyxcbiAgICAgICAgdGltZXMgPSBwcm9wcy50aW1lcyxcbiAgICAgICAgdmFsdWVzID0gcHJvcHMudmFsdWVzO1xuICAgIHZhciBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2VGltZVRvID0gdGltZXNbbnVtVmFsdWVzIC0gMV07XG4gICAgdmFyIHRpbWVGcm9tID0gZGVmLmF0ID09PSAwID8gMCA6IGRlZi5hdCAvIGR1cmF0aW9uO1xuICAgIHZhciB0aW1lVG8gPSAoZGVmLmF0ICsgZGVmLmR1cmF0aW9uKSAvIGR1cmF0aW9uO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGRlZi5mcm9tKTtcbiAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZUaW1lVG8gIT09IHRpbWVGcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlc1tudW1WYWx1ZXMgLSAxXSk7XG4gICAgICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgICAgICAgICAgICAgZWFzaW5ncy5wdXNoKGxpbmVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbSA9IGRlZi5mcm9tICE9PSB1bmRlZmluZWQgPyBkZWYuZnJvbSA6IHZhbHVlc1tudW1WYWx1ZXMgLSAxXTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGZyb20pO1xuICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgICAgICAgICBlYXNpbmdzLnB1c2gobGluZWFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkZWYuZnJvbSk7XG4gICAgICAgICAgICB0aW1lcy5wdXNoKHRpbWVGcm9tKTtcbiAgICAgICAgICAgIGVhc2luZ3MucHVzaChsaW5lYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcy5wdXNoKGRlZi50byk7XG4gICAgdGltZXMucHVzaCh0aW1lVG8pO1xuICAgIGVhc2luZ3MucHVzaChkZWYuZWFzZSB8fCBlYXNlSW5PdXQpO1xuICAgIHJldHVybiBwcm9wcztcbn07XG52YXIgdGltZWxpbmUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb25zLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBkdXJhdGlvbiA9IF9iLmR1cmF0aW9uLFxuICAgICAgICBlbGFwc2VkID0gX2IuZWxhcHNlZCxcbiAgICAgICAgZWFzZSA9IF9iLmVhc2UsXG4gICAgICAgIGxvb3AgPSBfYi5sb29wLFxuICAgICAgICBmbGlwID0gX2IuZmxpcCxcbiAgICAgICAgeW95byA9IF9iLnlveW87XG4gICAgdmFyIHBsYXloZWFkID0gMDtcbiAgICB2YXIgY2FsY3VsYXRlZER1cmF0aW9uID0gMDtcbiAgICB2YXIgZmxhdEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5yZWR1Y2UoZmxhdHRlbkFycmF5SW5zdHJ1Y3Rpb25zLCBbXSk7XG4gICAgdmFyIGFuaW1hdGlvbkRlZnMgPSBbXTtcbiAgICBmbGF0SW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwbGF5aGVhZCArPSBwYXJzZUZsb2F0KGluc3RydWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwbGF5aGVhZCA9IGluc3RydWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlZiA9IF9fYXNzaWduKHt9LCBpbnN0cnVjdGlvbiwgeyBhdDogcGxheWhlYWQgfSk7XG4gICAgICAgICAgICBkZWYuZHVyYXRpb24gPSBkZWYuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfRFVSQVRJT04gOiBkZWYuZHVyYXRpb247XG4gICAgICAgICAgICBhbmltYXRpb25EZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgIHBsYXloZWFkICs9IGRlZi5kdXJhdGlvbjtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbiA9IE1hdGgubWF4KGNhbGN1bGF0ZWREdXJhdGlvbiwgZGVmLmF0ICsgZGVmLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICB2YXIgbnVtRGVmcyA9IGFuaW1hdGlvbkRlZnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGVmczsgaSsrKSB7XG4gICAgICAgIHZhciBkZWYgPSBhbmltYXRpb25EZWZzW2ldO1xuICAgICAgICB2YXIgdHJhY2sgPSBkZWYudHJhY2s7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYWNrIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrcy5oYXNPd25Qcm9wZXJ0eSh0cmFjaykpIHRyYWNrc1t0cmFja10gPSBbXTtcbiAgICAgICAgdHJhY2tzW3RyYWNrXS5wdXNoKGRlZik7XG4gICAgfVxuICAgIHZhciB0cmFja0tleWZyYW1lcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0cmFja3MpIHtcbiAgICAgICAgaWYgKHRyYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5ZnJhbWVQcm9wcyA9IHRyYWNrc1trZXldLnJlZHVjZShjb252ZXJ0RGVmVG9Qcm9wcywge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBjYWxjdWxhdGVkRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgZWFzaW5nczogW10sXG4gICAgICAgICAgICAgICAgdGltZXM6IFtdLFxuICAgICAgICAgICAgICAgIHZhbHVlczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tLZXlmcmFtZXNba2V5XSA9IGtleWZyYW1lcyhfX2Fzc2lnbih7fSwga2V5ZnJhbWVQcm9wcywgeyBkdXJhdGlvbjogZHVyYXRpb24gfHwgY2FsY3VsYXRlZER1cmF0aW9uLCBlYXNlOiBlYXNlLFxuICAgICAgICAgICAgICAgIGVsYXBzZWQ6IGVsYXBzZWQsXG4gICAgICAgICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICAgICAgICB5b3lvOiB5b3lvLFxuICAgICAgICAgICAgICAgIGZsaXA6IGZsaXAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb3NpdGUodHJhY2tLZXlmcmFtZXMpO1xufTtcblxudmFyIGxpc3RlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlO1xuICAgICAgICB2YXIgZXZlbnROYW1lcyA9IGV2ZW50cy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB1cGRhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB1cGRhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIGRlZmF1bHRQb2ludGVyUG9zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgIGNsaWVudFk6IDAsXG4gICAgICAgIHBhZ2VYOiAwLFxuICAgICAgICBwYWdlWTogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgIH07XG59O1xudmFyIGV2ZW50VG9Qb2ludCA9IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICAgIGlmIChwb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBvaW50ID0gZGVmYXVsdFBvaW50ZXJQb3MoKTtcbiAgICB9XG4gICAgcG9pbnQuY2xpZW50WCA9IHBvaW50LnggPSBlLmNsaWVudFg7XG4gICAgcG9pbnQuY2xpZW50WSA9IHBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgcG9pbnQucGFnZVggPSBlLnBhZ2VYO1xuICAgIHBvaW50LnBhZ2VZID0gZS5wYWdlWTtcbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG52YXIgcG9pbnRzID0gWy8qI19fUFVSRV9fKi9kZWZhdWx0UG9pbnRlclBvcygpXTtcbnZhciBpc1RvdWNoRGV2aWNlID0gZmFsc2U7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1cGRhdGVQb2ludHNMb2NhdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IF9hLnRvdWNoZXM7XG4gICAgICAgIGlzVG91Y2hEZXZpY2UgPSB0cnVlO1xuICAgICAgICB2YXIgbnVtVG91Y2hlcyA9IHRvdWNoZXMubGVuZ3RoO1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ub3VjaGVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aGlzVG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goZXZlbnRUb1BvaW50KHRoaXNUb3VjaCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0IHRvdWNobW92ZScsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLnN0YXJ0KHVwZGF0ZVBvaW50c0xvY2F0aW9uKTtcbn1cbnZhciBtdWx0aXRvdWNoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICAgIF9jID0gX2IucHJldmVudERlZmF1bHQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYyxcbiAgICAgICAgX2QgPSBfYi5zY2FsZSxcbiAgICAgICAgc2NhbGUgPSBfZCA9PT0gdm9pZCAwID8gMS4wIDogX2QsXG4gICAgICAgIF9lID0gX2Iucm90YXRlLFxuICAgICAgICByb3RhdGUgPSBfZSA9PT0gdm9pZCAwID8gMC4wIDogX2U7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIHRvdWNoZXM6IHBvaW50cyxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIHJvdGF0ZTogcm90YXRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbml0aWFsRGlzdGFuY2UgPSAwLjA7XG4gICAgICAgIHZhciBpbml0aWFsUm90YXRpb24gPSAwLjA7XG4gICAgICAgIHZhciBpc0dlc3R1cmUgPSBwb2ludHMubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKGlzR2VzdHVyZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0VG91Y2ggPSBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgc2Vjb25kVG91Y2ggPSBwb2ludHNbMV07XG4gICAgICAgICAgICBpbml0aWFsRGlzdGFuY2UgPSBkaXN0YW5jZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgICAgICBpbml0aWFsUm90YXRpb24gPSBhbmdsZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzR2VzdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFRvdWNoID0gcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb3VjaCA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JvdGF0aW9uID0gYW5nbGUoZmlyc3RUb3VjaCwgc2Vjb25kVG91Y2gpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zY2FsZSA9IHNjYWxlICogKG5ld0Rpc3RhbmNlIC8gaW5pdGlhbERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucm90YXRlID0gcm90YXRlICsgKG5ld1JvdGF0aW9uIC0gaW5pdGlhbFJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZShvdXRwdXQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc3luYy51cGRhdGUodXBkYXRlUG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdXBkYXRlT25Nb3ZlID0gbGlzdGVuKGRvY3VtZW50LCAndG91Y2htb3ZlJywge1xuICAgICAgICAgICAgcGFzc2l2ZTogIXByZXZlbnREZWZhdWx0XG4gICAgICAgIH0pLnN0YXJ0KG9uTW92ZSk7XG4gICAgICAgIGlmIChpc1RvdWNoRGV2aWNlKSBzeW5jLnVwZGF0ZSh1cGRhdGVQb2ludCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodXBkYXRlUG9pbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU9uTW92ZS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xudmFyIGdldElzVG91Y2hEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzVG91Y2hEZXZpY2U7XG59O1xuXG52YXIgcG9pbnQgPSAvKiNfX1BVUkVfXyovZGVmYXVsdFBvaW50ZXJQb3MoKTtcbnZhciBpc01vdXNlRGV2aWNlID0gZmFsc2U7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1cGRhdGVQb2ludExvY2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaXNNb3VzZURldmljZSA9IHRydWU7XG4gICAgICAgIGV2ZW50VG9Qb2ludChlLCBwb2ludCk7XG4gICAgfTtcbiAgICBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZWRvd24gbW91c2Vtb3ZlJywgdHJ1ZSkuc3RhcnQodXBkYXRlUG9pbnRMb2NhdGlvbik7XG59XG52YXIgbW91c2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnByZXZlbnREZWZhdWx0LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShwb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzeW5jLnVwZGF0ZSh1cGRhdGVQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1cGRhdGVPbk1vdmUgPSBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZW1vdmUnKS5zdGFydChvbk1vdmUpO1xuICAgICAgICBpZiAoaXNNb3VzZURldmljZSkgc3luYy51cGRhdGUodXBkYXRlUG9pbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbFN5bmMudXBkYXRlKHVwZGF0ZVBvaW50KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVPbk1vdmUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIGdldEZpcnN0VG91Y2ggPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IF9hWzBdO1xuICAgIHJldHVybiBmaXJzdFRvdWNoO1xufTtcbnZhciBwb2ludGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGdldElzVG91Y2hEZXZpY2UoKSA/IG11bHRpdG91Y2gocHJvcHMpLnBpcGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gX2EudG91Y2hlcztcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgfSwgZ2V0Rmlyc3RUb3VjaCkgOiBtb3VzZShwcm9wcyk7XG59O1xudmFyIGluZGV4JDEgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICBpZiAoX2EgPT09IHZvaWQgMCkge1xuICAgICAgICBfYSA9IHt9O1xuICAgIH1cbiAgICB2YXIgeCA9IF9hLngsXG4gICAgICAgIHkgPSBfYS55LFxuICAgICAgICBwcm9wcyA9IF9fcmVzdChfYSwgW1wieFwiLCBcInlcIl0pO1xuICAgIGlmICh4ICE9PSB1bmRlZmluZWQgfHwgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhcHBseVhPZmZzZXRfMSA9IGFwcGx5T2Zmc2V0KHggfHwgMCk7XG4gICAgICAgIHZhciBhcHBseVlPZmZzZXRfMSA9IGFwcGx5T2Zmc2V0KHkgfHwgMCk7XG4gICAgICAgIHZhciBkZWx0YV8xID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHJldHVybiBwb2ludGVyKHByb3BzKS5waXBlKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgZGVsdGFfMS54ID0gYXBwbHlYT2Zmc2V0XzEocG9pbnQueCk7XG4gICAgICAgICAgICBkZWx0YV8xLnkgPSBhcHBseVlPZmZzZXRfMShwb2ludC55KTtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YV8xO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9pbnRlcihwcm9wcyk7XG4gICAgfVxufTtcblxudmFyIGNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYWN0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlLFxuICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudDtcbiAgICAgICAgdmFyIHBsYXlDdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGFjdGlvbnNbaV0uc3RhcnQoe1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaSA+PSBhY3Rpb25zLmxlbmd0aCA/IGNvbXBsZXRlKCkgOiBwbGF5Q3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBwbGF5Q3VycmVudCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50ICYmIGN1cnJlbnQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIHBhcmFsbGVsID0gLyojX19QVVJFX18qL211bHRpKHtcbiAgICBnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uIChzdWJzKSB7XG4gICAgICAgIHJldHVybiBzdWJzLmxlbmd0aDtcbiAgICB9LFxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAoc3Vicykge1xuICAgICAgICByZXR1cm4gc3Vic1swXTtcbiAgICB9LFxuICAgIG1hcEFwaTogZnVuY3Rpb24gKHN1YnMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWJzLm1hcChmdW5jdGlvbiAoc3ViLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlttZXRob2ROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IHN1YlttZXRob2ROYW1lXShhcmdzWzBdW2ldKSA6IHN1YlttZXRob2ROYW1lXS5hcHBseShzdWIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0UHJvcDogZnVuY3Rpb24gKG91dHB1dCwgbmFtZSwgdikge1xuICAgICAgICByZXR1cm4gb3V0cHV0W25hbWVdID0gdjtcbiAgICB9LFxuICAgIHN0YXJ0QWN0aW9uczogZnVuY3Rpb24gKGFjdGlvbnMsIHN0YXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydGVyKGFjdGlvbiwgaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xudmFyIHBhcmFsbGVsJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhY3Rpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBwYXJhbGxlbChhY3Rpb25zKTtcbn07XG5cbnZhciBjcm9zc2ZhZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBiYWxhbmNlID0gMDtcbiAgICAgICAgdmFyIGZhZGFibGUgPSBwYXJhbGxlbCQxKGEsIGIpLnN0YXJ0KF9fYXNzaWduKHt9LCBvYnNlcnZlciwgeyB1cGRhdGU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB2YSA9IF9hWzBdLFxuICAgICAgICAgICAgICAgICAgICB2YiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLnVwZGF0ZShtaXgodmEsIHZiLCBiYWxhbmNlKSk7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEJhbGFuY2U6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2UgPSB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFkYWJsZS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG52YXIgZGVsYXkgPSBmdW5jdGlvbiAodGltZVRvRGVsYXkpIHtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNvbXBsZXRlLCB0aW1lVG9EZWxheSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFjdGlvbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHN1YnMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAodGhpc0FjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNBY3Rpb24uc3RhcnQob2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vicy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG52YXIgc2NoZWR1bGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBzY2hlZHVsZWUpIHtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlLFxuICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIGxhdGVzdDtcbiAgICAgICAgdmFyIHNjaGVkdWxlclN1YiA9IHNjaGVkdWxlci5zdGFydCh7XG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0ICE9PSB1bmRlZmluZWQgJiYgdXBkYXRlKGxhdGVzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2NoZWR1bGVlU3ViID0gc2NoZWR1bGVlLnN0YXJ0KHtcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0ID0gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyU3ViLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWVTdWIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIHN0YWdnZXIgPSBmdW5jdGlvbiAoYWN0aW9ucywgaW50ZXJ2YWwpIHtcbiAgICB2YXIgaW50ZXJ2YWxJc051bWJlciA9IHR5cGVvZiBpbnRlcnZhbCA9PT0gJ251bWJlcic7XG4gICAgdmFyIGFjdGlvbnNXaXRoRGVsYXkgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYSwgaSkge1xuICAgICAgICB2YXIgdGltZVRvRGVsYXkgPSBpbnRlcnZhbElzTnVtYmVyID8gaW50ZXJ2YWwgKiBpIDogaW50ZXJ2YWwoaSk7XG4gICAgICAgIHJldHVybiBjaGFpbihkZWxheSh0aW1lVG9EZWxheSksIGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbGxlbCQxLmFwcGx5KHZvaWQgMCwgYWN0aW9uc1dpdGhEZWxheSk7XG59O1xuXG52YXIgc3R5bGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnZhcmlhbnQoZmFsc2UsICdzdHlsZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIFBvcG1vdGlvbiBpbiA5LjAuIERvd25ncmFkZSB0byA4Lnggb3IgbnBtIGluc3RhbGwgc3R5bGVmaXJlJyk7XG59O1xuXG5leHBvcnQgeyBBY3Rpb24sIFZhbHVlUmVhY3Rpb24sIGFjdGlvbiwgY2hhaW4sIGNvbXBvc2l0ZSwgY3Jvc3NmYWRlLCB2ZWN0b3JEZWNheSBhcyBkZWNheSwgZGVsYXksIGZyYW1lIGFzIGV2ZXJ5RnJhbWUsIGluZGV4IGFzIGluZXJ0aWEsIGtleWZyYW1lcywgbGlzdGVuLCBtZXJnZSwgbW91c2UsIG11bHRpY2FzdCwgbXVsdGl0b3VjaCwgcGFyYWxsZWwkMSBhcyBwYXJhbGxlbCwgdmVjdG9yUGh5c2ljcyBhcyBwaHlzaWNzLCBpbmRleCQxIGFzIHBvaW50ZXIsIHNjaGVkdWxlLCB2ZWN0b3JTcHJpbmcgYXMgc3ByaW5nLCBzdGFnZ2VyLCBzdHlsZXIsIHRpbWVsaW5lLCB0d2VlbiwgdmFsdWUgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/popmotion/dist/popmotion.es.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/YTE1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.13.1\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar ReactVersion = '16.13.1';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  suspense: null\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\nfunction describeComponentFrame (name, source, ownerName) {\n  var sourceInfo = '';\n\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n\n        if (match) {\n          var pathBeforeSlash = match[1];\n\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nvar Resolved = 1;\nfunction refineResolvedLazyComponent(lazyComponent) {\n  return lazyComponent._status === Resolved ? lazyComponent._result : null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type.render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var thenable = type;\n          var resolvedThenable = refineResolvedLazyComponent(thenable);\n\n          if (resolvedThenable) {\n            return getComponentName(resolvedThenable);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return null;\n}\n\nvar ReactDebugCurrentFrame = {};\nvar currentlyValidatingElement = null;\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\n{\n  // Stack implementation injected by the current renderer.\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n/**\n * Used by act() to track whether you're inside an act() scope.\n */\nvar IsSomeRendererActing = {\n  current: false\n};\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner,\n  IsSomeRendererActing: IsSomeRendererActing,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  _assign(ReactSharedInternals, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    printWarning('warn', format, args);\n  }\n}\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n    if (!hasExistingStack) {\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n      if (stack !== '') {\n        format += '%s';\n        args = args.concat([stack]);\n      }\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {\n    {\n      throw Error( \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\" );\n    }\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n_assign(pureComponentPrototype, Component.prototype);\n\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (!!(element === null || element === undefined)) {\n    {\n      throw Error( \"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\" );\n    }\n  }\n\n  var propName; // Original props are copied\n\n  var props = _assign({}, element.props); // Reserved names are extracted\n\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\n\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is deprecated and will be removed in ' + 'a future major release. Consider converting children to ' + 'an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n\n      var childrenString = '' + children;\n\n      {\n        {\n          throw Error( \"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \").\" + addendum );\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n  func.call(context, child, bookKeeping.count++);\n}\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\n\n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\n      return c;\n    });\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\n\n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  return traverseAllChildren(children, function () {\n    return null;\n  }, null);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\n    return child;\n  });\n  return result;\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    {\n      throw Error( \"React.Children.only expected to receive a single React element child.\" );\n    }\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {\n        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);\n      }\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context,\n      _calculateChangedBits: context._calculateChangedBits\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction lazy(ctor) {\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _ctor: ctor,\n    // React uses these fields to store the result.\n    _status: -1,\n    _result: null\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes;\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  if (!(dispatcher !== null)) {\n    {\n      throw Error( \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.\" );\n    }\n  }\n\n  return dispatcher;\n}\n\nfunction useContext(Context, unstable_observedBits) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    if (unstable_observedBits !== undefined) {\n      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\\n\\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '');\n    } // TODO: add a more generic warning for invalid values.\n\n\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context, unstable_observedBits);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n  }\n\n  setCurrentlyValidatingElement(element);\n\n  {\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var name = getComponentName(type);\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      setCurrentlyValidatingElement(element);\n      checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n      setCurrentlyValidatingElement(null);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true;\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    setCurrentlyValidatingElement(fragment);\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n    }\n\n    setCurrentlyValidatingElement(null);\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\n{\n\n  try {\n    var frozenObject = Object.freeze({});\n    var testMap = new Map([[frozenObject, null]]);\n    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useEffect = useEffect;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.version = ReactVersion;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz83MmQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGdGQUFlO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUEyQjs7QUFFeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjEzLjEnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgc3VzcGVuc2U6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIEJFRk9SRV9TTEFTSF9SRSA9IC9eKC4qKVtcXFxcXFwvXS87XG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9ICcnO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgcGF0aCA9IHNvdXJjZS5maWxlTmFtZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG5cbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuXG4gICAgICAgICAgaWYgKHBhdGhCZWZvcmVTbGFzaCkge1xuICAgICAgICAgICAgdmFyIGZvbGRlck5hbWUgPSBwYXRoQmVmb3JlU2xhc2gucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZm9sZGVyTmFtZSArICcvJyArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG5cbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyBzb3VyY2VJbmZvO1xufVxuXG52YXIgUmVzb2x2ZWQgPSAxO1xuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KGxhenlDb21wb25lbnQpIHtcbiAgcmV0dXJuIGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQgPyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0aGVuYWJsZSA9IHR5cGU7XG4gICAgICAgICAgdmFyIHJlc29sdmVkVGhlbmFibGUgPSByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQodGhlbmFibGUpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVkVGhlbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHJlc29sdmVkVGhlbmFibGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB9XG59XG5cbntcbiAgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50LnR5cGUpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpKTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3RTaGFyZWRJbnRlcm5hbHMsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBoYXNFeGlzdGluZ1N0YWNrID0gYXJncy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdzdHJpbmcnICYmIGFyZ3NbYXJncy5sZW5ndGggLSAxXS5pbmRleE9mKCdcXG4gICAgaW4nKSA9PT0gMDtcblxuICAgIGlmICghaGFzRXhpc3RpbmdTdGFjaykge1xuICAgICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5cbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLCAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgY29udmVydGluZyBjaGlsZHJlbiB0byAnICsgJ2FuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS5cIiArIGFkZGVuZHVtICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG5cbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG5cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgbnVsbCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfY3RvcjogY3RvcixcbiAgICAvLyBSZWFjdCB1c2VzIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9mYi5tZS9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICB7XG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0pO1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICB2YXIgdGVzdE1hcCA9IG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgdmFyIHRlc3RTZXQgPSBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTsgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIFJvbGx1cCB0byBub3QgY29uc2lkZXIgdGhlc2UgdW51c2VkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNzcxXG4gICAgLy8gVE9ETzogd2UgY2FuIHJlbW92ZSB0aGVzZSBpZiBSb2xsdXAgZml4ZXMgdGhlIGJ1Zy5cblxuICAgIHRlc3RNYXAuc2V0KDAsIDApO1xuICAgIHRlc3RTZXQuYWRkKDApO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5leHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzP2FiNWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsaUZBQTRCO0FBQ3ZEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/style-value-types/dist/style-value-types.es.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-value-types/dist/style-value-types.es.js ***!
  \*********************************************************************/
/*! exports provided: number, scale, alpha, degrees, percent, progressPercentage, px, vw, vh, rgba, rgbUnit, hsla, hex, color, complex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"number\", function() { return number; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha\", function() { return alpha; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees\", function() { return degrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"percent\", function() { return percent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"progressPercentage\", function() { return progressPercentage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"px\", function() { return px; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vw\", function() { return vw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vh\", function() { return vh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgba\", function() { return rgba; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbUnit\", function() { return rgbUnit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsla\", function() { return hsla; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hex\", function() { return hex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"color\", function() { return color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"complex\", function() { return complex; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar clamp = function (min, max) { return function (v) {\r\n    return Math.max(Math.min(v, max), min);\r\n}; };\r\nvar sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };\r\nvar floatRegex = /(-)?(\\d[\\d\\.]*)/g;\r\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\r\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))$/i;\n\nvar number = {\r\n    test: function (v) { return typeof v === 'number'; },\r\n    parse: parseFloat,\r\n    transform: function (v) { return v; }\r\n};\r\nvar alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });\r\nvar scale = __assign(__assign({}, number), { default: 1 });\n\nvar createUnitType = function (unit) { return ({\r\n    test: function (v) {\r\n        return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;\r\n    },\r\n    parse: parseFloat,\r\n    transform: function (v) { return \"\" + v + unit; }\r\n}); };\r\nvar degrees = createUnitType('deg');\r\nvar percent = createUnitType('%');\r\nvar px = createUnitType('px');\r\nvar vh = createUnitType('vh');\r\nvar vw = createUnitType('vw');\r\nvar progressPercentage = __assign(__assign({}, percent), { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });\n\nvar getValueFromFunctionString = function (value) {\r\n    return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));\r\n};\r\nvar clampRgbUnit = clamp(0, 255);\r\nvar isRgba = function (v) { return v.red !== undefined; };\r\nvar isHsla = function (v) { return v.hue !== undefined; };\r\nvar splitColorValues = function (terms) {\r\n    return function (v) {\r\n        if (typeof v !== 'string')\r\n            return v;\r\n        var values = {};\r\n        var valuesArray = getValueFromFunctionString(v).split(/,\\s*/);\r\n        for (var i = 0; i < 4; i++) {\r\n            values[terms[i]] =\r\n                valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;\r\n        }\r\n        return values;\r\n    };\r\n};\r\nvar rgbaTemplate = function (_a) {\r\n    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n    return \"rgba(\" + red + \", \" + green + \", \" + blue + \", \" + alpha$$1 + \")\";\r\n};\r\nvar hslaTemplate = function (_a) {\r\n    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n    return \"hsla(\" + hue + \", \" + saturation + \", \" + lightness + \", \" + alpha$$1 + \")\";\r\n};\r\nvar rgbUnit = __assign(__assign({}, number), { transform: function (v) { return Math.round(clampRgbUnit(v)); } });\r\nfunction isColorString(color, colorType) {\r\n    return color.startsWith(colorType) && singleColorRegex.test(color);\r\n}\r\nvar rgba = {\r\n    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'rgb') : isRgba(v)); },\r\n    parse: splitColorValues(['red', 'green', 'blue', 'alpha']),\r\n    transform: function (_a) {\r\n        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n        return rgbaTemplate({\r\n            red: rgbUnit.transform(red),\r\n            green: rgbUnit.transform(green),\r\n            blue: rgbUnit.transform(blue),\r\n            alpha: sanitize(alpha.transform(alpha$$1))\r\n        });\r\n    }\r\n};\r\nvar hsla = {\r\n    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'hsl') : isHsla(v)); },\r\n    parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),\r\n    transform: function (_a) {\r\n        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n        return hslaTemplate({\r\n            hue: Math.round(hue),\r\n            saturation: percent.transform(sanitize(saturation)),\r\n            lightness: percent.transform(sanitize(lightness)),\r\n            alpha: sanitize(alpha.transform(alpha$$1))\r\n        });\r\n    }\r\n};\r\nvar hex = __assign(__assign({}, rgba), { test: function (v) { return typeof v === 'string' && isColorString(v, '#'); }, parse: function (v) {\r\n        var r = '';\r\n        var g = '';\r\n        var b = '';\r\n        if (v.length > 4) {\r\n            r = v.substr(1, 2);\r\n            g = v.substr(3, 2);\r\n            b = v.substr(5, 2);\r\n        }\r\n        else {\r\n            r = v.substr(1, 1);\r\n            g = v.substr(2, 1);\r\n            b = v.substr(3, 1);\r\n            r += r;\r\n            g += g;\r\n            b += b;\r\n        }\r\n        return {\r\n            red: parseInt(r, 16),\r\n            green: parseInt(g, 16),\r\n            blue: parseInt(b, 16),\r\n            alpha: 1\r\n        };\r\n    } });\r\nvar color = {\r\n    test: function (v) {\r\n        return (typeof v === 'string' && singleColorRegex.test(v)) ||\r\n            isRgba(v) ||\r\n            isHsla(v);\r\n    },\r\n    parse: function (v) {\r\n        if (rgba.test(v)) {\r\n            return rgba.parse(v);\r\n        }\r\n        else if (hsla.test(v)) {\r\n            return hsla.parse(v);\r\n        }\r\n        else if (hex.test(v)) {\r\n            return hex.parse(v);\r\n        }\r\n        return v;\r\n    },\r\n    transform: function (v) {\r\n        if (isRgba(v)) {\r\n            return rgba.transform(v);\r\n        }\r\n        else if (isHsla(v)) {\r\n            return hsla.transform(v);\r\n        }\r\n        return v;\r\n    }\r\n};\n\nvar COLOR_TOKEN = '${c}';\r\nvar NUMBER_TOKEN = '${n}';\r\nvar convertNumbersToZero = function (v) {\r\n    return typeof v === 'number' ? 0 : v;\r\n};\r\nvar complex = {\r\n    test: function (v) {\r\n        if (typeof v !== 'string' || !isNaN(v))\r\n            return false;\r\n        var numValues = 0;\r\n        var foundNumbers = v.match(floatRegex);\r\n        var foundColors = v.match(colorRegex);\r\n        if (foundNumbers)\r\n            numValues += foundNumbers.length;\r\n        if (foundColors)\r\n            numValues += foundColors.length;\r\n        return numValues > 0;\r\n    },\r\n    parse: function (v) {\r\n        var input = v;\r\n        var parsed = [];\r\n        var foundColors = input.match(colorRegex);\r\n        if (foundColors) {\r\n            input = input.replace(colorRegex, COLOR_TOKEN);\r\n            parsed.push.apply(parsed, foundColors.map(color.parse));\r\n        }\r\n        var foundNumbers = input.match(floatRegex);\r\n        if (foundNumbers) {\r\n            parsed.push.apply(parsed, foundNumbers.map(number.parse));\r\n        }\r\n        return parsed;\r\n    },\r\n    createTransformer: function (prop) {\r\n        var template = prop;\r\n        var token = 0;\r\n        var foundColors = prop.match(colorRegex);\r\n        var numColors = foundColors ? foundColors.length : 0;\r\n        if (foundColors) {\r\n            for (var i = 0; i < numColors; i++) {\r\n                template = template.replace(foundColors[i], COLOR_TOKEN);\r\n                token++;\r\n            }\r\n        }\r\n        var foundNumbers = template.match(floatRegex);\r\n        var numNumbers = foundNumbers ? foundNumbers.length : 0;\r\n        if (foundNumbers) {\r\n            for (var i = 0; i < numNumbers; i++) {\r\n                template = template.replace(foundNumbers[i], NUMBER_TOKEN);\r\n                token++;\r\n            }\r\n        }\r\n        return function (v) {\r\n            var output = template;\r\n            for (var i = 0; i < token; i++) {\r\n                output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\r\n            }\r\n            return output;\r\n        };\r\n    },\r\n    getAnimatableNone: function (target) {\r\n        var parsedTarget = complex.parse(target);\r\n        var targetTransformer = complex.createTransformer(target);\r\n        return targetTransformer(parsedTarget.map(convertNumbersToZero));\r\n    }\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3Qvc3R5bGUtdmFsdWUtdHlwZXMuZXMuanM/MjFiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBLEVBQUU7QUFDRiw2QkFBNkIsMkNBQTJDO0FBQ3hFO0FBQ0EsNkJBQTZCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxFQUFFLElBQUksOEJBQThCLElBQUk7QUFDcEcsb0NBQW9DLEVBQUUsY0FBYyxFQUFFLEVBQUUsSUFBSSw4QkFBOEIsSUFBSTs7QUFFOUY7QUFDQSx3QkFBd0IsOEJBQThCLEVBQUU7QUFDeEQ7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLGdDQUFnQyxZQUFZLHlCQUF5QjtBQUNyRSxnQ0FBZ0MsWUFBWSxhQUFhOztBQUV6RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhLHNCQUFzQiwrQkFBK0IsRUFBRSwyQkFBMkIsbUNBQW1DLEVBQUUsRUFBRTs7QUFFbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZELDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZLDBCQUEwQixvQ0FBb0MsRUFBRSxFQUFFO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRSxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRSxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QixVQUFVLHFCQUFxQix1REFBdUQsRUFBRTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsRUFBRTtBQUN2QixzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEgiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9zdHlsZS12YWx1ZS10eXBlcy5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odiwgbWF4KSwgbWluKTtcclxufTsgfTtcclxudmFyIHNhbml0aXplID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ICUgMSA/IE51bWJlcih2LnRvRml4ZWQoNSkpIDogdik7IH07XHJcbnZhciBmbG9hdFJlZ2V4ID0gLygtKT8oXFxkW1xcZFxcLl0qKS9nO1xyXG52YXIgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdezZ9fCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9cXGQrJT9bLFxcc10rKXsyLDN9XFxzKltcXGRcXC5dKyU/XFwpKS9naTtcclxudmFyIHNpbmdsZUNvbG9yUmVnZXggPSAvXigjWzAtOWEtZl17M318Iyg/OlswLTlhLWZdezJ9KXsyLDR9fChyZ2J8aHNsKWE/XFwoKC0/XFxkKyU/WyxcXHNdKyl7MiwzfVxccypbXFxkXFwuXSslP1xcKSkkL2k7XG5cbnZhciBudW1iZXIgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInOyB9LFxyXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXHJcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9XHJcbn07XHJcbnZhciBhbHBoYSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBudW1iZXIpLCB7IHRyYW5zZm9ybTogY2xhbXAoMCwgMSkgfSk7XHJcbnZhciBzY2FsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBudW1iZXIpLCB7IGRlZmF1bHQ6IDEgfSk7XG5cbnZhciBjcmVhdGVVbml0VHlwZSA9IGZ1bmN0aW9uICh1bml0KSB7IHJldHVybiAoe1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdCgnICcpLmxlbmd0aCA9PT0gMTtcclxuICAgIH0sXHJcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcclxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiXCIgKyB2ICsgdW5pdDsgfVxyXG59KTsgfTtcclxudmFyIGRlZ3JlZXMgPSBjcmVhdGVVbml0VHlwZSgnZGVnJyk7XHJcbnZhciBwZXJjZW50ID0gY3JlYXRlVW5pdFR5cGUoJyUnKTtcclxudmFyIHB4ID0gY3JlYXRlVW5pdFR5cGUoJ3B4Jyk7XHJcbnZhciB2aCA9IGNyZWF0ZVVuaXRUeXBlKCd2aCcpO1xyXG52YXIgdncgPSBjcmVhdGVVbml0VHlwZSgndncnKTtcclxudmFyIHByb2dyZXNzUGVyY2VudGFnZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwZXJjZW50KSwgeyBwYXJzZTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBlcmNlbnQucGFyc2UodikgLyAxMDA7IH0sIHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBlcmNlbnQudHJhbnNmb3JtKHYgKiAxMDApOyB9IH0pO1xuXG52YXIgZ2V0VmFsdWVGcm9tRnVuY3Rpb25TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcodmFsdWUuaW5kZXhPZignKCcpICsgMSwgdmFsdWUubGFzdEluZGV4T2YoJyknKSk7XHJcbn07XHJcbnZhciBjbGFtcFJnYlVuaXQgPSBjbGFtcCgwLCAyNTUpO1xyXG52YXIgaXNSZ2JhID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucmVkICE9PSB1bmRlZmluZWQ7IH07XHJcbnZhciBpc0hzbGEgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5odWUgIT09IHVuZGVmaW5lZDsgfTtcclxudmFyIHNwbGl0Q29sb3JWYWx1ZXMgPSBmdW5jdGlvbiAodGVybXMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgICAgICB2YXIgdmFsdWVzQXJyYXkgPSBnZXRWYWx1ZUZyb21GdW5jdGlvblN0cmluZyh2KS5zcGxpdCgvLFxccyovKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZXNbdGVybXNbaV1dID1cclxuICAgICAgICAgICAgICAgIHZhbHVlc0FycmF5W2ldICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHZhbHVlc0FycmF5W2ldKSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgcmdiYVRlbXBsYXRlID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcmVkID0gX2EucmVkLCBncmVlbiA9IF9hLmdyZWVuLCBibHVlID0gX2EuYmx1ZSwgX2IgPSBfYS5hbHBoYSwgYWxwaGEkJDEgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xyXG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJlZCArIFwiLCBcIiArIGdyZWVuICsgXCIsIFwiICsgYmx1ZSArIFwiLCBcIiArIGFscGhhJCQxICsgXCIpXCI7XHJcbn07XHJcbnZhciBoc2xhVGVtcGxhdGUgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBodWUgPSBfYS5odWUsIHNhdHVyYXRpb24gPSBfYS5zYXR1cmF0aW9uLCBsaWdodG5lc3MgPSBfYS5saWdodG5lc3MsIF9iID0gX2EuYWxwaGEsIGFscGhhJCQxID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYjtcclxuICAgIHJldHVybiBcImhzbGEoXCIgKyBodWUgKyBcIiwgXCIgKyBzYXR1cmF0aW9uICsgXCIsIFwiICsgbGlnaHRuZXNzICsgXCIsIFwiICsgYWxwaGEkJDEgKyBcIilcIjtcclxufTtcclxudmFyIHJnYlVuaXQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSk7IH0gfSk7XHJcbmZ1bmN0aW9uIGlzQ29sb3JTdHJpbmcoY29sb3IsIGNvbG9yVHlwZSkge1xyXG4gICAgcmV0dXJuIGNvbG9yLnN0YXJ0c1dpdGgoY29sb3JUeXBlKSAmJiBzaW5nbGVDb2xvclJlZ2V4LnRlc3QoY29sb3IpO1xyXG59XHJcbnZhciByZ2JhID0ge1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyBpc0NvbG9yU3RyaW5nKHYsICdyZ2InKSA6IGlzUmdiYSh2KSk7IH0sXHJcbiAgICBwYXJzZTogc3BsaXRDb2xvclZhbHVlcyhbJ3JlZCcsICdncmVlbicsICdibHVlJywgJ2FscGhhJ10pLFxyXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgcmVkID0gX2EucmVkLCBncmVlbiA9IF9hLmdyZWVuLCBibHVlID0gX2EuYmx1ZSwgX2IgPSBfYS5hbHBoYSwgYWxwaGEkJDEgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xyXG4gICAgICAgIHJldHVybiByZ2JhVGVtcGxhdGUoe1xyXG4gICAgICAgICAgICByZWQ6IHJnYlVuaXQudHJhbnNmb3JtKHJlZCksXHJcbiAgICAgICAgICAgIGdyZWVuOiByZ2JVbml0LnRyYW5zZm9ybShncmVlbiksXHJcbiAgICAgICAgICAgIGJsdWU6IHJnYlVuaXQudHJhbnNmb3JtKGJsdWUpLFxyXG4gICAgICAgICAgICBhbHBoYTogc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJCQxKSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxudmFyIGhzbGEgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IGlzQ29sb3JTdHJpbmcodiwgJ2hzbCcpIDogaXNIc2xhKHYpKTsgfSxcclxuICAgIHBhcnNlOiBzcGxpdENvbG9yVmFsdWVzKFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJywgJ2FscGhhJ10pLFxyXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaHVlID0gX2EuaHVlLCBzYXR1cmF0aW9uID0gX2Euc2F0dXJhdGlvbiwgbGlnaHRuZXNzID0gX2EubGlnaHRuZXNzLCBfYiA9IF9hLmFscGhhLCBhbHBoYSQkMSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2I7XHJcbiAgICAgICAgcmV0dXJuIGhzbGFUZW1wbGF0ZSh7XHJcbiAgICAgICAgICAgIGh1ZTogTWF0aC5yb3VuZChodWUpLFxyXG4gICAgICAgICAgICBzYXR1cmF0aW9uOiBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShzYXR1cmF0aW9uKSksXHJcbiAgICAgICAgICAgIGxpZ2h0bmVzczogcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSksXHJcbiAgICAgICAgICAgIGFscGhhOiBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkJDEpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG52YXIgaGV4ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJnYmEpLCB7IHRlc3Q6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgaXNDb2xvclN0cmluZyh2LCAnIycpOyB9LCBwYXJzZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgciA9ICcnO1xyXG4gICAgICAgIHZhciBnID0gJyc7XHJcbiAgICAgICAgdmFyIGIgPSAnJztcclxuICAgICAgICBpZiAodi5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIHIgPSB2LnN1YnN0cigxLCAyKTtcclxuICAgICAgICAgICAgZyA9IHYuc3Vic3RyKDMsIDIpO1xyXG4gICAgICAgICAgICBiID0gdi5zdWJzdHIoNSwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByID0gdi5zdWJzdHIoMSwgMSk7XHJcbiAgICAgICAgICAgIGcgPSB2LnN1YnN0cigyLCAxKTtcclxuICAgICAgICAgICAgYiA9IHYuc3Vic3RyKDMsIDEpO1xyXG4gICAgICAgICAgICByICs9IHI7XHJcbiAgICAgICAgICAgIGcgKz0gZztcclxuICAgICAgICAgICAgYiArPSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZWQ6IHBhcnNlSW50KHIsIDE2KSxcclxuICAgICAgICAgICAgZ3JlZW46IHBhcnNlSW50KGcsIDE2KSxcclxuICAgICAgICAgICAgYmx1ZTogcGFyc2VJbnQoYiwgMTYpLFxyXG4gICAgICAgICAgICBhbHBoYTogMVxyXG4gICAgICAgIH07XHJcbiAgICB9IH0pO1xyXG52YXIgY29sb3IgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIHNpbmdsZUNvbG9yUmVnZXgudGVzdCh2KSkgfHxcclxuICAgICAgICAgICAgaXNSZ2JhKHYpIHx8XHJcbiAgICAgICAgICAgIGlzSHNsYSh2KTtcclxuICAgIH0sXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAocmdiYS50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhLnBhcnNlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhleC50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfSxcclxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoaXNSZ2JhKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhLnRyYW5zZm9ybSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNIc2xhKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhLnRyYW5zZm9ybSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbn07XG5cbnZhciBDT0xPUl9UT0tFTiA9ICcke2N9JztcclxudmFyIE5VTUJFUl9UT0tFTiA9ICcke259JztcclxudmFyIGNvbnZlcnROdW1iZXJzVG9aZXJvID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcicgPyAwIDogdjtcclxufTtcclxudmFyIGNvbXBsZXggPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycgfHwgIWlzTmFOKHYpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIG51bVZhbHVlcyA9IDA7XHJcbiAgICAgICAgdmFyIGZvdW5kTnVtYmVycyA9IHYubWF0Y2goZmxvYXRSZWdleCk7XHJcbiAgICAgICAgdmFyIGZvdW5kQ29sb3JzID0gdi5tYXRjaChjb2xvclJlZ2V4KTtcclxuICAgICAgICBpZiAoZm91bmROdW1iZXJzKVxyXG4gICAgICAgICAgICBudW1WYWx1ZXMgKz0gZm91bmROdW1iZXJzLmxlbmd0aDtcclxuICAgICAgICBpZiAoZm91bmRDb2xvcnMpXHJcbiAgICAgICAgICAgIG51bVZhbHVlcyArPSBmb3VuZENvbG9ycy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIG51bVZhbHVlcyA+IDA7XHJcbiAgICB9LFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdjtcclxuICAgICAgICB2YXIgcGFyc2VkID0gW107XHJcbiAgICAgICAgdmFyIGZvdW5kQ29sb3JzID0gaW5wdXQubWF0Y2goY29sb3JSZWdleCk7XHJcbiAgICAgICAgaWYgKGZvdW5kQ29sb3JzKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShjb2xvclJlZ2V4LCBDT0xPUl9UT0tFTik7XHJcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoLmFwcGx5KHBhcnNlZCwgZm91bmRDb2xvcnMubWFwKGNvbG9yLnBhcnNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmb3VuZE51bWJlcnMgPSBpbnB1dC5tYXRjaChmbG9hdFJlZ2V4KTtcclxuICAgICAgICBpZiAoZm91bmROdW1iZXJzKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoLmFwcGx5KHBhcnNlZCwgZm91bmROdW1iZXJzLm1hcChudW1iZXIucGFyc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVUcmFuc2Zvcm1lcjogZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwcm9wO1xyXG4gICAgICAgIHZhciB0b2tlbiA9IDA7XHJcbiAgICAgICAgdmFyIGZvdW5kQ29sb3JzID0gcHJvcC5tYXRjaChjb2xvclJlZ2V4KTtcclxuICAgICAgICB2YXIgbnVtQ29sb3JzID0gZm91bmRDb2xvcnMgPyBmb3VuZENvbG9ycy5sZW5ndGggOiAwO1xyXG4gICAgICAgIGlmIChmb3VuZENvbG9ycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvbG9yczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoZm91bmRDb2xvcnNbaV0sIENPTE9SX1RPS0VOKTtcclxuICAgICAgICAgICAgICAgIHRva2VuKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvdW5kTnVtYmVycyA9IHRlbXBsYXRlLm1hdGNoKGZsb2F0UmVnZXgpO1xyXG4gICAgICAgIHZhciBudW1OdW1iZXJzID0gZm91bmROdW1iZXJzID8gZm91bmROdW1iZXJzLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgaWYgKGZvdW5kTnVtYmVycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU51bWJlcnM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKGZvdW5kTnVtYmVyc1tpXSwgTlVNQkVSX1RPS0VOKTtcclxuICAgICAgICAgICAgICAgIHRva2VuKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0ZW1wbGF0ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShpIDwgbnVtQ29sb3JzID8gQ09MT1JfVE9LRU4gOiBOVU1CRVJfVE9LRU4sIGkgPCBudW1Db2xvcnMgPyBjb2xvci50cmFuc2Zvcm0odltpXSkgOiBzYW5pdGl6ZSh2W2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdldEFuaW1hdGFibGVOb25lOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZFRhcmdldCA9IGNvbXBsZXgucGFyc2UodGFyZ2V0KTtcclxuICAgICAgICB2YXIgdGFyZ2V0VHJhbnNmb3JtZXIgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFRyYW5zZm9ybWVyKHBhcnNlZFRhcmdldC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcclxuICAgIH1cclxufTtcblxuZXhwb3J0IHsgbnVtYmVyLCBzY2FsZSwgYWxwaGEsIGRlZ3JlZXMsIHBlcmNlbnQsIHByb2dyZXNzUGVyY2VudGFnZSwgcHgsIHZ3LCB2aCwgcmdiYSwgcmdiVW5pdCwgaHNsYSwgaGV4LCBjb2xvciwgY29tcGxleCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-value-types/dist/style-value-types.es.js\n");

/***/ }),

/***/ "./node_modules/stylefire/dist/stylefire.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/stylefire/dist/stylefire.es.js ***!
  \*****************************************************/
/*! exports provided: default, buildSVGAttrs, buildStyleProperty, createStylerFactory, isTransformProp, transformProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSVGAttrs\", function() { return buildSVGAttrs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildStyleProperty\", function() { return buildStyleProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createStylerFactory\", function() { return createStyler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTransformProp\", function() { return isTransformProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformProps\", function() { return transformProps; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framesync */ \"./node_modules/framesync/dist/framesync.es.js\");\n/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-value-types */ \"./node_modules/style-value-types/dist/style-value-types.es.js\");\n/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hey-listen */ \"./node_modules/hey-listen/dist/hey-listen.es.js\");\n\n\n\n\n\nvar createStyler = function (_a) {\n    var onRead = _a.onRead,\n        onRender = _a.onRender,\n        _b = _a.uncachedValues,\n        uncachedValues = _b === void 0 ? new Set() : _b,\n        _c = _a.useCache,\n        useCache = _c === void 0 ? true : _c;\n    return function (_a) {\n        if (_a === void 0) {\n            _a = {};\n        }\n        var props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, []);\n        var state = {};\n        var changedValues = [];\n        var hasChanged = false;\n        function setValue(key, value) {\n            if (key.startsWith('--')) {\n                props.hasCSSVariable = true;\n            }\n            var currentValue = state[key];\n            state[key] = value;\n            if (state[key] === currentValue) return;\n            if (changedValues.indexOf(key) === -1) {\n                changedValues.push(key);\n            }\n            if (!hasChanged) {\n                hasChanged = true;\n                framesync__WEBPACK_IMPORTED_MODULE_1__[\"default\"].render(styler.render);\n            }\n        }\n        var styler = {\n            get: function (key, forceRead) {\n                if (forceRead === void 0) {\n                    forceRead = false;\n                }\n                var useCached = !forceRead && useCache && !uncachedValues.has(key) && state[key] !== undefined;\n                return useCached ? state[key] : onRead(key, props);\n            },\n            set: function (values, value) {\n                if (typeof values === 'string') {\n                    setValue(values, value);\n                } else {\n                    for (var key in values) {\n                        setValue(key, values[key]);\n                    }\n                }\n                return this;\n            },\n            render: function (forceRender) {\n                if (forceRender === void 0) {\n                    forceRender = false;\n                }\n                if (hasChanged || forceRender === true) {\n                    onRender(state, props, changedValues);\n                    hasChanged = false;\n                    changedValues.length = 0;\n                }\n                return this;\n            }\n        };\n        return styler;\n    };\n};\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = '$1-$2';\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nvar camelCache = /*#__PURE__*/new Map();\nvar dashCache = /*#__PURE__*/new Map();\nvar prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];\nvar numPrefixes = prefixes.length;\nvar isBrowser = typeof document !== 'undefined';\nvar testElement;\nvar setDashPrefix = function (key, prefixed) {\n    return dashCache.set(key, camelToDash(prefixed));\n};\nvar testPrefix = function (key) {\n    testElement = testElement || document.createElement('div');\n    for (var i = 0; i < numPrefixes; i++) {\n        var prefix = prefixes[i];\n        var noPrefix = prefix === '';\n        var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);\n        if (prefixedPropertyName in testElement.style || noPrefix) {\n            if (noPrefix && key === 'clipPath' && dashCache.has(key)) {\n                return;\n            }\n            camelCache.set(key, prefixedPropertyName);\n            setDashPrefix(key, \"\" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));\n        }\n    }\n};\nvar setServerProperty = function (key) {\n    return setDashPrefix(key, key);\n};\nvar prefixer = function (key, asDashCase) {\n    if (asDashCase === void 0) {\n        asDashCase = false;\n    }\n    var cache = asDashCase ? dashCache : camelCache;\n    if (!cache.has(key)) {\n        isBrowser ? testPrefix(key) : setServerProperty(key);\n    }\n    return cache.get(key) || key;\n};\n\nvar axes = ['', 'X', 'Y', 'Z'];\nvar order = ['translate', 'scale', 'rotate', 'skew', 'transformPerspective'];\nvar transformProps = /*#__PURE__*/order.reduce(function (acc, key) {\n    return axes.reduce(function (axesAcc, axesKey) {\n        axesAcc.push(key + axesKey);\n        return axesAcc;\n    }, acc);\n}, ['x', 'y', 'z']);\nvar transformPropDictionary = /*#__PURE__*/transformProps.reduce(function (dict, key) {\n    dict[key] = true;\n    return dict;\n}, {});\nfunction isTransformProp(key) {\n    return transformPropDictionary[key] === true;\n}\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\nvar transformOriginProps = /*#__PURE__*/new Set(['originX', 'originY', 'originZ']);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nvar int = /*#__PURE__*/Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])( /*#__PURE__*/Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"number\"]), { transform: Math.round });\nvar valueTypes = {\n    color: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    backgroundColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    outlineColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    fill: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    stroke: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderTopColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderRightColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderBottomColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderLeftColor: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"color\"],\n    borderWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderTopWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderRightWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderBottomWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderLeftWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderRadius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    radius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderTopLeftRadius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderTopRightRadius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderBottomRightRadius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    borderBottomLeftRadius: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    width: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    maxWidth: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    height: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    maxHeight: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    size: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    top: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    right: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    bottom: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    left: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    padding: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    paddingTop: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    paddingRight: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    paddingBottom: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    paddingLeft: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    margin: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    marginTop: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    marginRight: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    marginBottom: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    marginLeft: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    rotate: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    rotateX: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    rotateY: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    rotateZ: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    scale: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"scale\"],\n    scaleX: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"scale\"],\n    scaleY: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"scale\"],\n    scaleZ: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"scale\"],\n    skew: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    skewX: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    skewY: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"degrees\"],\n    distance: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    translateX: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    translateY: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    translateZ: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    x: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    y: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    z: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    perspective: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    opacity: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"alpha\"],\n    originX: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"progressPercentage\"],\n    originY: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"progressPercentage\"],\n    originZ: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"],\n    zIndex: int,\n    fillOpacity: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"alpha\"],\n    strokeOpacity: style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"alpha\"],\n    numOctaves: int\n};\nvar getValueType = function (key) {\n    return valueTypes[key];\n};\nvar getValueAsType = function (value, type) {\n    return type && typeof value === 'number' ? type.transform(value) : value;\n};\n\nvar SCROLL_LEFT = 'scrollLeft';\nvar SCROLL_TOP = 'scrollTop';\nvar scrollKeys = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP]);\n\nvar blacklist = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP, 'transform']);\nvar translateAlias = {\n    x: 'translateX',\n    y: 'translateY',\n    z: 'translateZ'\n};\nfunction isCustomTemplate(v) {\n    return typeof v === 'function';\n}\nfunction buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n    if (allowTransformNone === void 0) {\n        allowTransformNone = true;\n    }\n    var transformString = '';\n    var transformHasZ = false;\n    transformKeys.sort(sortTransformProps);\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        transformHasZ = key === 'z' ? true : transformHasZ;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += 'translateZ(0)';\n    } else {\n        transformString = transformString.trim();\n    }\n    if (isCustomTemplate(state.transform)) {\n        transformString = state.transform(transform, transformIsDefault ? '' : transformString);\n    } else if (allowTransformNone && transformIsDefault) {\n        transformString = 'none';\n    }\n    return transformString;\n}\nfunction buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone) {\n    if (enableHardwareAcceleration === void 0) {\n        enableHardwareAcceleration = true;\n    }\n    if (styles === void 0) {\n        styles = {};\n    }\n    if (transform === void 0) {\n        transform = {};\n    }\n    if (transformOrigin === void 0) {\n        transformOrigin = {};\n    }\n    if (transformKeys === void 0) {\n        transformKeys = [];\n    }\n    if (isDashCase === void 0) {\n        isDashCase = false;\n    }\n    if (allowTransformNone === void 0) {\n        allowTransformNone = true;\n    }\n    var transformIsDefault = true;\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    for (var key in state) {\n        var value = state[key];\n        var valueType = getValueType(key);\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            if (transformIsDefault) {\n                if (valueType.default && value !== valueType.default || !valueType.default && value !== 0) {\n                    transformIsDefault = false;\n                }\n            }\n        } else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            hasTransformOrigin = true;\n        } else if (!blacklist.has(key) || !isCustomTemplate(valueAsType)) {\n            styles[prefixer(key, isDashCase)] = valueAsType;\n        }\n    }\n    if (hasTransform || typeof state.transform === 'function') {\n        styles.transform = buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone);\n    }\n    if (hasTransformOrigin) {\n        styles.transformOrigin = (transformOrigin.originX || '50%') + \" \" + (transformOrigin.originY || '50%') + \" \" + (transformOrigin.originZ || 0);\n    }\n    return styles;\n}\nfunction createStyleBuilder(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.enableHardwareAcceleration,\n        enableHardwareAcceleration = _c === void 0 ? true : _c,\n        _d = _b.isDashCase,\n        isDashCase = _d === void 0 ? true : _d,\n        _e = _b.allowTransformNone,\n        allowTransformNone = _e === void 0 ? true : _e;\n    var styles = {};\n    var transform = {};\n    var transformOrigin = {};\n    var transformKeys = [];\n    return function (state) {\n        transformKeys.length = 0;\n        buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone);\n        return styles;\n    };\n}\n\nfunction onRead(key, options) {\n    var element = options.element,\n        preparseOutput = options.preparseOutput;\n    var defaultValueType = getValueType(key);\n    if (isTransformProp(key)) {\n        return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else if (scrollKeys.has(key)) {\n        return element[key];\n    } else {\n        var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;\n        return preparseOutput && defaultValueType && defaultValueType.test(domValue) && defaultValueType.parse ? defaultValueType.parse(domValue) : domValue;\n    }\n}\nfunction onRender(state, _a, changedValues) {\n    var element = _a.element,\n        buildStyles = _a.buildStyles,\n        hasCSSVariable = _a.hasCSSVariable;\n    Object.assign(element.style, buildStyles(state));\n    if (hasCSSVariable) {\n        var numChangedValues = changedValues.length;\n        for (var i = 0; i < numChangedValues; i++) {\n            var key = changedValues[i];\n            if (key.startsWith('--')) {\n                element.style.setProperty(key, state[key]);\n            }\n        }\n    }\n    if (changedValues.indexOf(SCROLL_LEFT) !== -1) {\n        element[SCROLL_LEFT] = state[SCROLL_LEFT];\n    }\n    if (changedValues.indexOf(SCROLL_TOP) !== -1) {\n        element[SCROLL_TOP] = state[SCROLL_TOP];\n    }\n}\nvar cssStyler = /*#__PURE__*/createStyler({\n    onRead: onRead,\n    onRender: onRender,\n    uncachedValues: scrollKeys\n});\nfunction createCssStyler(element, _a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n        allowTransformNone = _a.allowTransformNone,\n        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"enableHardwareAcceleration\", \"allowTransformNone\"]);\n    return cssStyler(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ element: element, buildStyles: createStyleBuilder({\n            enableHardwareAcceleration: enableHardwareAcceleration,\n            allowTransformNone: allowTransformNone\n        }), preparseOutput: true }, props));\n}\n\nvar camelCaseAttributes = /*#__PURE__*/new Set(['baseFrequency', 'diffuseConstant', 'kernelMatrix', 'kernelUnitLength', 'keySplines', 'keyTimes', 'limitingConeAngle', 'markerHeight', 'markerWidth', 'numOctaves', 'targetX', 'targetY', 'surfaceScale', 'specularConstant', 'specularExponent', 'stdDeviation', 'tableValues']);\n\nvar defaultOrigin = 0.5;\nvar svgAttrsTemplate = function () {\n    return {\n        style: {}\n    };\n};\nvar progressToPixels = function (progress, length) {\n    return style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"].transform(progress * length);\n};\nvar unmeasured = { x: 0, y: 0, width: 0, height: 0 };\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === 'string' ? origin : style_value_types__WEBPACK_IMPORTED_MODULE_2__[\"px\"].transform(offset + size * origin);\n}\nfunction calculateSVGTransformOrigin(dimensions, originX, originY) {\n    return calcOrigin(originX, dimensions.x, dimensions.width) + \" \" + calcOrigin(originY, dimensions.y, dimensions.height);\n}\nvar svgStyleConfig = {\n    enableHardwareAcceleration: false,\n    isDashCase: false\n};\nfunction buildSVGAttrs(_a, dimensions, totalPathLength, cssBuilder, attrs, isDashCase) {\n    if (dimensions === void 0) {\n        dimensions = unmeasured;\n    }\n    if (cssBuilder === void 0) {\n        cssBuilder = createStyleBuilder(svgStyleConfig);\n    }\n    if (attrs === void 0) {\n        attrs = svgAttrsTemplate();\n    }\n    if (isDashCase === void 0) {\n        isDashCase = true;\n    }\n    var attrX = _a.attrX,\n        attrY = _a.attrY,\n        originX = _a.originX,\n        originY = _a.originY,\n        pathLength = _a.pathLength,\n        _b = _a.pathSpacing,\n        pathSpacing = _b === void 0 ? 1 : _b,\n        _c = _a.pathOffset,\n        pathOffset = _c === void 0 ? 0 : _c,\n        state = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__rest\"])(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    var style = cssBuilder(state);\n    for (var key in style) {\n        if (key === 'transform') {\n            attrs.style.transform = style[key];\n        } else {\n            var attrKey = isDashCase && !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n            attrs[attrKey] = style[key];\n        }\n    }\n    if (originX !== undefined || originY !== undefined || style.transform) {\n        attrs.style.transformOrigin = calculateSVGTransformOrigin(dimensions, originX !== undefined ? originX : defaultOrigin, originY !== undefined ? originY : defaultOrigin);\n    }\n    if (attrX !== undefined) attrs.x = attrX;\n    if (attrY !== undefined) attrs.y = attrY;\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        attrs[isDashCase ? 'stroke-dashoffset' : 'strokeDashoffset'] = progressToPixels(-pathOffset, totalPathLength);\n        attrs[isDashCase ? 'stroke-dasharray' : 'strokeDasharray'] = progressToPixels(pathLength, totalPathLength) + \" \" + progressToPixels(pathSpacing, totalPathLength);\n    }\n    return attrs;\n}\nfunction createAttrBuilder(dimensions, totalPathLength, isDashCase) {\n    if (isDashCase === void 0) {\n        isDashCase = true;\n    }\n    var attrs = svgAttrsTemplate();\n    var cssBuilder = createStyleBuilder(svgStyleConfig);\n    return function (state) {\n        return buildSVGAttrs(state, dimensions, totalPathLength, cssBuilder, attrs, isDashCase);\n    };\n}\n\nvar getDimensions = function (element) {\n    return typeof element.getBBox === 'function' ? element.getBBox() : element.getBoundingClientRect();\n};\nvar getSVGElementDimensions = function (element) {\n    try {\n        return getDimensions(element);\n    } catch (e) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n};\n\nvar isPath = function (element) {\n    return element.tagName === 'path';\n};\nvar svgStyler = /*#__PURE__*/createStyler({\n    onRead: function (key, _a) {\n        var element = _a.element;\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        if (!isTransformProp(key)) {\n            return element.getAttribute(key);\n        } else {\n            var valueType = getValueType(key);\n            return valueType ? valueType.default || 0 : 0;\n        }\n    },\n    onRender: function (state, _a) {\n        var element = _a.element,\n            buildAttrs = _a.buildAttrs;\n        var attrs = buildAttrs(state);\n        for (var key in attrs) {\n            if (key === 'style') {\n                Object.assign(element.style, attrs.style);\n            } else {\n                element.setAttribute(key, attrs[key]);\n            }\n        }\n    }\n});\nvar svg = function (element) {\n    var dimensions = getSVGElementDimensions(element);\n    var pathLength = isPath(element) && element.getTotalLength ? element.getTotalLength() : undefined;\n    return svgStyler({\n        element: element,\n        buildAttrs: createAttrBuilder(dimensions, pathLength)\n    });\n};\n\nvar viewport = /*#__PURE__*/createStyler({\n    useCache: false,\n    onRead: function (key) {\n        return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;\n    },\n    onRender: function (_a) {\n        var _b = _a.scrollTop,\n            scrollTop = _b === void 0 ? 0 : _b,\n            _c = _a.scrollLeft,\n            scrollLeft = _c === void 0 ? 0 : _c;\n        return window.scrollTo(scrollLeft, scrollTop);\n    }\n});\n\nvar cache = /*#__PURE__*/new WeakMap();\nvar isHTMLElement = function (node) {\n    return node instanceof HTMLElement || typeof node.click === 'function';\n};\nvar isSVGElement = function (node) {\n    return node instanceof SVGElement || 'ownerSVGElement' in node;\n};\nvar createDOMStyler = function (node, props) {\n    var styler;\n    if (node === window) {\n        styler = viewport(node);\n    } else if (isHTMLElement(node)) {\n        styler = createCssStyler(node, props);\n    } else if (isSVGElement(node)) {\n        styler = svg(node);\n    }\n    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__[\"invariant\"])(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');\n    cache.set(node, styler);\n    return styler;\n};\nvar getStyler = function (node, props) {\n    return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);\n};\nfunction index(nodeOrSelector, props) {\n    var node = typeof nodeOrSelector === 'string' ? document.querySelector(nodeOrSelector) : nodeOrSelector;\n    return getStyler(node, props);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlZmlyZS9kaXN0L3N0eWxlZmlyZS5lcy5qcz9kODM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlDO0FBQ1o7QUFDb0U7QUFDMUQ7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksNERBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvRUFBSyxFQUFDO0FBQzhGIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlZmlyZS9kaXN0L3N0eWxlZmlyZS5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3luYyBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgbnVtYmVyLCBjb2xvciwgcHgsIGRlZ3JlZXMsIHNjYWxlLCBhbHBoYSwgcHJvZ3Jlc3NQZXJjZW50YWdlIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5cbnZhciBjcmVhdGVTdHlsZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgb25SZWFkID0gX2Eub25SZWFkLFxuICAgICAgICBvblJlbmRlciA9IF9hLm9uUmVuZGVyLFxuICAgICAgICBfYiA9IF9hLnVuY2FjaGVkVmFsdWVzLFxuICAgICAgICB1bmNhY2hlZFZhbHVlcyA9IF9iID09PSB2b2lkIDAgPyBuZXcgU2V0KCkgOiBfYixcbiAgICAgICAgX2MgPSBfYS51c2VDYWNoZSxcbiAgICAgICAgdXNlQ2FjaGUgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jO1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgaWYgKF9hID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIF9hID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0gX19yZXN0KF9hLCBbXSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgICAgICB2YXIgY2hhbmdlZFZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5oYXNDU1NWYXJpYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldID09PSBjdXJyZW50VmFsdWUpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkVmFsdWVzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkVmFsdWVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN5bmMucmVuZGVyKHN0eWxlci5yZW5kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZXIgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXksIGZvcmNlUmVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZVJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHVzZUNhY2hlZCA9ICFmb3JjZVJlYWQgJiYgdXNlQ2FjaGUgJiYgIXVuY2FjaGVkVmFsdWVzLmhhcyhrZXkpICYmIHN0YXRlW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlQ2FjaGVkID8gc3RhdGVba2V5XSA6IG9uUmVhZChrZXksIHByb3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGtleSwgdmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlUmVuZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NoYW5nZWQgfHwgZm9yY2VSZW5kZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25SZW5kZXIoc3RhdGUsIHByb3BzLCBjaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3R5bGVyO1xuICAgIH07XG59O1xuXG52YXIgQ0FNRUxfQ0FTRV9QQVRURVJOID0gLyhbYS16XSkoW0EtWl0pL2c7XG52YXIgUkVQTEFDRV9URU1QTEFURSA9ICckMS0kMic7XG52YXIgY2FtZWxUb0Rhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKENBTUVMX0NBU0VfUEFUVEVSTiwgUkVQTEFDRV9URU1QTEFURSkudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBjYW1lbENhY2hlID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcbnZhciBkYXNoQ2FjaGUgPSAvKiNfX1BVUkVfXyovbmV3IE1hcCgpO1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnLCAnJ107XG52YXIgbnVtUHJlZml4ZXMgPSBwcmVmaXhlcy5sZW5ndGg7XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciB0ZXN0RWxlbWVudDtcbnZhciBzZXREYXNoUHJlZml4ID0gZnVuY3Rpb24gKGtleSwgcHJlZml4ZWQpIHtcbiAgICByZXR1cm4gZGFzaENhY2hlLnNldChrZXksIGNhbWVsVG9EYXNoKHByZWZpeGVkKSk7XG59O1xudmFyIHRlc3RQcmVmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByZWZpeGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBwcmVmaXggPT09ICcnO1xuICAgICAgICB2YXIgcHJlZml4ZWRQcm9wZXJ0eU5hbWUgPSBub1ByZWZpeCA/IGtleSA6IHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZWZpeGVkUHJvcGVydHlOYW1lIGluIHRlc3RFbGVtZW50LnN0eWxlIHx8IG5vUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAobm9QcmVmaXggJiYga2V5ID09PSAnY2xpcFBhdGgnICYmIGRhc2hDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbWVsQ2FjaGUuc2V0KGtleSwgcHJlZml4ZWRQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgc2V0RGFzaFByZWZpeChrZXksIFwiXCIgKyAobm9QcmVmaXggPyAnJyA6ICctJykgKyBjYW1lbFRvRGFzaChwcmVmaXhlZFByb3BlcnR5TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbnZhciBzZXRTZXJ2ZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc2V0RGFzaFByZWZpeChrZXksIGtleSk7XG59O1xudmFyIHByZWZpeGVyID0gZnVuY3Rpb24gKGtleSwgYXNEYXNoQ2FzZSkge1xuICAgIGlmIChhc0Rhc2hDYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgYXNEYXNoQ2FzZSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBhc0Rhc2hDYXNlID8gZGFzaENhY2hlIDogY2FtZWxDYWNoZTtcbiAgICBpZiAoIWNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzQnJvd3NlciA/IHRlc3RQcmVmaXgoa2V5KSA6IHNldFNlcnZlclByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KSB8fCBrZXk7XG59O1xuXG52YXIgYXhlcyA9IFsnJywgJ1gnLCAnWScsICdaJ107XG52YXIgb3JkZXIgPSBbJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAnc2tldycsICd0cmFuc2Zvcm1QZXJzcGVjdGl2ZSddO1xudmFyIHRyYW5zZm9ybVByb3BzID0gLyojX19QVVJFX18qL29yZGVyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICByZXR1cm4gYXhlcy5yZWR1Y2UoZnVuY3Rpb24gKGF4ZXNBY2MsIGF4ZXNLZXkpIHtcbiAgICAgICAgYXhlc0FjYy5wdXNoKGtleSArIGF4ZXNLZXkpO1xuICAgICAgICByZXR1cm4gYXhlc0FjYztcbiAgICB9LCBhY2MpO1xufSwgWyd4JywgJ3knLCAneiddKTtcbnZhciB0cmFuc2Zvcm1Qcm9wRGljdGlvbmFyeSA9IC8qI19fUFVSRV9fKi90cmFuc2Zvcm1Qcm9wcy5yZWR1Y2UoZnVuY3Rpb24gKGRpY3QsIGtleSkge1xuICAgIGRpY3Rba2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGRpY3Q7XG59LCB7fSk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb3BEaWN0aW9uYXJ5W2tleV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBzb3J0VHJhbnNmb3JtUHJvcHMoYSwgYikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5pbmRleE9mKGEpIC0gdHJhbnNmb3JtUHJvcHMuaW5kZXhPZihiKTtcbn1cbnZhciB0cmFuc2Zvcm1PcmlnaW5Qcm9wcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnb3JpZ2luWCcsICdvcmlnaW5ZJywgJ29yaWdpblonXSk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpblByb3BzLmhhcyhrZXkpO1xufVxuXG52YXIgaW50ID0gLyojX19QVVJFX18qL19fYXNzaWduKCAvKiNfX1BVUkVfXyovX19hc3NpZ24oe30sIG51bWJlciksIHsgdHJhbnNmb3JtOiBNYXRoLnJvdW5kIH0pO1xudmFyIHZhbHVlVHlwZXMgPSB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgICBmaWxsOiBjb2xvcixcbiAgICBzdHJva2U6IGNvbG9yLFxuICAgIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgICBib3JkZXJUb3BDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlckxlZnRDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyV2lkdGg6IHB4LFxuICAgIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgICBib3JkZXJSaWdodFdpZHRoOiBweCxcbiAgICBib3JkZXJCb3R0b21XaWR0aDogcHgsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgICBib3JkZXJSYWRpdXM6IHB4LFxuICAgIHJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBweCxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgICB3aWR0aDogcHgsXG4gICAgbWF4V2lkdGg6IHB4LFxuICAgIGhlaWdodDogcHgsXG4gICAgbWF4SGVpZ2h0OiBweCxcbiAgICBzaXplOiBweCxcbiAgICB0b3A6IHB4LFxuICAgIHJpZ2h0OiBweCxcbiAgICBib3R0b206IHB4LFxuICAgIGxlZnQ6IHB4LFxuICAgIHBhZGRpbmc6IHB4LFxuICAgIHBhZGRpbmdUb3A6IHB4LFxuICAgIHBhZGRpbmdSaWdodDogcHgsXG4gICAgcGFkZGluZ0JvdHRvbTogcHgsXG4gICAgcGFkZGluZ0xlZnQ6IHB4LFxuICAgIG1hcmdpbjogcHgsXG4gICAgbWFyZ2luVG9wOiBweCxcbiAgICBtYXJnaW5SaWdodDogcHgsXG4gICAgbWFyZ2luQm90dG9tOiBweCxcbiAgICBtYXJnaW5MZWZ0OiBweCxcbiAgICByb3RhdGU6IGRlZ3JlZXMsXG4gICAgcm90YXRlWDogZGVncmVlcyxcbiAgICByb3RhdGVZOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVo6IGRlZ3JlZXMsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHNjYWxlWDogc2NhbGUsXG4gICAgc2NhbGVZOiBzY2FsZSxcbiAgICBzY2FsZVo6IHNjYWxlLFxuICAgIHNrZXc6IGRlZ3JlZXMsXG4gICAgc2tld1g6IGRlZ3JlZXMsXG4gICAgc2tld1k6IGRlZ3JlZXMsXG4gICAgZGlzdGFuY2U6IHB4LFxuICAgIHRyYW5zbGF0ZVg6IHB4LFxuICAgIHRyYW5zbGF0ZVk6IHB4LFxuICAgIHRyYW5zbGF0ZVo6IHB4LFxuICAgIHg6IHB4LFxuICAgIHk6IHB4LFxuICAgIHo6IHB4LFxuICAgIHBlcnNwZWN0aXZlOiBweCxcbiAgICBvcGFjaXR5OiBhbHBoYSxcbiAgICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblo6IHB4LFxuICAgIHpJbmRleDogaW50LFxuICAgIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBhbHBoYSxcbiAgICBudW1PY3RhdmVzOiBpbnRcbn07XG52YXIgZ2V0VmFsdWVUeXBlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB2YWx1ZVR5cGVzW2tleV07XG59O1xudmFyIGdldFZhbHVlQXNUeXBlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHR5cGUudHJhbnNmb3JtKHZhbHVlKSA6IHZhbHVlO1xufTtcblxudmFyIFNDUk9MTF9MRUZUID0gJ3Njcm9sbExlZnQnO1xudmFyIFNDUk9MTF9UT1AgPSAnc2Nyb2xsVG9wJztcbnZhciBzY3JvbGxLZXlzID0gLyojX19QVVJFX18qL25ldyBTZXQoW1NDUk9MTF9MRUZULCBTQ1JPTExfVE9QXSk7XG5cbnZhciBibGFja2xpc3QgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbU0NST0xMX0xFRlQsIFNDUk9MTF9UT1AsICd0cmFuc2Zvcm0nXSk7XG52YXIgdHJhbnNsYXRlQWxpYXMgPSB7XG4gICAgeDogJ3RyYW5zbGF0ZVgnLFxuICAgIHk6ICd0cmFuc2xhdGVZJyxcbiAgICB6OiAndHJhbnNsYXRlWidcbn07XG5mdW5jdGlvbiBpc0N1c3RvbVRlbXBsYXRlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybShzdGF0ZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzLCB0cmFuc2Zvcm1Jc0RlZmF1bHQsIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uLCBhbGxvd1RyYW5zZm9ybU5vbmUpIHtcbiAgICBpZiAoYWxsb3dUcmFuc2Zvcm1Ob25lID09PSB2b2lkIDApIHtcbiAgICAgICAgYWxsb3dUcmFuc2Zvcm1Ob25lID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybVN0cmluZyA9ICcnO1xuICAgIHZhciB0cmFuc2Zvcm1IYXNaID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtS2V5cy5zb3J0KHNvcnRUcmFuc2Zvcm1Qcm9wcyk7XG4gICAgdmFyIG51bVRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1LZXlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRyYW5zZm9ybUtleXM7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gdHJhbnNmb3JtS2V5c1tpXTtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nICs9ICh0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleSkgKyBcIihcIiArIHRyYW5zZm9ybVtrZXldICsgXCIpIFwiO1xuICAgICAgICB0cmFuc2Zvcm1IYXNaID0ga2V5ID09PSAneicgPyB0cnVlIDogdHJhbnNmb3JtSGFzWjtcbiAgICB9XG4gICAgaWYgKCF0cmFuc2Zvcm1IYXNaICYmIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyArPSAndHJhbnNsYXRlWigwKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtU3RyaW5nLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tVGVtcGxhdGUoc3RhdGUudHJhbnNmb3JtKSkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSBzdGF0ZS50cmFuc2Zvcm0odHJhbnNmb3JtLCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPyAnJyA6IHRyYW5zZm9ybVN0cmluZyk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYW5zZm9ybU5vbmUgJiYgdHJhbnNmb3JtSXNEZWZhdWx0KSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9ICdub25lJztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3R5bGVQcm9wZXJ0eShzdGF0ZSwgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sIHN0eWxlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4sIHRyYW5zZm9ybUtleXMsIGlzRGFzaENhc2UsIGFsbG93VHJhbnNmb3JtTm9uZSkge1xuICAgIGlmIChlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0eWxlcyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtID09PSB2b2lkIDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0ge307XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1PcmlnaW4gPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSB7fTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybUtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2Zvcm1LZXlzID0gW107XG4gICAgfVxuICAgIGlmIChpc0Rhc2hDYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNEYXNoQ2FzZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dUcmFuc2Zvcm1Ob25lID09PSB2b2lkIDApIHtcbiAgICAgICAgYWxsb3dUcmFuc2Zvcm1Ob25lID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybUlzRGVmYXVsdCA9IHRydWU7XG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHZhciBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZShrZXkpO1xuICAgICAgICB2YXIgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUlzRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUuZGVmYXVsdCAmJiB2YWx1ZSAhPT0gdmFsdWVUeXBlLmRlZmF1bHQgfHwgIXZhbHVlVHlwZS5kZWZhdWx0ICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybU9yaWdpbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWJsYWNrbGlzdC5oYXMoa2V5KSB8fCAhaXNDdXN0b21UZW1wbGF0ZSh2YWx1ZUFzVHlwZSkpIHtcbiAgICAgICAgICAgIHN0eWxlc1twcmVmaXhlcihrZXksIGlzRGFzaENhc2UpXSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm0gfHwgdHlwZW9mIHN0YXRlLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm0oc3RhdGUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtS2V5cywgdHJhbnNmb3JtSXNEZWZhdWx0LCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiwgYWxsb3dUcmFuc2Zvcm1Ob25lKTtcbiAgICB9XG4gICAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICBzdHlsZXMudHJhbnNmb3JtT3JpZ2luID0gKHRyYW5zZm9ybU9yaWdpbi5vcmlnaW5YIHx8ICc1MCUnKSArIFwiIFwiICsgKHRyYW5zZm9ybU9yaWdpbi5vcmlnaW5ZIHx8ICc1MCUnKSArIFwiIFwiICsgKHRyYW5zZm9ybU9yaWdpbi5vcmlnaW5aIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlU3R5bGVCdWlsZGVyKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICAgIF9jID0gX2IuZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sXG4gICAgICAgIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYyxcbiAgICAgICAgX2QgPSBfYi5pc0Rhc2hDYXNlLFxuICAgICAgICBpc0Rhc2hDYXNlID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCxcbiAgICAgICAgX2UgPSBfYi5hbGxvd1RyYW5zZm9ybU5vbmUsXG4gICAgICAgIGFsbG93VHJhbnNmb3JtTm9uZSA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgIHZhciB0cmFuc2Zvcm0gPSB7fTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0ge307XG4gICAgdmFyIHRyYW5zZm9ybUtleXMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybUtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnVpbGRTdHlsZVByb3BlcnR5KHN0YXRlLCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiwgc3R5bGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbiwgdHJhbnNmb3JtS2V5cywgaXNEYXNoQ2FzZSwgYWxsb3dUcmFuc2Zvcm1Ob25lKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBvblJlYWQoa2V5LCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICAgIHByZXBhcnNlT3V0cHV0ID0gb3B0aW9ucy5wcmVwYXJzZU91dHB1dDtcbiAgICB2YXIgZGVmYXVsdFZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZShrZXkpO1xuICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlVHlwZSA/IGRlZmF1bHRWYWx1ZVR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICB9IGVsc2UgaWYgKHNjcm9sbEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9tVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVyKGtleSwgdHJ1ZSkpIHx8IDA7XG4gICAgICAgIHJldHVybiBwcmVwYXJzZU91dHB1dCAmJiBkZWZhdWx0VmFsdWVUeXBlICYmIGRlZmF1bHRWYWx1ZVR5cGUudGVzdChkb21WYWx1ZSkgJiYgZGVmYXVsdFZhbHVlVHlwZS5wYXJzZSA/IGRlZmF1bHRWYWx1ZVR5cGUucGFyc2UoZG9tVmFsdWUpIDogZG9tVmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gb25SZW5kZXIoc3RhdGUsIF9hLCBjaGFuZ2VkVmFsdWVzKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICBidWlsZFN0eWxlcyA9IF9hLmJ1aWxkU3R5bGVzLFxuICAgICAgICBoYXNDU1NWYXJpYWJsZSA9IF9hLmhhc0NTU1ZhcmlhYmxlO1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgYnVpbGRTdHlsZXMoc3RhdGUpKTtcbiAgICBpZiAoaGFzQ1NTVmFyaWFibGUpIHtcbiAgICAgICAgdmFyIG51bUNoYW5nZWRWYWx1ZXMgPSBjaGFuZ2VkVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFuZ2VkVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjaGFuZ2VkVmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHN0YXRlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkVmFsdWVzLmluZGV4T2YoU0NST0xMX0xFRlQpICE9PSAtMSkge1xuICAgICAgICBlbGVtZW50W1NDUk9MTF9MRUZUXSA9IHN0YXRlW1NDUk9MTF9MRUZUXTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWRWYWx1ZXMuaW5kZXhPZihTQ1JPTExfVE9QKSAhPT0gLTEpIHtcbiAgICAgICAgZWxlbWVudFtTQ1JPTExfVE9QXSA9IHN0YXRlW1NDUk9MTF9UT1BdO1xuICAgIH1cbn1cbnZhciBjc3NTdHlsZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlU3R5bGVyKHtcbiAgICBvblJlYWQ6IG9uUmVhZCxcbiAgICBvblJlbmRlcjogb25SZW5kZXIsXG4gICAgdW5jYWNoZWRWYWx1ZXM6IHNjcm9sbEtleXNcbn0pO1xuZnVuY3Rpb24gY3JlYXRlQ3NzU3R5bGVyKGVsZW1lbnQsIF9hKSB7XG4gICAgaWYgKF9hID09PSB2b2lkIDApIHtcbiAgICAgICAgX2EgPSB7fTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID0gX2EuZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sXG4gICAgICAgIGFsbG93VHJhbnNmb3JtTm9uZSA9IF9hLmFsbG93VHJhbnNmb3JtTm9uZSxcbiAgICAgICAgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uXCIsIFwiYWxsb3dUcmFuc2Zvcm1Ob25lXCJdKTtcbiAgICByZXR1cm4gY3NzU3R5bGVyKF9fYXNzaWduKHsgZWxlbWVudDogZWxlbWVudCwgYnVpbGRTdHlsZXM6IGNyZWF0ZVN0eWxlQnVpbGRlcih7XG4gICAgICAgICAgICBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sXG4gICAgICAgICAgICBhbGxvd1RyYW5zZm9ybU5vbmU6IGFsbG93VHJhbnNmb3JtTm9uZVxuICAgICAgICB9KSwgcHJlcGFyc2VPdXRwdXQ6IHRydWUgfSwgcHJvcHMpKTtcbn1cblxudmFyIGNhbWVsQ2FzZUF0dHJpYnV0ZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2Jhc2VGcmVxdWVuY3knLCAnZGlmZnVzZUNvbnN0YW50JywgJ2tlcm5lbE1hdHJpeCcsICdrZXJuZWxVbml0TGVuZ3RoJywgJ2tleVNwbGluZXMnLCAna2V5VGltZXMnLCAnbGltaXRpbmdDb25lQW5nbGUnLCAnbWFya2VySGVpZ2h0JywgJ21hcmtlcldpZHRoJywgJ251bU9jdGF2ZXMnLCAndGFyZ2V0WCcsICd0YXJnZXRZJywgJ3N1cmZhY2VTY2FsZScsICdzcGVjdWxhckNvbnN0YW50JywgJ3NwZWN1bGFyRXhwb25lbnQnLCAnc3RkRGV2aWF0aW9uJywgJ3RhYmxlVmFsdWVzJ10pO1xuXG52YXIgZGVmYXVsdE9yaWdpbiA9IDAuNTtcbnZhciBzdmdBdHRyc1RlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiB7fVxuICAgIH07XG59O1xudmFyIHByb2dyZXNzVG9QaXhlbHMgPSBmdW5jdGlvbiAocHJvZ3Jlc3MsIGxlbmd0aCkge1xuICAgIHJldHVybiBweC50cmFuc2Zvcm0ocHJvZ3Jlc3MgKiBsZW5ndGgpO1xufTtcbnZhciB1bm1lYXN1cmVkID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5mdW5jdGlvbiBjYWxjT3JpZ2luKG9yaWdpbiwgb2Zmc2V0LCBzaXplKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnID8gb3JpZ2luIDogcHgudHJhbnNmb3JtKG9mZnNldCArIHNpemUgKiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICByZXR1cm4gY2FsY09yaWdpbihvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpICsgXCIgXCIgKyBjYWxjT3JpZ2luKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xufVxudmFyIHN2Z1N0eWxlQ29uZmlnID0ge1xuICAgIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSxcbiAgICBpc0Rhc2hDYXNlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoX2EsIGRpbWVuc2lvbnMsIHRvdGFsUGF0aExlbmd0aCwgY3NzQnVpbGRlciwgYXR0cnMsIGlzRGFzaENhc2UpIHtcbiAgICBpZiAoZGltZW5zaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSB1bm1lYXN1cmVkO1xuICAgIH1cbiAgICBpZiAoY3NzQnVpbGRlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNzc0J1aWxkZXIgPSBjcmVhdGVTdHlsZUJ1aWxkZXIoc3ZnU3R5bGVDb25maWcpO1xuICAgIH1cbiAgICBpZiAoYXR0cnMgPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRycyA9IHN2Z0F0dHJzVGVtcGxhdGUoKTtcbiAgICB9XG4gICAgaWYgKGlzRGFzaENhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBpc0Rhc2hDYXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGF0dHJYID0gX2EuYXR0clgsXG4gICAgICAgIGF0dHJZID0gX2EuYXR0clksXG4gICAgICAgIG9yaWdpblggPSBfYS5vcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZID0gX2Eub3JpZ2luWSxcbiAgICAgICAgcGF0aExlbmd0aCA9IF9hLnBhdGhMZW5ndGgsXG4gICAgICAgIF9iID0gX2EucGF0aFNwYWNpbmcsXG4gICAgICAgIHBhdGhTcGFjaW5nID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYixcbiAgICAgICAgX2MgPSBfYS5wYXRoT2Zmc2V0LFxuICAgICAgICBwYXRoT2Zmc2V0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgc3RhdGUgPSBfX3Jlc3QoX2EsIFtcImF0dHJYXCIsIFwiYXR0cllcIiwgXCJvcmlnaW5YXCIsIFwib3JpZ2luWVwiLCBcInBhdGhMZW5ndGhcIiwgXCJwYXRoU3BhY2luZ1wiLCBcInBhdGhPZmZzZXRcIl0pO1xuICAgIHZhciBzdHlsZSA9IGNzc0J1aWxkZXIoc3RhdGUpO1xuICAgIGZvciAodmFyIGtleSBpbiBzdHlsZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgICAgYXR0cnMuc3R5bGUudHJhbnNmb3JtID0gc3R5bGVba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhdHRyS2V5ID0gaXNEYXNoQ2FzZSAmJiAhY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXk7XG4gICAgICAgICAgICBhdHRyc1thdHRyS2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yaWdpblggIT09IHVuZGVmaW5lZCB8fCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgfHwgc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbGN1bGF0ZVNWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB1bmRlZmluZWQgPyBvcmlnaW5YIDogZGVmYXVsdE9yaWdpbiwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkID8gb3JpZ2luWSA6IGRlZmF1bHRPcmlnaW4pO1xuICAgIH1cbiAgICBpZiAoYXR0clggIT09IHVuZGVmaW5lZCkgYXR0cnMueCA9IGF0dHJYO1xuICAgIGlmIChhdHRyWSAhPT0gdW5kZWZpbmVkKSBhdHRycy55ID0gYXR0clk7XG4gICAgaWYgKHRvdGFsUGF0aExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHBhdGhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhdHRyc1tpc0Rhc2hDYXNlID8gJ3N0cm9rZS1kYXNob2Zmc2V0JyA6ICdzdHJva2VEYXNob2Zmc2V0J10gPSBwcm9ncmVzc1RvUGl4ZWxzKC1wYXRoT2Zmc2V0LCB0b3RhbFBhdGhMZW5ndGgpO1xuICAgICAgICBhdHRyc1tpc0Rhc2hDYXNlID8gJ3N0cm9rZS1kYXNoYXJyYXknIDogJ3N0cm9rZURhc2hhcnJheSddID0gcHJvZ3Jlc3NUb1BpeGVscyhwYXRoTGVuZ3RoLCB0b3RhbFBhdGhMZW5ndGgpICsgXCIgXCIgKyBwcm9ncmVzc1RvUGl4ZWxzKHBhdGhTcGFjaW5nLCB0b3RhbFBhdGhMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRyQnVpbGRlcihkaW1lbnNpb25zLCB0b3RhbFBhdGhMZW5ndGgsIGlzRGFzaENhc2UpIHtcbiAgICBpZiAoaXNEYXNoQ2FzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzRGFzaENhc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYXR0cnMgPSBzdmdBdHRyc1RlbXBsYXRlKCk7XG4gICAgdmFyIGNzc0J1aWxkZXIgPSBjcmVhdGVTdHlsZUJ1aWxkZXIoc3ZnU3R5bGVDb25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIGRpbWVuc2lvbnMsIHRvdGFsUGF0aExlbmd0aCwgY3NzQnVpbGRlciwgYXR0cnMsIGlzRGFzaENhc2UpO1xuICAgIH07XG59XG5cbnZhciBnZXREaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyA/IGVsZW1lbnQuZ2V0QkJveCgpIDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn07XG52YXIgZ2V0U1ZHRWxlbWVudERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbn07XG5cbnZhciBpc1BhdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09ICdwYXRoJztcbn07XG52YXIgc3ZnU3R5bGVyID0gLyojX19QVVJFX18qL2NyZWF0ZVN0eWxlcih7XG4gICAgb25SZWFkOiBmdW5jdGlvbiAoa2V5LCBfYSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQ7XG4gICAgICAgIGtleSA9ICFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleTtcbiAgICAgICAgaWYgKCFpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gZ2V0VmFsdWVUeXBlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlID8gdmFsdWVUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cnMgPSBfYS5idWlsZEF0dHJzO1xuICAgICAgICB2YXIgYXR0cnMgPSBidWlsZEF0dHJzKHN0YXRlKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBhdHRycy5zdHlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbnZhciBzdmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBkaW1lbnNpb25zID0gZ2V0U1ZHRWxlbWVudERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgdmFyIHBhdGhMZW5ndGggPSBpc1BhdGgoZWxlbWVudCkgJiYgZWxlbWVudC5nZXRUb3RhbExlbmd0aCA/IGVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3ZnU3R5bGVyKHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgYnVpbGRBdHRyczogY3JlYXRlQXR0ckJ1aWxkZXIoZGltZW5zaW9ucywgcGF0aExlbmd0aClcbiAgICB9KTtcbn07XG5cbnZhciB2aWV3cG9ydCA9IC8qI19fUFVSRV9fKi9jcmVhdGVTdHlsZXIoe1xuICAgIHVzZUNhY2hlOiBmYWxzZSxcbiAgICBvblJlYWQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ3Njcm9sbFRvcCcgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgICAgICBfYyA9IF9hLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApO1xuICAgIH1cbn0pO1xuXG52YXIgY2FjaGUgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBpc0hUTUxFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHR5cGVvZiBub2RlLmNsaWNrID09PSAnZnVuY3Rpb24nO1xufTtcbnZhciBpc1NWR0VsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCB8fCAnb3duZXJTVkdFbGVtZW50JyBpbiBub2RlO1xufTtcbnZhciBjcmVhdGVET01TdHlsZXIgPSBmdW5jdGlvbiAobm9kZSwgcHJvcHMpIHtcbiAgICB2YXIgc3R5bGVyO1xuICAgIGlmIChub2RlID09PSB3aW5kb3cpIHtcbiAgICAgICAgc3R5bGVyID0gdmlld3BvcnQobm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHN0eWxlciA9IGNyZWF0ZUNzc1N0eWxlcihub2RlLCBwcm9wcyk7XG4gICAgfSBlbHNlIGlmIChpc1NWR0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgc3R5bGVyID0gc3ZnKG5vZGUpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoc3R5bGVyICE9PSB1bmRlZmluZWQsICdObyB2YWxpZCBub2RlIHByb3ZpZGVkLiBOb2RlIG11c3QgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQgb3Igd2luZG93LicpO1xuICAgIGNhY2hlLnNldChub2RlLCBzdHlsZXIpO1xuICAgIHJldHVybiBzdHlsZXI7XG59O1xudmFyIGdldFN0eWxlciA9IGZ1bmN0aW9uIChub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBjYWNoZS5oYXMobm9kZSkgPyBjYWNoZS5nZXQobm9kZSkgOiBjcmVhdGVET01TdHlsZXIobm9kZSwgcHJvcHMpO1xufTtcbmZ1bmN0aW9uIGluZGV4KG5vZGVPclNlbGVjdG9yLCBwcm9wcykge1xuICAgIHZhciBub2RlID0gdHlwZW9mIG5vZGVPclNlbGVjdG9yID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iobm9kZU9yU2VsZWN0b3IpIDogbm9kZU9yU2VsZWN0b3I7XG4gICAgcmV0dXJuIGdldFN0eWxlcihub2RlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgYnVpbGRTVkdBdHRycywgYnVpbGRTdHlsZVByb3BlcnR5LCBjcmVhdGVTdHlsZXIgYXMgY3JlYXRlU3R5bGVyRmFjdG9yeSwgaXNUcmFuc2Zvcm1Qcm9wLCB0cmFuc2Zvcm1Qcm9wcyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/stylefire/dist/stylefire.es.js\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__createBinding\", function() { return __createBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldGet\", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldSet\", function() { return __classPrivateFieldSet; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7O0FBRU87QUFDUDtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFTztBQUNQO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTs7QUFFTztBQUNQLG1DQUFtQyxvQ0FBb0M7QUFDdkU7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1AsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEsRUFBRTtBQUN4SixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQyxrQ0FBa0MsV0FBVyxVQUFVO0FBQ3ZELHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsNkdBQTZHLE9BQU8sVUFBVTtBQUM5SCxnRkFBZ0YsaUJBQWlCLE9BQU87QUFDeEcsd0RBQXdELGdCQUFnQixRQUFRLE9BQU87QUFDdkYsOENBQThDLGdCQUFnQixnQkFBZ0IsT0FBTztBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUyxZQUFZLGFBQWEsT0FBTyxFQUFFLFVBQVUsV0FBVztBQUNoRSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFTztBQUNQLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVPO0FBQ1AsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsc0ZBQXNGLGFBQWEsRUFBRTtBQUN0SCxzQkFBc0IsZ0NBQWdDLHFDQUFxQywwQ0FBMEMsRUFBRSxFQUFFLEdBQUc7QUFDNUksMkJBQTJCLE1BQU0sZUFBZSxFQUFFLFlBQVksb0JBQW9CLEVBQUU7QUFDcEYsc0JBQXNCLG9HQUFvRztBQUMxSCw2QkFBNkIsdUJBQXVCO0FBQ3BELDRCQUE0Qix3QkFBd0I7QUFDcEQsMkJBQTJCLHlEQUF5RDtBQUNwRjs7QUFFTztBQUNQO0FBQ0EsaUJBQWlCLDRDQUE0QyxTQUFTLEVBQUUscURBQXFELGFBQWEsRUFBRTtBQUM1SSx5QkFBeUIsNkJBQTZCLG9CQUFvQixnREFBZ0QsZ0JBQWdCLEVBQUUsS0FBSztBQUNqSjs7QUFFTztBQUNQO0FBQ0E7QUFDQSwyR0FBMkcsc0ZBQXNGLGFBQWEsRUFBRTtBQUNoTixzQkFBc0IsOEJBQThCLGdEQUFnRCx1REFBdUQsRUFBRSxFQUFFLEdBQUc7QUFDbEssNENBQTRDLHNDQUFzQyxVQUFVLG9CQUFvQixFQUFFLEVBQUUsVUFBVTtBQUM5SDs7QUFFTztBQUNQLGdDQUFnQyx1Q0FBdUMsYUFBYSxFQUFFLEVBQUUsT0FBTyxrQkFBa0I7QUFDakg7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLDRDQUE0QztBQUM1Qzs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./pages/projects.js":
/*!***************************!*\
  !*** ./pages/projects.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Projects; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _projects_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projects.module.scss */ \"./pages/projects.module.scss\");\n/* harmony import */ var _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_projects_module_scss__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Container */ \"./components/Container.js\");\n/* harmony import */ var _components_Nav__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Nav */ \"./components/Nav.js\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! framer-motion */ \"./node_modules/framer-motion/dist/framer-motion.es.js\");\nvar _jsxFileName = \"/home/macmac/Projects/markanthonyuy.github.io/pages/projects.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\nfunction Projects() {\n  var _this = this;\n\n  var container = {\n    hidden: {\n      opacity: 0\n    },\n    show: {\n      opacity: 1,\n      transition: {\n        delay: 0.7,\n        delayChildren: 0.3,\n        staggerChildren: 0.1\n      }\n    }\n  };\n  var item = {\n    hidden: {\n      opacity: 0\n    },\n    show: {\n      opacity: 1\n    }\n  };\n  var projects = [{\n    name: \"Uno's Baptism\",\n    link: 'https://uno-baptism.vercel.app/',\n    desc: \"Uno's baptism photos.\",\n    uses: ['Nextjs', 'Cloudinary'],\n    active: true\n  }, {\n    name: \"Uno's Record\",\n    link: 'https://uno-records.vercel.app/',\n    desc: \"Uno's immunization Records.\",\n    uses: ['Nextjs', 'Framer'],\n    active: true\n  }, {\n    name: 'Manga Go',\n    link: 'https://mangago.vercel.app/',\n    desc: 'Discover Manga on the Go.',\n    uses: ['Nextjs', 'Chakra UI', 'Valtio'],\n    active: true\n  }, {\n    name: 'Github Jobs',\n    link: 'https://ghjobs.netlify.app/',\n    desc: 'My Version of Github Jobs.',\n    uses: ['Reactjs', 'Material UI', 'Serverless'],\n    active: false\n  }, {\n    name: 'Hacker News',\n    link: 'https://newshacker.vercel.app/',\n    desc: 'The Purple Hacker News.',\n    uses: ['Nextjs', 'Styled-Components'],\n    active: true\n  }, {\n    name: 'Puck Board Game',\n    link: 'https://codepen.io/markanthonyuy/pen/qBbNGQJ',\n    desc: 'Perya (Carnival) inspired game.',\n    uses: ['Pug', 'Javascript'],\n    active: true\n  }, {\n    name: 'Jejenator',\n    link: 'https://jejenator.netlify.app/',\n    desc: 'The Jejemon Generator. Converts regular word to a Jejemon word.',\n    uses: ['Sveltejs'],\n    active: true\n  }, {\n    name: 'Personal Website',\n    link: 'https://markanthonyuy.com/',\n    desc: 'This is the version 2 personal website.',\n    uses: ['Nextjs', 'Framer', 'PWA'],\n    active: true\n  }, {\n    name: 'Bingoo',\n    link: 'https://bingoo.now.sh/',\n    desc: 'Fun to play Bingo Game.',\n    uses: ['Reactjs', 'Framer', 'Styled-Components'],\n    active: true\n  }, {\n    name: 'Covid 19 Philippines Tracker',\n    link: 'https://covid-19-ph.vercel.app/',\n    desc: 'Dedicated Covid 19 Tracker for Philippines.',\n    uses: ['Reactjs', 'Tailwind'],\n    active: true\n  }, {\n    name: 'Philippine UITF Listing',\n    link: 'https://uitf.now.sh/',\n    desc: \"Updated market value of UITF's available in the Philippines.\",\n    uses: ['Reactjs', 'Material UI', 'PWA'],\n    active: true\n  }, {\n    name: 'Cryptomark',\n    link: 'https://cryptomark.now.sh/',\n    desc: 'Compare Cryptocurrencies Realtime.',\n    uses: ['Reactjs', 'Bulma'],\n    active: true\n  }, {\n    name: 'Pokemon DB',\n    link: 'https://pokedb.now.sh/',\n    desc: 'Pokemon Database.',\n    uses: ['Nextjs', 'Framer', 'Sass'],\n    active: true\n  }, {\n    name: 'Dota 2 Leaderboards',\n    link: 'https://dota2leaderboards.now.sh/',\n    desc: 'List of Dota2 players with the highest Rank.',\n    uses: ['Nextjs', 'Framer', 'Serverless'],\n    active: true\n  }, {\n    name: 'Dota 2 Earnings',\n    link: 'https://dota2earnings.now.sh/',\n    desc: 'List of Dota 2 professional players with the highest earnings.',\n    uses: ['Nextjs', 'Framer', 'Serverless'],\n    active: true\n  }, {\n    name: 'Palitan',\n    link: 'https://markanthonyuy.com/palitan/',\n    desc: 'Simple currency exchange rate.',\n    uses: ['Reactjs'],\n    active: false\n  }, {\n    name: 'Manga Libre',\n    link: 'https://mangalibre.herokuapp.com/',\n    desc: 'Free, fast, simple and straightforward Manga Reader.',\n    uses: ['Backbonejs', 'Jquery'],\n    active: false\n  }, {\n    name: 'Libre Manga',\n    link: 'https://libremanga.herokuapp.com/',\n    desc: 'My first manga reader app.',\n    uses: ['HTML', 'CSS', 'Jquery'],\n    active: false\n  }, {\n    name: 'Marktip',\n    link: 'https://markanthonyuy.com/markTip/',\n    desc: 'Jquery tootlip plugin.',\n    uses: ['Javascript', 'Jquery'],\n    active: true\n  }, {\n    name: 'Randomizer',\n    link: 'https://markanthonyuy.com/randomizer/',\n    desc: 'Random Team Generator.',\n    uses: ['HTML', 'CSS', 'Javascript'],\n    active: true\n  }];\n  return __jsx(_components_Container__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 5\n    }\n  }, __jsx(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 7\n    }\n  }, __jsx(\"meta\", {\n    name: \"description\",\n    content: \"Here are some of the projects that I've built over the course of my career.\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 9\n    }\n  }), __jsx(\"title\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 175,\n      columnNumber: 9\n    }\n  }, \"My Projects | Mark Anthony Uy\")), __jsx(_components_Nav__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n    active: \"projects\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 7\n    }\n  }), __jsx(\"div\", {\n    className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.project,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }\n  }, __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].h1, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 179,\n      columnNumber: 9\n    }\n  }, \"My Work\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].h2, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.2\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 9\n    }\n  }, \"Professional\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].p, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.3\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 9\n    }\n  }, \"I'm currently maintaining and developing an ecommerce site.\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].h2, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.4\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 9\n    }\n  }, \"Personal\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].p, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.5\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 9\n    }\n  }, \"During my pastime I like to think of how can I solve problems. Just simple problems that I'm having. I remember a colleague of mine first made a Manga reader. I was in awe and got really inspired. Since I love reading manga, I told myself what is the problem that I mostly encounter when doing so. The answers are loading speed, poor UI and Ads everywhere! If you are reading manga as well, you are definitely aware of the problems I just mentioned. Besides, manga images are notorious for their large size and the websites are bombarded with ads. Quite annoying. Though, I don't blame them if that's how they make money. Anyway, I just took action on the matter and build my own Manga Reader. And\", ' ', __jsx(\"a\", {\n    href: \"http://libremanga.herokuapp.com/\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 11\n    }\n  }, \"Libremanga\"), \" was born. (FYI, this is not maintained and the API is now inactive.) My first web app. Then the rest is history :)\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].blockquote, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.5\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 227,\n      columnNumber: 9\n    }\n  }, __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 11\n    }\n  }, \"\\u201CA problem is a chance for you to do your best.\\u201D \\u2015 Duke Ellington\")), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].p, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.5\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 236,\n      columnNumber: 9\n    }\n  }, \"I like to use different tech/tools when creating my own app. Mix and match to see which will be the best fit for the requirements and my style. This is one of the great parts of doing your own projects. You get to decide which one to use. I'm my own BOSS!\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].p, {\n    initial: {\n      y: 50,\n      opacity: 0\n    },\n    animate: {\n      y: 0,\n      opacity: 1,\n      transition: {\n        delay: 0.5\n      }\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 246,\n      columnNumber: 9\n    }\n  }, \"Here are some of my personal projects. Or you can check out my\", ' ', __jsx(\"a\", {\n    href: \"https://github.com/markanthonyuy\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 11\n    }\n  }, \"github account\"), \".\"), __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].div, {\n    className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.list,\n    variants: container,\n    initial: \"hidden\",\n    animate: \"show\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 254,\n      columnNumber: 9\n    }\n  }, projects.map(function (project) {\n    return __jsx(framer_motion__WEBPACK_IMPORTED_MODULE_5__[\"motion\"].div, {\n      variants: item,\n      key: project.name,\n      className: \"\".concat(!project.active ? _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.broken : ''),\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 261,\n        columnNumber: 13\n      }\n    }, __jsx(\"div\", {\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.top,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 266,\n        columnNumber: 15\n      }\n    }, __jsx(\"a\", {\n      href: project.link,\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.title,\n      target: \"_blank\",\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 17\n      }\n    }, project.name), __jsx(\"a\", {\n      href: project.link,\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.icon,\n      target: \"_blank\",\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270,\n        columnNumber: 17\n      }\n    }, __jsx(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 640 640\",\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 271,\n        columnNumber: 19\n      }\n    }, __jsx(\"path\", {\n      d: \"M41.28 10.323h178.774l73.052 82.466H115.194c-17.61 0-32.02 14.41-32.02 32.02v401.403c0 17.598 14.41 32.02 32.02 32.02h406.328c17.61 0 32.02-14.422 32.02-32.02v-181.62l83.174 69.19v185.624c0 22.7-18.567 41.28-41.28 41.28H41.28c-22.712 0-41.28-18.58-41.28-41.28V51.604c0-22.702 18.568-41.28 41.28-41.28zM640-.685L311.378 13.843l104.801 104.8-230.755 230.744 101.21 101.21 230.755-230.755 106.82 106.82L640-.685z\",\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 21\n      }\n    })))), __jsx(\"span\", {\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.desc,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 276,\n        columnNumber: 15\n      }\n    }, project.desc), __jsx(\"span\", {\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.built,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 277,\n        columnNumber: 15\n      }\n    }, project.uses.map(function (u, key) {\n      return __jsx(\"span\", {\n        key: \"\".concat(u, \"-\").concat(key),\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 279,\n          columnNumber: 19\n        }\n      }, u);\n    })), !project.active ? __jsx(\"span\", {\n      className: _projects_module_scss__WEBPACK_IMPORTED_MODULE_2___default.a.brokenAPI,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 283,\n        columnNumber: 17\n      }\n    }, \"Deprecated API\") : null);\n  }))));\n}\n_c = Projects;\n\nvar _c;\n\n$RefreshReg$(_c, \"Projects\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvcHJvamVjdHMuanM/NDQ3MSJdLCJuYW1lcyI6WyJQcm9qZWN0cyIsImNvbnRhaW5lciIsImhpZGRlbiIsIm9wYWNpdHkiLCJzaG93IiwidHJhbnNpdGlvbiIsImRlbGF5IiwiZGVsYXlDaGlsZHJlbiIsInN0YWdnZXJDaGlsZHJlbiIsIml0ZW0iLCJwcm9qZWN0cyIsIm5hbWUiLCJsaW5rIiwiZGVzYyIsInVzZXMiLCJhY3RpdmUiLCJzdHlsZXMiLCJwcm9qZWN0IiwieSIsImxpc3QiLCJtYXAiLCJicm9rZW4iLCJ0b3AiLCJ0aXRsZSIsImljb24iLCJidWlsdCIsInUiLCJrZXkiLCJicm9rZW5BUEkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVlLFNBQVNBLFFBQVQsR0FBb0I7QUFBQTs7QUFDakMsTUFBTUMsU0FBUyxHQUFHO0FBQ2hCQyxVQUFNLEVBQUU7QUFBRUMsYUFBTyxFQUFFO0FBQVgsS0FEUTtBQUVoQkMsUUFBSSxFQUFFO0FBQ0pELGFBQU8sRUFBRSxDQURMO0FBRUpFLGdCQUFVLEVBQUU7QUFDVkMsYUFBSyxFQUFFLEdBREc7QUFFVkMscUJBQWEsRUFBRSxHQUZMO0FBR1ZDLHVCQUFlLEVBQUU7QUFIUDtBQUZSO0FBRlUsR0FBbEI7QUFZQSxNQUFNQyxJQUFJLEdBQUc7QUFDWFAsVUFBTSxFQUFFO0FBQUVDLGFBQU8sRUFBRTtBQUFYLEtBREc7QUFFWEMsUUFBSSxFQUFFO0FBQUVELGFBQU8sRUFBRTtBQUFYO0FBRkssR0FBYjtBQUtBLE1BQU1PLFFBQVEsR0FBRyxDQUNmO0FBQ0VDLFFBQUksRUFBRSxlQURSO0FBRUVDLFFBQUksRUFBRSxpQ0FGUjtBQUdFQyxRQUFJLEVBQUUsdUJBSFI7QUFJRUMsUUFBSSxFQUFFLENBQUMsUUFBRCxFQUFXLFlBQVgsQ0FKUjtBQUtFQyxVQUFNLEVBQUU7QUFMVixHQURlLEVBUWY7QUFDRUosUUFBSSxFQUFF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UixPQUFPLENBQUNILElBQVIsQ0FBYU0sR0FBYixDQUFpQixVQUFDTSxDQUFELEVBQUlDLEdBQUo7QUFBQSxhQUNoQjtBQUFNLFdBQUcsWUFBS0QsQ0FBTCxjQUFVQyxHQUFWLENBQVQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUEyQkQsQ0FBM0IsQ0FEZ0I7QUFBQSxLQUFqQixDQURILENBaEJGLEVBcUJHLENBQUNULE9BQU8sQ0FBQ0YsTUFBVCxHQUNDO0FBQU0sZUFBUyxFQUFFQyw0REFBTSxDQUFDWSxTQUF4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHdCQURELEdBRUcsSUF2Qk4sQ0FEWTtBQUFBLEdBQWIsQ0FOSCxDQTVFRixDQVRGLENBREY7QUEySEQ7S0E1UnVCNUIsUSIsImZpbGUiOiIuL3BhZ2VzL3Byb2plY3RzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJ1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3Byb2plY3RzLm1vZHVsZS5zY3NzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRhaW5lcidcbmltcG9ydCBOYXYgZnJvbSAnLi4vY29tcG9uZW50cy9OYXYnXG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tICdmcmFtZXItbW90aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQcm9qZWN0cygpIHtcbiAgY29uc3QgY29udGFpbmVyID0ge1xuICAgIGhpZGRlbjogeyBvcGFjaXR5OiAwIH0sXG4gICAgc2hvdzoge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgZGVsYXk6IDAuNyxcbiAgICAgICAgZGVsYXlDaGlsZHJlbjogMC4zLFxuICAgICAgICBzdGFnZ2VyQ2hpbGRyZW46IDAuMSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaGlkZGVuOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBzaG93OiB7IG9wYWNpdHk6IDEgfSxcbiAgfVxuXG4gIGNvbnN0IHByb2plY3RzID0gW1xuICAgIHtcbiAgICAgIG5hbWU6IFwiVW5vJ3MgQmFwdGlzbVwiLFxuICAgICAgbGluazogJ2h0dHBzOi8vdW5vLWJhcHRpc20udmVyY2VsLmFwcC8nLFxuICAgICAgZGVzYzogXCJVbm8ncyBiYXB0aXNtIHBob3Rvcy5cIixcbiAgICAgIHVzZXM6IFsnTmV4dGpzJywgJ0Nsb3VkaW5hcnknXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiVW5vJ3MgUmVjb3JkXCIsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly91bm8tcmVjb3Jkcy52ZXJjZWwuYXBwLycsXG4gICAgICBkZXNjOiBcIlVubydzIGltbXVuaXphdGlvbiBSZWNvcmRzLlwiLFxuICAgICAgdXNlczogWydOZXh0anMnLCAnRnJhbWVyJ10sXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnTWFuZ2EgR28nLFxuICAgICAgbGluazogJ2h0dHBzOi8vbWFuZ2Fnby52ZXJjZWwuYXBwLycsXG4gICAgICBkZXNjOiAnRGlzY292ZXIgTWFuZ2Egb24gdGhlIEdvLicsXG4gICAgICB1c2VzOiBbJ05leHRqcycsICdDaGFrcmEgVUknLCAnVmFsdGlvJ10sXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnR2l0aHViIEpvYnMnLFxuICAgICAgbGluazogJ2h0dHBzOi8vZ2hqb2JzLm5ldGxpZnkuYXBwLycsXG4gICAgICBkZXNjOiAnTXkgVmVyc2lvbiBvZiBHaXRodWIgSm9icy4nLFxuICAgICAgdXNlczogWydSZWFjdGpzJywgJ01hdGVyaWFsIFVJJywgJ1NlcnZlcmxlc3MnXSxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnSGFja2VyIE5ld3MnLFxuICAgICAgbGluazogJ2h0dHBzOi8vbmV3c2hhY2tlci52ZXJjZWwuYXBwLycsXG4gICAgICBkZXNjOiAnVGhlIFB1cnBsZSBIYWNrZXIgTmV3cy4nLFxuICAgICAgdXNlczogWydOZXh0anMnLCAnU3R5bGVkLUNvbXBvbmVudHMnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdQdWNrIEJvYXJkIEdhbWUnLFxuICAgICAgbGluazogJ2h0dHBzOi8vY29kZXBlbi5pby9tYXJrYW50aG9ueXV5L3Blbi9xQmJOR1FKJyxcbiAgICAgIGRlc2M6ICdQZXJ5YSAoQ2Fybml2YWwpIGluc3BpcmVkIGdhbWUuJyxcbiAgICAgIHVzZXM6IFsnUHVnJywgJ0phdmFzY3JpcHQnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdKZWplbmF0b3InLFxuICAgICAgbGluazogJ2h0dHBzOi8vamVqZW5hdG9yLm5ldGxpZnkuYXBwLycsXG4gICAgICBkZXNjOiAnVGhlIEplamVtb24gR2VuZXJhdG9yLiBDb252ZXJ0cyByZWd1bGFyIHdvcmQgdG8gYSBKZWplbW9uIHdvcmQuJyxcbiAgICAgIHVzZXM6IFsnU3ZlbHRlanMnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdQZXJzb25hbCBXZWJzaXRlJyxcbiAgICAgIGxpbms6ICdodHRwczovL21hcmthbnRob255dXkuY29tLycsXG4gICAgICBkZXNjOiAnVGhpcyBpcyB0aGUgdmVyc2lvbiAyIHBlcnNvbmFsIHdlYnNpdGUuJyxcbiAgICAgIHVzZXM6IFsnTmV4dGpzJywgJ0ZyYW1lcicsICdQV0EnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdCaW5nb28nLFxuICAgICAgbGluazogJ2h0dHBzOi8vYmluZ29vLm5vdy5zaC8nLFxuICAgICAgZGVzYzogJ0Z1biB0byBwbGF5IEJpbmdvIEdhbWUuJyxcbiAgICAgIHVzZXM6IFsnUmVhY3RqcycsICdGcmFtZXInLCAnU3R5bGVkLUNvbXBvbmVudHMnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdDb3ZpZCAxOSBQaGlsaXBwaW5lcyBUcmFja2VyJyxcbiAgICAgIGxpbms6ICdodHRwczovL2NvdmlkLTE5LXBoLnZlcmNlbC5hcHAvJyxcbiAgICAgIGRlc2M6ICdEZWRpY2F0ZWQgQ292aWQgMTkgVHJhY2tlciBmb3IgUGhpbGlwcGluZXMuJyxcbiAgICAgIHVzZXM6IFsnUmVhY3RqcycsICdUYWlsd2luZCddLFxuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ1BoaWxpcHBpbmUgVUlURiBMaXN0aW5nJyxcbiAgICAgIGxpbms6ICdodHRwczovL3VpdGYubm93LnNoLycsXG4gICAgICBkZXNjOiBcIlVwZGF0ZWQgbWFya2V0IHZhbHVlIG9mIFVJVEYncyBhdmFpbGFibGUgaW4gdGhlIFBoaWxpcHBpbmVzLlwiLFxuICAgICAgdXNlczogWydSZWFjdGpzJywgJ01hdGVyaWFsIFVJJywgJ1BXQSddLFxuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0NyeXB0b21hcmsnLFxuICAgICAgbGluazogJ2h0dHBzOi8vY3J5cHRvbWFyay5ub3cuc2gvJyxcbiAgICAgIGRlc2M6ICdDb21wYXJlIENyeXB0b2N1cnJlbmNpZXMgUmVhbHRpbWUuJyxcbiAgICAgIHVzZXM6IFsnUmVhY3RqcycsICdCdWxtYSddLFxuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ1Bva2Vtb24gREInLFxuICAgICAgbGluazogJ2h0dHBzOi8vcG9rZWRiLm5vdy5zaC8nLFxuICAgICAgZGVzYzogJ1Bva2Vtb24gRGF0YWJhc2UuJyxcbiAgICAgIHVzZXM6IFsnTmV4dGpzJywgJ0ZyYW1lcicsICdTYXNzJ10sXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnRG90YSAyIExlYWRlcmJvYXJkcycsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9kb3RhMmxlYWRlcmJvYXJkcy5ub3cuc2gvJyxcbiAgICAgIGRlc2M6ICdMaXN0IG9mIERvdGEyIHBsYXllcnMgd2l0aCB0aGUgaGlnaGVzdCBSYW5rLicsXG4gICAgICB1c2VzOiBbJ05leHRqcycsICdGcmFtZXInLCAnU2VydmVybGVzcyddLFxuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0RvdGEgMiBFYXJuaW5ncycsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9kb3RhMmVhcm5pbmdzLm5vdy5zaC8nLFxuICAgICAgZGVzYzogJ0xpc3Qgb2YgRG90YSAyIHByb2Zlc3Npb25hbCBwbGF5ZXJzIHdpdGggdGhlIGhpZ2hlc3QgZWFybmluZ3MuJyxcbiAgICAgIHVzZXM6IFsnTmV4dGpzJywgJ0ZyYW1lcicsICdTZXJ2ZXJsZXNzJ10sXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnUGFsaXRhbicsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9tYXJrYW50aG9ueXV5LmNvbS9wYWxpdGFuLycsXG4gICAgICBkZXNjOiAnU2ltcGxlIGN1cnJlbmN5IGV4Y2hhbmdlIHJhdGUuJyxcbiAgICAgIHVzZXM6IFsnUmVhY3RqcyddLFxuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdNYW5nYSBMaWJyZScsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9tYW5nYWxpYnJlLmhlcm9rdWFwcC5jb20vJyxcbiAgICAgIGRlc2M6ICdGcmVlLCBmYXN0LCBzaW1wbGUgYW5kIHN0cmFpZ2h0Zm9yd2FyZCBNYW5nYSBSZWFkZXIuJyxcbiAgICAgIHVzZXM6IFsnQmFja2JvbmVqcycsICdKcXVlcnknXSxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnTGlicmUgTWFuZ2EnLFxuICAgICAgbGluazogJ2h0dHBzOi8vbGlicmVtYW5nYS5oZXJva3VhcHAuY29tLycsXG4gICAgICBkZXNjOiAnTXkgZmlyc3QgbWFuZ2EgcmVhZGVyIGFwcC4nLFxuICAgICAgdXNlczogWydIVE1MJywgJ0NTUycsICdKcXVlcnknXSxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnTWFya3RpcCcsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9tYXJrYW50aG9ueXV5LmNvbS9tYXJrVGlwLycsXG4gICAgICBkZXNjOiAnSnF1ZXJ5IHRvb3RsaXAgcGx1Z2luLicsXG4gICAgICB1c2VzOiBbJ0phdmFzY3JpcHQnLCAnSnF1ZXJ5J10sXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnUmFuZG9taXplcicsXG4gICAgICBsaW5rOiAnaHR0cHM6Ly9tYXJrYW50aG9ueXV5LmNvbS9yYW5kb21pemVyLycsXG4gICAgICBkZXNjOiAnUmFuZG9tIFRlYW0gR2VuZXJhdG9yLicsXG4gICAgICB1c2VzOiBbJ0hUTUwnLCAnQ1NTJywgJ0phdmFzY3JpcHQnXSxcbiAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICBdXG5cbiAgcmV0dXJuIChcbiAgICA8Q29udGFpbmVyPlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDxtZXRhXG4gICAgICAgICAgbmFtZT1cImRlc2NyaXB0aW9uXCJcbiAgICAgICAgICBjb250ZW50PVwiSGVyZSBhcmUgc29tZSBvZiB0aGUgcHJvamVjdHMgdGhhdCBJJ3ZlIGJ1aWx0IG92ZXIgdGhlIGNvdXJzZSBvZiBteSBjYXJlZXIuXCJcbiAgICAgICAgPjwvbWV0YT5cbiAgICAgICAgPHRpdGxlPk15IFByb2plY3RzIHwgTWFyayBBbnRob255IFV5PC90aXRsZT5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxOYXYgYWN0aXZlPVwicHJvamVjdHNcIiAvPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wcm9qZWN0fT5cbiAgICAgICAgPG1vdGlvbi5oMVxuICAgICAgICAgIGluaXRpYWw9e3sgeTogNTAsIG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IHk6IDAsIG9wYWNpdHk6IDEgfX1cbiAgICAgICAgPlxuICAgICAgICAgIE15IFdvcmtcbiAgICAgICAgPC9tb3Rpb24uaDE+XG5cbiAgICAgICAgPG1vdGlvbi5oMlxuICAgICAgICAgIGluaXRpYWw9e3sgeTogNTAsIG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IHk6IDAsIG9wYWNpdHk6IDEsIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuMiB9IH19XG4gICAgICAgID5cbiAgICAgICAgICBQcm9mZXNzaW9uYWxcbiAgICAgICAgPC9tb3Rpb24uaDI+XG5cbiAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgaW5pdGlhbD17eyB5OiA1MCwgb3BhY2l0eTogMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgeTogMCwgb3BhY2l0eTogMSwgdHJhbnNpdGlvbjogeyBkZWxheTogMC4zIH0gfX1cbiAgICAgICAgPlxuICAgICAgICAgIEknbSBjdXJyZW50bHkgbWFpbnRhaW5pbmcgYW5kIGRldmVsb3BpbmcgYW4gZWNvbW1lcmNlIHNpdGUuXG4gICAgICAgIDwvbW90aW9uLnA+XG5cbiAgICAgICAgPG1vdGlvbi5oMlxuICAgICAgICAgIGluaXRpYWw9e3sgeTogNTAsIG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IHk6IDAsIG9wYWNpdHk6IDEsIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNCB9IH19XG4gICAgICAgID5cbiAgICAgICAgICBQZXJzb25hbFxuICAgICAgICA8L21vdGlvbi5oMj5cblxuICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICBpbml0aWFsPXt7IHk6IDUwLCBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgYW5pbWF0ZT17eyB5OiAwLCBvcGFjaXR5OiAxLCB0cmFuc2l0aW9uOiB7IGRlbGF5OiAwLjUgfSB9fVxuICAgICAgICA+XG4gICAgICAgICAgRHVyaW5nIG15IHBhc3RpbWUgSSBsaWtlIHRvIHRoaW5rIG9mIGhvdyBjYW4gSSBzb2x2ZSBwcm9ibGVtcy4gSnVzdFxuICAgICAgICAgIHNpbXBsZSBwcm9ibGVtcyB0aGF0IEknbSBoYXZpbmcuIEkgcmVtZW1iZXIgYSBjb2xsZWFndWUgb2YgbWluZSBmaXJzdFxuICAgICAgICAgIG1hZGUgYSBNYW5nYSByZWFkZXIuIEkgd2FzIGluIGF3ZSBhbmQgZ290IHJlYWxseSBpbnNwaXJlZC4gU2luY2UgSVxuICAgICAgICAgIGxvdmUgcmVhZGluZyBtYW5nYSwgSSB0b2xkIG15c2VsZiB3aGF0IGlzIHRoZSBwcm9ibGVtIHRoYXQgSSBtb3N0bHlcbiAgICAgICAgICBlbmNvdW50ZXIgd2hlbiBkb2luZyBzby4gVGhlIGFuc3dlcnMgYXJlIGxvYWRpbmcgc3BlZWQsIHBvb3IgVUkgYW5kXG4gICAgICAgICAgQWRzIGV2ZXJ5d2hlcmUhIElmIHlvdSBhcmUgcmVhZGluZyBtYW5nYSBhcyB3ZWxsLCB5b3UgYXJlIGRlZmluaXRlbHlcbiAgICAgICAgICBhd2FyZSBvZiB0aGUgcHJvYmxlbXMgSSBqdXN0IG1lbnRpb25lZC4gQmVzaWRlcywgbWFuZ2EgaW1hZ2VzIGFyZVxuICAgICAgICAgIG5vdG9yaW91cyBmb3IgdGhlaXIgbGFyZ2Ugc2l6ZSBhbmQgdGhlIHdlYnNpdGVzIGFyZSBib21iYXJkZWQgd2l0aFxuICAgICAgICAgIGFkcy4gUXVpdGUgYW5ub3lpbmcuIFRob3VnaCwgSSBkb24ndCBibGFtZSB0aGVtIGlmIHRoYXQncyBob3cgdGhleVxuICAgICAgICAgIG1ha2UgbW9uZXkuIEFueXdheSwgSSBqdXN0IHRvb2sgYWN0aW9uIG9uIHRoZSBtYXR0ZXIgYW5kIGJ1aWxkIG15IG93blxuICAgICAgICAgIE1hbmdhIFJlYWRlci4gQW5keycgJ31cbiAgICAgICAgICA8YSBocmVmPVwiaHR0cDovL2xpYnJlbWFuZ2EuaGVyb2t1YXBwLmNvbS9cIj5MaWJyZW1hbmdhPC9hPiB3YXMgYm9ybi5cbiAgICAgICAgICAoRllJLCB0aGlzIGlzIG5vdCBtYWludGFpbmVkIGFuZCB0aGUgQVBJIGlzIG5vdyBpbmFjdGl2ZS4pIE15IGZpcnN0XG4gICAgICAgICAgd2ViIGFwcC4gVGhlbiB0aGUgcmVzdCBpcyBoaXN0b3J5IDopXG4gICAgICAgIDwvbW90aW9uLnA+XG5cbiAgICAgICAgPG1vdGlvbi5ibG9ja3F1b3RlXG4gICAgICAgICAgaW5pdGlhbD17eyB5OiA1MCwgb3BhY2l0eTogMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgeTogMCwgb3BhY2l0eTogMSwgdHJhbnNpdGlvbjogeyBkZWxheTogMC41IH0gfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAg4oCcQSBwcm9ibGVtIGlzIGEgY2hhbmNlIGZvciB5b3UgdG8gZG8geW91ciBiZXN0LuKAnSDigJUgRHVrZSBFbGxpbmd0b25cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvbW90aW9uLmJsb2NrcXVvdGU+XG5cbiAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgaW5pdGlhbD17eyB5OiA1MCwgb3BhY2l0eTogMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgeTogMCwgb3BhY2l0eTogMSwgdHJhbnNpdGlvbjogeyBkZWxheTogMC41IH0gfX1cbiAgICAgICAgPlxuICAgICAgICAgIEkgbGlrZSB0byB1c2UgZGlmZmVyZW50IHRlY2gvdG9vbHMgd2hlbiBjcmVhdGluZyBteSBvd24gYXBwLiBNaXggYW5kXG4gICAgICAgICAgbWF0Y2ggdG8gc2VlIHdoaWNoIHdpbGwgYmUgdGhlIGJlc3QgZml0IGZvciB0aGUgcmVxdWlyZW1lbnRzIGFuZCBteVxuICAgICAgICAgIHN0eWxlLiBUaGlzIGlzIG9uZSBvZiB0aGUgZ3JlYXQgcGFydHMgb2YgZG9pbmcgeW91ciBvd24gcHJvamVjdHMuIFlvdVxuICAgICAgICAgIGdldCB0byBkZWNpZGUgd2hpY2ggb25lIHRvIHVzZS4gSSdtIG15IG93biBCT1NTIVxuICAgICAgICA8L21vdGlvbi5wPlxuXG4gICAgICAgIDxtb3Rpb24ucFxuICAgICAgICAgIGluaXRpYWw9e3sgeTogNTAsIG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IHk6IDAsIG9wYWNpdHk6IDEsIHRyYW5zaXRpb246IHsgZGVsYXk6IDAuNSB9IH19XG4gICAgICAgID5cbiAgICAgICAgICBIZXJlIGFyZSBzb21lIG9mIG15IHBlcnNvbmFsIHByb2plY3RzLiBPciB5b3UgY2FuIGNoZWNrIG91dCBteXsnICd9XG4gICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrYW50aG9ueXV5XCI+Z2l0aHViIGFjY291bnQ8L2E+LlxuICAgICAgICA8L21vdGlvbi5wPlxuXG4gICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGlzdH1cbiAgICAgICAgICB2YXJpYW50cz17Y29udGFpbmVyfVxuICAgICAgICAgIGluaXRpYWw9XCJoaWRkZW5cIlxuICAgICAgICAgIGFuaW1hdGU9XCJzaG93XCJcbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9qZWN0cy5tYXAoKHByb2plY3QpID0+IChcbiAgICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICAgIHZhcmlhbnRzPXtpdGVtfVxuICAgICAgICAgICAgICBrZXk9e3Byb2plY3QubmFtZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHshcHJvamVjdC5hY3RpdmUgPyBzdHlsZXMuYnJva2VuIDogJyd9YH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50b3B9PlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9e3Byb2plY3QubGlua30gY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9IHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgICAgICAgICAgICAge3Byb2plY3QubmFtZX1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj17cHJvamVjdC5saW5rfSBjbGFzc05hbWU9e3N0eWxlcy5pY29ufSB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgNjQwIDY0MFwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQxLjI4IDEwLjMyM2gxNzguNzc0bDczLjA1MiA4Mi40NjZIMTE1LjE5NGMtMTcuNjEgMC0zMi4wMiAxNC40MS0zMi4wMiAzMi4wMnY0MDEuNDAzYzAgMTcuNTk4IDE0LjQxIDMyLjAyIDMyLjAyIDMyLjAyaDQwNi4zMjhjMTcuNjEgMCAzMi4wMi0xNC40MjIgMzIuMDItMzIuMDJ2LTE4MS42Mmw4My4xNzQgNjkuMTl2MTg1LjYyNGMwIDIyLjctMTguNTY3IDQxLjI4LTQxLjI4IDQxLjI4SDQxLjI4Yy0yMi43MTIgMC00MS4yOC0xOC41OC00MS4yOC00MS4yOFY1MS42MDRjMC0yMi43MDIgMTguNTY4LTQxLjI4IDQxLjI4LTQxLjI4ek02NDAtLjY4NUwzMTEuMzc4IDEzLjg0M2wxMDQuODAxIDEwNC44LTIzMC43NTUgMjMwLjc0NCAxMDEuMjEgMTAxLjIxIDIzMC43NTUtMjMwLjc1NSAxMDYuODIgMTA2LjgyTDY0MC0uNjg1elwiIC8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5kZXNjfT57cHJvamVjdC5kZXNjfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuYnVpbHR9PlxuICAgICAgICAgICAgICAgIHtwcm9qZWN0LnVzZXMubWFwKCh1LCBrZXkpID0+IChcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGtleT17YCR7dX0tJHtrZXl9YH0+e3V9PC9zcGFuPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIHshcHJvamVjdC5hY3RpdmUgPyAoXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuYnJva2VuQVBJfT5EZXByZWNhdGVkIEFQSTwvc3Bhbj5cbiAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICA8L21vdGlvbi5kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvQ29udGFpbmVyPlxuICApXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/projects.js\n");

/***/ }),

/***/ "./pages/projects.module.scss":
/*!************************************!*\
  !*** ./pages/projects.module.scss ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./projects.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./pages/projects.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element){// These elements should always exist. If they do not,\n// this code should fail.\nvar anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>\n// Each style tag should be placed right before our\n// anchor. By inserting before and not after, we do not\n// need to track the last inserted element.\nparentNode.insertBefore(element,anchorElement);};\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(!a[p]){return false;}}return true;};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./projects.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./pages/projects.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !../node_modules/next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-3-1!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-3-2!../node_modules/next/dist/compiled/resolve-url-loader??ref--5-oneOf-3-3!../node_modules/next/dist/compiled/sass-loader/cjs.js??ref--5-oneOf-3-4!./projects.module.scss */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/next/dist/compiled/resolve-url-loader/index.js?!./node_modules/next/dist/compiled/sass-loader/cjs.js?!./pages/projects.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvcHJvamVjdHMubW9kdWxlLnNjc3M/N2MwZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsbU5BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLGtrQkFBcVU7O0FBRXZXOztBQUVBO0FBQ0EsMEJBQTBCLFFBQVM7QUFDbkM7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0Esc0VBQXNFLHdDQUF3QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZDtBQUNBLGtFQUFrRSxpQkFBaUIsY0FBYyxNQUFNLFlBQVksaUNBQWlDO0FBQ3BKLFVBQVUsZ0JBQWdCLGVBQWUsWUFBWSxpQ0FBaUM7QUFDdEYsVUFBVSxVQUFVLGVBQWU7QUFDbkM7O0FBRUE7QUFDQSxNQUFNLGtrQkFBcVU7QUFDM1U7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxra0JBQXFVOztBQUUvVjs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vcGFnZXMvcHJvamVjdHMubW9kdWxlLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL3Byb2plY3RzLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS1vbmVPZi0zLTMhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0zLTQhLi9wcm9qZWN0cy5tb2R1bGUuc2Nzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtMiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LW9uZU9mLTMtMyEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTMtNCEuL3Byb2plY3RzLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/projects.module.scss\n");

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fprojects&absolutePagePath=%2Fhome%2Fmacmac%2FProjects%2Fmarkanthonyuy.github.io%2Fpages%2Fprojects.js!./","webpack"]]]);